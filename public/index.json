[{"content":"Introduction Hello, world! I\u0026rsquo;m here again :D\n","permalink":"http://localhost:1313/games/second/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eHello, world! I\u0026rsquo;m here again :D\u003c/p\u003e","title":"Second"},{"content":"Generative Design in Minecraft (GDMC) GDMC is a competition to generate settlements within a selection of a minecraft map. The project\u0026rsquo;s website provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\nMCEdit To generate settlements, the competition has gone the route of using MCEdit to allow competitors to view, generate, and modify minecraft maps. GDMC provides a wiki with easy to use instructions for installing and general set up. The wiki also provides an example cellular automata script for generating structures seen in figure one. As you can see, the output isn’t great, but it provides a nice starting point. It, also, shows how to work with the MCEdit filters which is how we can interact with the maps.\nFigure 1: Example cellular automata output from CASG_Example.py ","permalink":"http://localhost:1313/posts/second/","summary":"\u003ch1 id=\"generative-design-in-minecraft-gdmc\"\u003eGenerative Design in Minecraft (GDMC)\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eGDMC\u003c/a\u003e is a competition to generate settlements within a selection of a minecraft map. The \u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eproject\u0026rsquo;s website\u003c/a\u003e provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\u003c/p\u003e","title":"Generative Design in Mineraft: MCEdit Basics"},{"content":"This is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, Swig’s website for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on Swig\u0026rsquo;s website and a StackOverflow question for Python 3. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\n1. Install # python-dev sudo apt-get install python-dev # python2.x sudo apt-get install python3-dev # python3.x # swig sudo apt-get install swig 2. Source c++ Fibonacci implementation, filename: fib.cpp\n#include \u0026#34;fib.h\u0026#34; int fibonacci(int n) { if(n \u0026lt;= 1) return n; return fibonacci(n-1) + fibonacci(n-2); } c++ fibonacci header file, filename: fib.h. I\u0026rsquo;m going to explain why this file exists in a moment.\nint fibonacci(int n); The next file is the interface file for swig, fib.i. This is telling swig what bindings it will need to create and is why we implemented fib.h.\n%module Fibonacci %{ #include \u0026#34;fib.h\u0026#34; %} %include \u0026#34;fib.h\u0026#34; The alternative to creating the fib.h file is directly below. For this we define each function individually for swig to then bind.\n%module Fibonacci %{ int fibonacci(int n); %} int fibonacci(int n); 3. Build setup.py, this file is taken directly from Swig\u0026rsquo;s documentation and modified slightly.\n#!/usr/bin/env python from distutils.core import setup, Extension fib_module = Extension( \u0026#39;_Fibonacci\u0026#39;, sources=[\u0026#39;fib_wrap.cxx\u0026#39;, \u0026#39;fib.cpp\u0026#39;], # fib_wrap.cxx is going to be generated by swig ) setup ( name = \u0026#39;Fibonacci\u0026#39;, version = \u0026#39;0.0\u0026#39;, author = \u0026#34;YOUR_NAME\u0026#34;, description = \u0026#34;Fibonacci swig\u0026#34;, ext_modules = [fib_module], py_modules = [\u0026#34;Fibonacci\u0026#34;], # name of module that we\u0026#39;re going import ) build.sh or whatever you fancy.\n#!/bin/bash swig -c++ -python fib.i python setup.py build_ext --inplace 4. Run Assign permissions (e.g. chmod 755 build.sh) and run ./build.sh. From there you can go into the python console and test by running the following:\n$ python \u0026gt;\u0026gt;\u0026gt; import Fibonacci \u0026gt;\u0026gt;\u0026gt; Fibonacci.fibonacci(10) 55 5. Conclusion Please let me know if anything here can be improved so I can update this for future readers. Regardless, I hope this helped some of you with your projects/work and saved you some time.\n","permalink":"http://localhost:1313/posts/first/","summary":"\u003cp\u003eThis is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig’s website\u003c/a\u003e for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig\u0026rsquo;s website\u003c/a\u003e and a \u003ca href=\"https://stackoverflow.com/questions/32667888/building-extension-for-python-3-with-swig-and-distutils\"\u003eStackOverflow question for Python 3\u003c/a\u003e. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\u003c/p\u003e","title":"C++ to Python Bindings with Swig"},{"content":"Biemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). Paper\nBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). Paper\nBiemer, C., \u0026amp; Cooper, S. (2022, October). Level Assembly as a Markov Decision Process. In 2022 Proceedings of the Experimental AI in Games Workshop. Paper, Talk, Code\nBiemer, C., \u0026amp; Cooper, S. (2022, August). On Linking Level Segments. In 2022 IEEE Conference on Games (CoG) (pp. 199-205). ★ Best Paper Nominee Paper, Talk, Code\nBiemer, C., Hervella, A., \u0026amp; Cooper, S. (2021, August). Gram-Elites: N-Gram Based Quality-Diversity Search. In The 16th International Conference on the Foundations of Digital Games (FDG) 2021 (pp. 1-6). Paper, Talk, Code\nVillareale, J., Biemer, C., Seif El-Nasr, M., \u0026amp; Zhu, J. (2020, September). Reflection in Game-Based Learning: A Survey of Programming Games. In International Conference on the Foundations of Digital Games (pp. 1-9). Paper\n","permalink":"http://localhost:1313/publications/","summary":"\u003cp\u003eBiemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). \u003cbr\u003e\n\u003ca href=\"/pdf/2024_solution_path_heuristics.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). \u003cbr\u003e\n\u003ca href=\"/pdf/2023_ddaviaplgviamdp.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e","title":"Publications"},{"content":"Introduction Hello, world! I\u0026rsquo;m here again :D\n","permalink":"http://localhost:1313/games/second/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eHello, world! I\u0026rsquo;m here again :D\u003c/p\u003e","title":"Second"},{"content":"Generative Design in Minecraft (GDMC) GDMC is a competition to generate settlements within a selection of a minecraft map. The project\u0026rsquo;s website provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\nMCEdit To generate settlements, the competition has gone the route of using MCEdit to allow competitors to view, generate, and modify minecraft maps. GDMC provides a wiki with easy to use instructions for installing and general set up. The wiki also provides an example cellular automata script for generating structures seen in figure one. As you can see, the output isn’t great, but it provides a nice starting point. It, also, shows how to work with the MCEdit filters which is how we can interact with the maps.\nFigure 1: Example cellular automata output from CASG_Example.py Filters A filter is how we are able to modify maps. To activate a filter, a user makes a selection on the map via a left click and dragging your mouse. From there, on the bottom of the screen, there is a potion looking icon that when pressed will open the filter menu. This provides a drop down menu of available filters. Each of these filters provides a set of options and the ability to perform their respective actions. When activated they will make modifications to the map given the users selection area. Each of the filters are Python 2.7 scripts located in the stock-filters directory.\n","permalink":"http://localhost:1313/posts/second/","summary":"\u003ch1 id=\"generative-design-in-minecraft-gdmc\"\u003eGenerative Design in Minecraft (GDMC)\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eGDMC\u003c/a\u003e is a competition to generate settlements within a selection of a minecraft map. The \u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eproject\u0026rsquo;s website\u003c/a\u003e provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\u003c/p\u003e","title":"Generative Design in Mineraft: MCEdit Basics"},{"content":"This is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, Swig’s website for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on Swig\u0026rsquo;s website and a StackOverflow question for Python 3. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\n1. Install # python-dev sudo apt-get install python-dev # python2.x sudo apt-get install python3-dev # python3.x # swig sudo apt-get install swig 2. Source c++ Fibonacci implementation, filename: fib.cpp\n#include \u0026#34;fib.h\u0026#34; int fibonacci(int n) { if(n \u0026lt;= 1) return n; return fibonacci(n-1) + fibonacci(n-2); } c++ fibonacci header file, filename: fib.h. I\u0026rsquo;m going to explain why this file exists in a moment.\nint fibonacci(int n); The next file is the interface file for swig, fib.i. This is telling swig what bindings it will need to create and is why we implemented fib.h.\n%module Fibonacci %{ #include \u0026#34;fib.h\u0026#34; %} %include \u0026#34;fib.h\u0026#34; The alternative to creating the fib.h file is directly below. For this we define each function individually for swig to then bind.\n%module Fibonacci %{ int fibonacci(int n); %} int fibonacci(int n); 3. Build setup.py, this file is taken directly from Swig\u0026rsquo;s documentation and modified slightly.\n#!/usr/bin/env python from distutils.core import setup, Extension fib_module = Extension( \u0026#39;_Fibonacci\u0026#39;, sources=[\u0026#39;fib_wrap.cxx\u0026#39;, \u0026#39;fib.cpp\u0026#39;], # fib_wrap.cxx is going to be generated by swig ) setup ( name = \u0026#39;Fibonacci\u0026#39;, version = \u0026#39;0.0\u0026#39;, author = \u0026#34;YOUR_NAME\u0026#34;, description = \u0026#34;Fibonacci swig\u0026#34;, ext_modules = [fib_module], py_modules = [\u0026#34;Fibonacci\u0026#34;], # name of module that we\u0026#39;re going import ) build.sh or whatever you fancy.\n#!/bin/bash swig -c++ -python fib.i python setup.py build_ext --inplace 4. Run Assign permissions (e.g. chmod 755 build.sh) and run ./build.sh. From there you can go into the python console and test by running the following:\n$ python \u0026gt;\u0026gt;\u0026gt; import Fibonacci \u0026gt;\u0026gt;\u0026gt; Fibonacci.fibonacci(10) 55 5. Conclusion Please let me know if anything here can be improved so I can update this for future readers. Regardless, I hope this helped some of you with your projects/work and saved you some time.\n","permalink":"http://localhost:1313/posts/first/","summary":"\u003cp\u003eThis is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig’s website\u003c/a\u003e for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig\u0026rsquo;s website\u003c/a\u003e and a \u003ca href=\"https://stackoverflow.com/questions/32667888/building-extension-for-python-3-with-swig-and-distutils\"\u003eStackOverflow question for Python 3\u003c/a\u003e. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\u003c/p\u003e","title":"C++ to Python Bindings with Swig"},{"content":"Biemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). Paper\nBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). Paper\nBiemer, C., \u0026amp; Cooper, S. (2022, October). Level Assembly as a Markov Decision Process. In 2022 Proceedings of the Experimental AI in Games Workshop. Paper, Talk, Code\nBiemer, C., \u0026amp; Cooper, S. (2022, August). On Linking Level Segments. In 2022 IEEE Conference on Games (CoG) (pp. 199-205). ★ Best Paper Nominee Paper, Talk, Code\nBiemer, C., Hervella, A., \u0026amp; Cooper, S. (2021, August). Gram-Elites: N-Gram Based Quality-Diversity Search. In The 16th International Conference on the Foundations of Digital Games (FDG) 2021 (pp. 1-6). Paper, Talk, Code\nVillareale, J., Biemer, C., Seif El-Nasr, M., \u0026amp; Zhu, J. (2020, September). Reflection in Game-Based Learning: A Survey of Programming Games. In International Conference on the Foundations of Digital Games (pp. 1-9). Paper\n","permalink":"http://localhost:1313/publications/","summary":"\u003cp\u003eBiemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). \u003cbr\u003e\n\u003ca href=\"/pdf/2024_solution_path_heuristics.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). \u003cbr\u003e\n\u003ca href=\"/pdf/2023_ddaviaplgviamdp.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e","title":"Publications"},{"content":"Introduction Hello, world! I\u0026rsquo;m here again :D\n","permalink":"http://localhost:1313/games/second/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eHello, world! I\u0026rsquo;m here again :D\u003c/p\u003e","title":"Second"},{"content":"Generative Design in Minecraft (GDMC) GDMC is a competition to generate settlements within a selection of a minecraft map. The project\u0026rsquo;s website provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\nMCEdit To generate settlements, the competition has gone the route of using MCEdit to allow competitors to view, generate, and modify minecraft maps. GDMC provides a wiki with easy to use instructions for installing and general set up. The wiki also provides an example cellular automata script for generating structures seen in figure one. As you can see, the output isn’t great, but it provides a nice starting point. It, also, shows how to work with the MCEdit filters which is how we can interact with the maps.\nFigure 1: Example cellular automata output from CASG_Example.py Filters A filter is how we are able to modify maps. To activate a filter, a user makes a selection on the map via a left click and dragging your mouse. From there, on the bottom of the screen, there is a potion looking icon that when pressed will open the filter menu. This provides a drop down menu of available filters. Each of these filters provides a set of options and the ability to perform their respective actions. When activated they will make modifications to the map given the users selection area. Each of the filters are Python 2.7 scripts located in the stock-filters directory.\nFilter Basics The wiki provides some helpful commentary in getting started with filters, but the script is a bit too complicated for a starting point. There are, however, two things that every filter has in common: the perform function and inputs tuple.\n","permalink":"http://localhost:1313/posts/second/","summary":"\u003ch1 id=\"generative-design-in-minecraft-gdmc\"\u003eGenerative Design in Minecraft (GDMC)\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eGDMC\u003c/a\u003e is a competition to generate settlements within a selection of a minecraft map. The \u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eproject\u0026rsquo;s website\u003c/a\u003e provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\u003c/p\u003e","title":"Generative Design in Mineraft: MCEdit Basics"},{"content":"This is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, Swig’s website for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on Swig\u0026rsquo;s website and a StackOverflow question for Python 3. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\n1. Install # python-dev sudo apt-get install python-dev # python2.x sudo apt-get install python3-dev # python3.x # swig sudo apt-get install swig 2. Source c++ Fibonacci implementation, filename: fib.cpp\n#include \u0026#34;fib.h\u0026#34; int fibonacci(int n) { if(n \u0026lt;= 1) return n; return fibonacci(n-1) + fibonacci(n-2); } c++ fibonacci header file, filename: fib.h. I\u0026rsquo;m going to explain why this file exists in a moment.\nint fibonacci(int n); The next file is the interface file for swig, fib.i. This is telling swig what bindings it will need to create and is why we implemented fib.h.\n%module Fibonacci %{ #include \u0026#34;fib.h\u0026#34; %} %include \u0026#34;fib.h\u0026#34; The alternative to creating the fib.h file is directly below. For this we define each function individually for swig to then bind.\n%module Fibonacci %{ int fibonacci(int n); %} int fibonacci(int n); 3. Build setup.py, this file is taken directly from Swig\u0026rsquo;s documentation and modified slightly.\n#!/usr/bin/env python from distutils.core import setup, Extension fib_module = Extension( \u0026#39;_Fibonacci\u0026#39;, sources=[\u0026#39;fib_wrap.cxx\u0026#39;, \u0026#39;fib.cpp\u0026#39;], # fib_wrap.cxx is going to be generated by swig ) setup ( name = \u0026#39;Fibonacci\u0026#39;, version = \u0026#39;0.0\u0026#39;, author = \u0026#34;YOUR_NAME\u0026#34;, description = \u0026#34;Fibonacci swig\u0026#34;, ext_modules = [fib_module], py_modules = [\u0026#34;Fibonacci\u0026#34;], # name of module that we\u0026#39;re going import ) build.sh or whatever you fancy.\n#!/bin/bash swig -c++ -python fib.i python setup.py build_ext --inplace 4. Run Assign permissions (e.g. chmod 755 build.sh) and run ./build.sh. From there you can go into the python console and test by running the following:\n$ python \u0026gt;\u0026gt;\u0026gt; import Fibonacci \u0026gt;\u0026gt;\u0026gt; Fibonacci.fibonacci(10) 55 5. Conclusion Please let me know if anything here can be improved so I can update this for future readers. Regardless, I hope this helped some of you with your projects/work and saved you some time.\n","permalink":"http://localhost:1313/posts/first/","summary":"\u003cp\u003eThis is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig’s website\u003c/a\u003e for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig\u0026rsquo;s website\u003c/a\u003e and a \u003ca href=\"https://stackoverflow.com/questions/32667888/building-extension-for-python-3-with-swig-and-distutils\"\u003eStackOverflow question for Python 3\u003c/a\u003e. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\u003c/p\u003e","title":"C++ to Python Bindings with Swig"},{"content":"Biemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). Paper\nBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). Paper\nBiemer, C., \u0026amp; Cooper, S. (2022, October). Level Assembly as a Markov Decision Process. In 2022 Proceedings of the Experimental AI in Games Workshop. Paper, Talk, Code\nBiemer, C., \u0026amp; Cooper, S. (2022, August). On Linking Level Segments. In 2022 IEEE Conference on Games (CoG) (pp. 199-205). ★ Best Paper Nominee Paper, Talk, Code\nBiemer, C., Hervella, A., \u0026amp; Cooper, S. (2021, August). Gram-Elites: N-Gram Based Quality-Diversity Search. In The 16th International Conference on the Foundations of Digital Games (FDG) 2021 (pp. 1-6). Paper, Talk, Code\nVillareale, J., Biemer, C., Seif El-Nasr, M., \u0026amp; Zhu, J. (2020, September). Reflection in Game-Based Learning: A Survey of Programming Games. In International Conference on the Foundations of Digital Games (pp. 1-9). Paper\n","permalink":"http://localhost:1313/publications/","summary":"\u003cp\u003eBiemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). \u003cbr\u003e\n\u003ca href=\"/pdf/2024_solution_path_heuristics.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). \u003cbr\u003e\n\u003ca href=\"/pdf/2023_ddaviaplgviamdp.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e","title":"Publications"},{"content":"Introduction Hello, world! I\u0026rsquo;m here again :D\n","permalink":"http://localhost:1313/games/second/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eHello, world! I\u0026rsquo;m here again :D\u003c/p\u003e","title":"Second"},{"content":"Generative Design in Minecraft (GDMC) GDMC is a competition to generate settlements within a selection of a minecraft map. The project\u0026rsquo;s website provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\nMCEdit To generate settlements, the competition has gone the route of using MCEdit to allow competitors to view, generate, and modify minecraft maps. GDMC provides a wiki with easy to use instructions for installing and general set up. The wiki also provides an example cellular automata script for generating structures seen in figure one. As you can see, the output isn’t great, but it provides a nice starting point. It, also, shows how to work with the MCEdit filters which is how we can interact with the maps.\nFigure 1: Example cellular automata output from CASG_Example.py Filters A filter is how we are able to modify maps. To activate a filter, a user makes a selection on the map via a left click and dragging your mouse. From there, on the bottom of the screen, there is a potion looking icon that when pressed will open the filter menu. This provides a drop down menu of available filters. Each of these filters provides a set of options and the ability to perform their respective actions. When activated they will make modifications to the map given the users selection area. Each of the filters are Python 2.7 scripts located in the stock-filters directory.\nFilter Basics The wiki provides some helpful commentary in getting started with filters, but the script is a bit too complicated for a starting point. There are, however, two things that every filter has in common: the perform function and inputs tuple.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def perform(level, box, options): pass ","permalink":"http://localhost:1313/posts/second/","summary":"\u003ch1 id=\"generative-design-in-minecraft-gdmc\"\u003eGenerative Design in Minecraft (GDMC)\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eGDMC\u003c/a\u003e is a competition to generate settlements within a selection of a minecraft map. The \u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eproject\u0026rsquo;s website\u003c/a\u003e provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\u003c/p\u003e","title":"Generative Design in Mineraft: MCEdit Basics"},{"content":"This is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, Swig’s website for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on Swig\u0026rsquo;s website and a StackOverflow question for Python 3. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\n1. Install # python-dev sudo apt-get install python-dev # python2.x sudo apt-get install python3-dev # python3.x # swig sudo apt-get install swig 2. Source c++ Fibonacci implementation, filename: fib.cpp\n#include \u0026#34;fib.h\u0026#34; int fibonacci(int n) { if(n \u0026lt;= 1) return n; return fibonacci(n-1) + fibonacci(n-2); } c++ fibonacci header file, filename: fib.h. I\u0026rsquo;m going to explain why this file exists in a moment.\nint fibonacci(int n); The next file is the interface file for swig, fib.i. This is telling swig what bindings it will need to create and is why we implemented fib.h.\n%module Fibonacci %{ #include \u0026#34;fib.h\u0026#34; %} %include \u0026#34;fib.h\u0026#34; The alternative to creating the fib.h file is directly below. For this we define each function individually for swig to then bind.\n%module Fibonacci %{ int fibonacci(int n); %} int fibonacci(int n); 3. Build setup.py, this file is taken directly from Swig\u0026rsquo;s documentation and modified slightly.\n#!/usr/bin/env python from distutils.core import setup, Extension fib_module = Extension( \u0026#39;_Fibonacci\u0026#39;, sources=[\u0026#39;fib_wrap.cxx\u0026#39;, \u0026#39;fib.cpp\u0026#39;], # fib_wrap.cxx is going to be generated by swig ) setup ( name = \u0026#39;Fibonacci\u0026#39;, version = \u0026#39;0.0\u0026#39;, author = \u0026#34;YOUR_NAME\u0026#34;, description = \u0026#34;Fibonacci swig\u0026#34;, ext_modules = [fib_module], py_modules = [\u0026#34;Fibonacci\u0026#34;], # name of module that we\u0026#39;re going import ) build.sh or whatever you fancy.\n#!/bin/bash swig -c++ -python fib.i python setup.py build_ext --inplace 4. Run Assign permissions (e.g. chmod 755 build.sh) and run ./build.sh. From there you can go into the python console and test by running the following:\n$ python \u0026gt;\u0026gt;\u0026gt; import Fibonacci \u0026gt;\u0026gt;\u0026gt; Fibonacci.fibonacci(10) 55 5. Conclusion Please let me know if anything here can be improved so I can update this for future readers. Regardless, I hope this helped some of you with your projects/work and saved you some time.\n","permalink":"http://localhost:1313/posts/first/","summary":"\u003cp\u003eThis is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig’s website\u003c/a\u003e for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig\u0026rsquo;s website\u003c/a\u003e and a \u003ca href=\"https://stackoverflow.com/questions/32667888/building-extension-for-python-3-with-swig-and-distutils\"\u003eStackOverflow question for Python 3\u003c/a\u003e. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\u003c/p\u003e","title":"C++ to Python Bindings with Swig"},{"content":"Biemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). Paper\nBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). Paper\nBiemer, C., \u0026amp; Cooper, S. (2022, October). Level Assembly as a Markov Decision Process. In 2022 Proceedings of the Experimental AI in Games Workshop. Paper, Talk, Code\nBiemer, C., \u0026amp; Cooper, S. (2022, August). On Linking Level Segments. In 2022 IEEE Conference on Games (CoG) (pp. 199-205). ★ Best Paper Nominee Paper, Talk, Code\nBiemer, C., Hervella, A., \u0026amp; Cooper, S. (2021, August). Gram-Elites: N-Gram Based Quality-Diversity Search. In The 16th International Conference on the Foundations of Digital Games (FDG) 2021 (pp. 1-6). Paper, Talk, Code\nVillareale, J., Biemer, C., Seif El-Nasr, M., \u0026amp; Zhu, J. (2020, September). Reflection in Game-Based Learning: A Survey of Programming Games. In International Conference on the Foundations of Digital Games (pp. 1-9). Paper\n","permalink":"http://localhost:1313/publications/","summary":"\u003cp\u003eBiemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). \u003cbr\u003e\n\u003ca href=\"/pdf/2024_solution_path_heuristics.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). \u003cbr\u003e\n\u003ca href=\"/pdf/2023_ddaviaplgviamdp.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e","title":"Publications"},{"content":"Introduction Hello, world! I\u0026rsquo;m here again :D\n","permalink":"http://localhost:1313/games/second/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eHello, world! I\u0026rsquo;m here again :D\u003c/p\u003e","title":"Second"},{"content":"Generative Design in Minecraft (GDMC) GDMC is a competition to generate settlements within a selection of a minecraft map. The project\u0026rsquo;s website provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\nMCEdit To generate settlements, the competition has gone the route of using MCEdit to allow competitors to view, generate, and modify minecraft maps. GDMC provides a wiki with easy to use instructions for installing and general set up. The wiki also provides an example cellular automata script for generating structures seen in figure one. As you can see, the output isn’t great, but it provides a nice starting point. It, also, shows how to work with the MCEdit filters which is how we can interact with the maps.\nFigure 1: Example cellular automata output from CASG_Example.py Filters A filter is how we are able to modify maps. To activate a filter, a user makes a selection on the map via a left click and dragging your mouse. From there, on the bottom of the screen, there is a potion looking icon that when pressed will open the filter menu. This provides a drop down menu of available filters. Each of these filters provides a set of options and the ability to perform their respective actions. When activated they will make modifications to the map given the users selection area. Each of the filters are Python 2.7 scripts located in the stock-filters directory.\nFilter Basics The wiki provides some helpful commentary in getting started with filters, but the script is a bit too complicated for a starting point. There are, however, two things that every filter has in common: the perform function and inputs tuple.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def perform(level, box, options): pass When a filter is activated, the engine will call the perform function and pass the level data (this data structure will be explored further in the next post), the bounding box, and the set of options a user has defined. The bounding box defines the origin of the box the user created and the size. The options is a dictionary based on the inputs defined in the above script. Therefore, to access the materials you could use options[“Material”] to be able to see what the user set.\n","permalink":"http://localhost:1313/posts/second/","summary":"\u003ch1 id=\"generative-design-in-minecraft-gdmc\"\u003eGenerative Design in Minecraft (GDMC)\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eGDMC\u003c/a\u003e is a competition to generate settlements within a selection of a minecraft map. The \u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eproject\u0026rsquo;s website\u003c/a\u003e provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\u003c/p\u003e","title":"Generative Design in Mineraft: MCEdit Basics"},{"content":"This is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, Swig’s website for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on Swig\u0026rsquo;s website and a StackOverflow question for Python 3. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\n1. Install # python-dev sudo apt-get install python-dev # python2.x sudo apt-get install python3-dev # python3.x # swig sudo apt-get install swig 2. Source c++ Fibonacci implementation, filename: fib.cpp\n#include \u0026#34;fib.h\u0026#34; int fibonacci(int n) { if(n \u0026lt;= 1) return n; return fibonacci(n-1) + fibonacci(n-2); } c++ fibonacci header file, filename: fib.h. I\u0026rsquo;m going to explain why this file exists in a moment.\nint fibonacci(int n); The next file is the interface file for swig, fib.i. This is telling swig what bindings it will need to create and is why we implemented fib.h.\n%module Fibonacci %{ #include \u0026#34;fib.h\u0026#34; %} %include \u0026#34;fib.h\u0026#34; The alternative to creating the fib.h file is directly below. For this we define each function individually for swig to then bind.\n%module Fibonacci %{ int fibonacci(int n); %} int fibonacci(int n); 3. Build setup.py, this file is taken directly from Swig\u0026rsquo;s documentation and modified slightly.\n#!/usr/bin/env python from distutils.core import setup, Extension fib_module = Extension( \u0026#39;_Fibonacci\u0026#39;, sources=[\u0026#39;fib_wrap.cxx\u0026#39;, \u0026#39;fib.cpp\u0026#39;], # fib_wrap.cxx is going to be generated by swig ) setup ( name = \u0026#39;Fibonacci\u0026#39;, version = \u0026#39;0.0\u0026#39;, author = \u0026#34;YOUR_NAME\u0026#34;, description = \u0026#34;Fibonacci swig\u0026#34;, ext_modules = [fib_module], py_modules = [\u0026#34;Fibonacci\u0026#34;], # name of module that we\u0026#39;re going import ) build.sh or whatever you fancy.\n#!/bin/bash swig -c++ -python fib.i python setup.py build_ext --inplace 4. Run Assign permissions (e.g. chmod 755 build.sh) and run ./build.sh. From there you can go into the python console and test by running the following:\n$ python \u0026gt;\u0026gt;\u0026gt; import Fibonacci \u0026gt;\u0026gt;\u0026gt; Fibonacci.fibonacci(10) 55 5. Conclusion Please let me know if anything here can be improved so I can update this for future readers. Regardless, I hope this helped some of you with your projects/work and saved you some time.\n","permalink":"http://localhost:1313/posts/first/","summary":"\u003cp\u003eThis is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig’s website\u003c/a\u003e for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig\u0026rsquo;s website\u003c/a\u003e and a \u003ca href=\"https://stackoverflow.com/questions/32667888/building-extension-for-python-3-with-swig-and-distutils\"\u003eStackOverflow question for Python 3\u003c/a\u003e. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\u003c/p\u003e","title":"C++ to Python Bindings with Swig"},{"content":"Biemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). Paper\nBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). Paper\nBiemer, C., \u0026amp; Cooper, S. (2022, October). Level Assembly as a Markov Decision Process. In 2022 Proceedings of the Experimental AI in Games Workshop. Paper, Talk, Code\nBiemer, C., \u0026amp; Cooper, S. (2022, August). On Linking Level Segments. In 2022 IEEE Conference on Games (CoG) (pp. 199-205). ★ Best Paper Nominee Paper, Talk, Code\nBiemer, C., Hervella, A., \u0026amp; Cooper, S. (2021, August). Gram-Elites: N-Gram Based Quality-Diversity Search. In The 16th International Conference on the Foundations of Digital Games (FDG) 2021 (pp. 1-6). Paper, Talk, Code\nVillareale, J., Biemer, C., Seif El-Nasr, M., \u0026amp; Zhu, J. (2020, September). Reflection in Game-Based Learning: A Survey of Programming Games. In International Conference on the Foundations of Digital Games (pp. 1-9). Paper\n","permalink":"http://localhost:1313/publications/","summary":"\u003cp\u003eBiemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). \u003cbr\u003e\n\u003ca href=\"/pdf/2024_solution_path_heuristics.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). \u003cbr\u003e\n\u003ca href=\"/pdf/2023_ddaviaplgviamdp.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e","title":"Publications"},{"content":"Introduction Hello, world! I\u0026rsquo;m here again :D\n","permalink":"http://localhost:1313/games/second/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eHello, world! I\u0026rsquo;m here again :D\u003c/p\u003e","title":"Second"},{"content":"Generative Design in Minecraft (GDMC) GDMC is a competition to generate settlements within a selection of a minecraft map. The project\u0026rsquo;s website provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\nMCEdit To generate settlements, the competition has gone the route of using MCEdit to allow competitors to view, generate, and modify minecraft maps. GDMC provides a wiki with easy to use instructions for installing and general set up. The wiki also provides an example cellular automata script for generating structures seen in figure one. As you can see, the output isn’t great, but it provides a nice starting point. It, also, shows how to work with the MCEdit filters which is how we can interact with the maps.\nFigure 1: Example cellular automata output from CASG_Example.py Filters A filter is how we are able to modify maps. To activate a filter, a user makes a selection on the map via a left click and dragging your mouse. From there, on the bottom of the screen, there is a potion looking icon that when pressed will open the filter menu. This provides a drop down menu of available filters. Each of these filters provides a set of options and the ability to perform their respective actions. When activated they will make modifications to the map given the users selection area. Each of the filters are Python 2.7 scripts located in the stock-filters directory.\nFilter Basics The wiki provides some helpful commentary in getting started with filters, but the script is a bit too complicated for a starting point. There are, however, two things that every filter has in common: the perform function and inputs tuple.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def perform(level, box, options): pass When a filter is activated, the engine will call the perform function and pass the level data (this data structure will be explored further in the next post), the bounding box, and the set of options a user has defined. The bounding box defines the origin of the box the user created and the size. The options is a dictionary based on the inputs defined in the above script. Therefore, to access the materials you could use options[“Material”] to be able to see what the user set.\nBox in all Eight Corners of Selection Now that we understand the basics, we can start with a simple filter. The goal of this filter is to place a user defined material in all eight corners of the user’s selection. The end result can be seen in figure two. The first step here is to define the inputs for the user. In this case, the above inputs code is exactly what we need.\n","permalink":"http://localhost:1313/posts/second/","summary":"\u003ch1 id=\"generative-design-in-minecraft-gdmc\"\u003eGenerative Design in Minecraft (GDMC)\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eGDMC\u003c/a\u003e is a competition to generate settlements within a selection of a minecraft map. The \u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eproject\u0026rsquo;s website\u003c/a\u003e provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\u003c/p\u003e","title":"Generative Design in Mineraft: MCEdit Basics"},{"content":"This is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, Swig’s website for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on Swig\u0026rsquo;s website and a StackOverflow question for Python 3. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\n1. Install # python-dev sudo apt-get install python-dev # python2.x sudo apt-get install python3-dev # python3.x # swig sudo apt-get install swig 2. Source c++ Fibonacci implementation, filename: fib.cpp\n#include \u0026#34;fib.h\u0026#34; int fibonacci(int n) { if(n \u0026lt;= 1) return n; return fibonacci(n-1) + fibonacci(n-2); } c++ fibonacci header file, filename: fib.h. I\u0026rsquo;m going to explain why this file exists in a moment.\nint fibonacci(int n); The next file is the interface file for swig, fib.i. This is telling swig what bindings it will need to create and is why we implemented fib.h.\n%module Fibonacci %{ #include \u0026#34;fib.h\u0026#34; %} %include \u0026#34;fib.h\u0026#34; The alternative to creating the fib.h file is directly below. For this we define each function individually for swig to then bind.\n%module Fibonacci %{ int fibonacci(int n); %} int fibonacci(int n); 3. Build setup.py, this file is taken directly from Swig\u0026rsquo;s documentation and modified slightly.\n#!/usr/bin/env python from distutils.core import setup, Extension fib_module = Extension( \u0026#39;_Fibonacci\u0026#39;, sources=[\u0026#39;fib_wrap.cxx\u0026#39;, \u0026#39;fib.cpp\u0026#39;], # fib_wrap.cxx is going to be generated by swig ) setup ( name = \u0026#39;Fibonacci\u0026#39;, version = \u0026#39;0.0\u0026#39;, author = \u0026#34;YOUR_NAME\u0026#34;, description = \u0026#34;Fibonacci swig\u0026#34;, ext_modules = [fib_module], py_modules = [\u0026#34;Fibonacci\u0026#34;], # name of module that we\u0026#39;re going import ) build.sh or whatever you fancy.\n#!/bin/bash swig -c++ -python fib.i python setup.py build_ext --inplace 4. Run Assign permissions (e.g. chmod 755 build.sh) and run ./build.sh. From there you can go into the python console and test by running the following:\n$ python \u0026gt;\u0026gt;\u0026gt; import Fibonacci \u0026gt;\u0026gt;\u0026gt; Fibonacci.fibonacci(10) 55 5. Conclusion Please let me know if anything here can be improved so I can update this for future readers. Regardless, I hope this helped some of you with your projects/work and saved you some time.\n","permalink":"http://localhost:1313/posts/first/","summary":"\u003cp\u003eThis is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig’s website\u003c/a\u003e for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig\u0026rsquo;s website\u003c/a\u003e and a \u003ca href=\"https://stackoverflow.com/questions/32667888/building-extension-for-python-3-with-swig-and-distutils\"\u003eStackOverflow question for Python 3\u003c/a\u003e. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\u003c/p\u003e","title":"C++ to Python Bindings with Swig"},{"content":"Biemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). Paper\nBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). Paper\nBiemer, C., \u0026amp; Cooper, S. (2022, October). Level Assembly as a Markov Decision Process. In 2022 Proceedings of the Experimental AI in Games Workshop. Paper, Talk, Code\nBiemer, C., \u0026amp; Cooper, S. (2022, August). On Linking Level Segments. In 2022 IEEE Conference on Games (CoG) (pp. 199-205). ★ Best Paper Nominee Paper, Talk, Code\nBiemer, C., Hervella, A., \u0026amp; Cooper, S. (2021, August). Gram-Elites: N-Gram Based Quality-Diversity Search. In The 16th International Conference on the Foundations of Digital Games (FDG) 2021 (pp. 1-6). Paper, Talk, Code\nVillareale, J., Biemer, C., Seif El-Nasr, M., \u0026amp; Zhu, J. (2020, September). Reflection in Game-Based Learning: A Survey of Programming Games. In International Conference on the Foundations of Digital Games (pp. 1-9). Paper\n","permalink":"http://localhost:1313/publications/","summary":"\u003cp\u003eBiemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). \u003cbr\u003e\n\u003ca href=\"/pdf/2024_solution_path_heuristics.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). \u003cbr\u003e\n\u003ca href=\"/pdf/2023_ddaviaplgviamdp.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e","title":"Publications"},{"content":"Introduction Hello, world! I\u0026rsquo;m here again :D\n","permalink":"http://localhost:1313/games/second/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eHello, world! I\u0026rsquo;m here again :D\u003c/p\u003e","title":"Second"},{"content":"Generative Design in Minecraft (GDMC) GDMC is a competition to generate settlements within a selection of a minecraft map. The project\u0026rsquo;s website provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\nMCEdit To generate settlements, the competition has gone the route of using MCEdit to allow competitors to view, generate, and modify minecraft maps. GDMC provides a wiki with easy to use instructions for installing and general set up. The wiki also provides an example cellular automata script for generating structures seen in figure one. As you can see, the output isn’t great, but it provides a nice starting point. It, also, shows how to work with the MCEdit filters which is how we can interact with the maps.\nFigure 1: Example cellular automata output from CASG_Example.py Filters A filter is how we are able to modify maps. To activate a filter, a user makes a selection on the map via a left click and dragging your mouse. From there, on the bottom of the screen, there is a potion looking icon that when pressed will open the filter menu. This provides a drop down menu of available filters. Each of these filters provides a set of options and the ability to perform their respective actions. When activated they will make modifications to the map given the users selection area. Each of the filters are Python 2.7 scripts located in the stock-filters directory.\nFilter Basics The wiki provides some helpful commentary in getting started with filters, but the script is a bit too complicated for a starting point. There are, however, two things that every filter has in common: the perform function and inputs tuple.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def perform(level, box, options): pass When a filter is activated, the engine will call the perform function and pass the level data (this data structure will be explored further in the next post), the bounding box, and the set of options a user has defined. The bounding box defines the origin of the box the user created and the size. The options is a dictionary based on the inputs defined in the above script. Therefore, to access the materials you could use options[“Material”] to be able to see what the user set.\nBox in all Eight Corners of Selection Now that we understand the basics, we can start with a simple filter. The goal of this filter is to place a user defined material in all eight corners of the user’s selection. The end result can be seen in figure two. The first step here is to define the inputs for the user. In this case, the above inputs code is exactly what we need.\nFigure 2: Example of placing blocks at all eight corners of user\u0026#39;s selection space ","permalink":"http://localhost:1313/posts/second/","summary":"\u003ch1 id=\"generative-design-in-minecraft-gdmc\"\u003eGenerative Design in Minecraft (GDMC)\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eGDMC\u003c/a\u003e is a competition to generate settlements within a selection of a minecraft map. The \u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eproject\u0026rsquo;s website\u003c/a\u003e provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\u003c/p\u003e","title":"Generative Design in Mineraft: MCEdit Basics"},{"content":"This is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, Swig’s website for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on Swig\u0026rsquo;s website and a StackOverflow question for Python 3. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\n1. Install # python-dev sudo apt-get install python-dev # python2.x sudo apt-get install python3-dev # python3.x # swig sudo apt-get install swig 2. Source c++ Fibonacci implementation, filename: fib.cpp\n#include \u0026#34;fib.h\u0026#34; int fibonacci(int n) { if(n \u0026lt;= 1) return n; return fibonacci(n-1) + fibonacci(n-2); } c++ fibonacci header file, filename: fib.h. I\u0026rsquo;m going to explain why this file exists in a moment.\nint fibonacci(int n); The next file is the interface file for swig, fib.i. This is telling swig what bindings it will need to create and is why we implemented fib.h.\n%module Fibonacci %{ #include \u0026#34;fib.h\u0026#34; %} %include \u0026#34;fib.h\u0026#34; The alternative to creating the fib.h file is directly below. For this we define each function individually for swig to then bind.\n%module Fibonacci %{ int fibonacci(int n); %} int fibonacci(int n); 3. Build setup.py, this file is taken directly from Swig\u0026rsquo;s documentation and modified slightly.\n#!/usr/bin/env python from distutils.core import setup, Extension fib_module = Extension( \u0026#39;_Fibonacci\u0026#39;, sources=[\u0026#39;fib_wrap.cxx\u0026#39;, \u0026#39;fib.cpp\u0026#39;], # fib_wrap.cxx is going to be generated by swig ) setup ( name = \u0026#39;Fibonacci\u0026#39;, version = \u0026#39;0.0\u0026#39;, author = \u0026#34;YOUR_NAME\u0026#34;, description = \u0026#34;Fibonacci swig\u0026#34;, ext_modules = [fib_module], py_modules = [\u0026#34;Fibonacci\u0026#34;], # name of module that we\u0026#39;re going import ) build.sh or whatever you fancy.\n#!/bin/bash swig -c++ -python fib.i python setup.py build_ext --inplace 4. Run Assign permissions (e.g. chmod 755 build.sh) and run ./build.sh. From there you can go into the python console and test by running the following:\n$ python \u0026gt;\u0026gt;\u0026gt; import Fibonacci \u0026gt;\u0026gt;\u0026gt; Fibonacci.fibonacci(10) 55 5. Conclusion Please let me know if anything here can be improved so I can update this for future readers. Regardless, I hope this helped some of you with your projects/work and saved you some time.\n","permalink":"http://localhost:1313/posts/first/","summary":"\u003cp\u003eThis is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig’s website\u003c/a\u003e for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig\u0026rsquo;s website\u003c/a\u003e and a \u003ca href=\"https://stackoverflow.com/questions/32667888/building-extension-for-python-3-with-swig-and-distutils\"\u003eStackOverflow question for Python 3\u003c/a\u003e. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\u003c/p\u003e","title":"C++ to Python Bindings with Swig"},{"content":"Biemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). Paper\nBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). Paper\nBiemer, C., \u0026amp; Cooper, S. (2022, October). Level Assembly as a Markov Decision Process. In 2022 Proceedings of the Experimental AI in Games Workshop. Paper, Talk, Code\nBiemer, C., \u0026amp; Cooper, S. (2022, August). On Linking Level Segments. In 2022 IEEE Conference on Games (CoG) (pp. 199-205). ★ Best Paper Nominee Paper, Talk, Code\nBiemer, C., Hervella, A., \u0026amp; Cooper, S. (2021, August). Gram-Elites: N-Gram Based Quality-Diversity Search. In The 16th International Conference on the Foundations of Digital Games (FDG) 2021 (pp. 1-6). Paper, Talk, Code\nVillareale, J., Biemer, C., Seif El-Nasr, M., \u0026amp; Zhu, J. (2020, September). Reflection in Game-Based Learning: A Survey of Programming Games. In International Conference on the Foundations of Digital Games (pp. 1-9). Paper\n","permalink":"http://localhost:1313/publications/","summary":"\u003cp\u003eBiemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). \u003cbr\u003e\n\u003ca href=\"/pdf/2024_solution_path_heuristics.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). \u003cbr\u003e\n\u003ca href=\"/pdf/2023_ddaviaplgviamdp.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e","title":"Publications"},{"content":"Introduction Hello, world! I\u0026rsquo;m here again :D\n","permalink":"http://localhost:1313/games/second/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eHello, world! I\u0026rsquo;m here again :D\u003c/p\u003e","title":"Second"},{"content":"Generative Design in Minecraft (GDMC) GDMC is a competition to generate settlements within a selection of a minecraft map. The project\u0026rsquo;s website provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\nMCEdit To generate settlements, the competition has gone the route of using MCEdit to allow competitors to view, generate, and modify minecraft maps. GDMC provides a wiki with easy to use instructions for installing and general set up. The wiki also provides an example cellular automata script for generating structures seen in figure one. As you can see, the output isn’t great, but it provides a nice starting point. It, also, shows how to work with the MCEdit filters which is how we can interact with the maps.\nFigure 1: Example cellular automata output from CASG_Example.py Filters A filter is how we are able to modify maps. To activate a filter, a user makes a selection on the map via a left click and dragging your mouse. From there, on the bottom of the screen, there is a potion looking icon that when pressed will open the filter menu. This provides a drop down menu of available filters. Each of these filters provides a set of options and the ability to perform their respective actions. When activated they will make modifications to the map given the users selection area. Each of the filters are Python 2.7 scripts located in the stock-filters directory.\nFilter Basics The wiki provides some helpful commentary in getting started with filters, but the script is a bit too complicated for a starting point. There are, however, two things that every filter has in common: the perform function and inputs tuple.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def perform(level, box, options): pass When a filter is activated, the engine will call the perform function and pass the level data (this data structure will be explored further in the next post), the bounding box, and the set of options a user has defined. The bounding box defines the origin of the box the user created and the size. The options is a dictionary based on the inputs defined in the above script. Therefore, to access the materials you could use options[“Material”] to be able to see what the user set.\nBox in all Eight Corners of Selection Now that we understand the basics, we can start with a simple filter. The goal of this filter is to place a user defined material in all eight corners of the user’s selection. The end result can be seen in figure two. The first step here is to define the inputs for the user. In this case, the above inputs code is exactly what we need.\nFigure 2: Example of placing blocks at all eight corners of user\u0026#39;s selection space ","permalink":"http://localhost:1313/posts/second/","summary":"\u003ch1 id=\"generative-design-in-minecraft-gdmc\"\u003eGenerative Design in Minecraft (GDMC)\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eGDMC\u003c/a\u003e is a competition to generate settlements within a selection of a minecraft map. The \u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eproject\u0026rsquo;s website\u003c/a\u003e provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\u003c/p\u003e","title":"Generative Design in Mineraft: MCEdit Basics"},{"content":"This is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, Swig’s website for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on Swig\u0026rsquo;s website and a StackOverflow question for Python 3. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\n1. Install # python-dev sudo apt-get install python-dev # python2.x sudo apt-get install python3-dev # python3.x # swig sudo apt-get install swig 2. Source c++ Fibonacci implementation, filename: fib.cpp\n#include \u0026#34;fib.h\u0026#34; int fibonacci(int n) { if(n \u0026lt;= 1) return n; return fibonacci(n-1) + fibonacci(n-2); } c++ fibonacci header file, filename: fib.h. I\u0026rsquo;m going to explain why this file exists in a moment.\nint fibonacci(int n); The next file is the interface file for swig, fib.i. This is telling swig what bindings it will need to create and is why we implemented fib.h.\n%module Fibonacci %{ #include \u0026#34;fib.h\u0026#34; %} %include \u0026#34;fib.h\u0026#34; The alternative to creating the fib.h file is directly below. For this we define each function individually for swig to then bind.\n%module Fibonacci %{ int fibonacci(int n); %} int fibonacci(int n); 3. Build setup.py, this file is taken directly from Swig\u0026rsquo;s documentation and modified slightly.\n#!/usr/bin/env python from distutils.core import setup, Extension fib_module = Extension( \u0026#39;_Fibonacci\u0026#39;, sources=[\u0026#39;fib_wrap.cxx\u0026#39;, \u0026#39;fib.cpp\u0026#39;], # fib_wrap.cxx is going to be generated by swig ) setup ( name = \u0026#39;Fibonacci\u0026#39;, version = \u0026#39;0.0\u0026#39;, author = \u0026#34;YOUR_NAME\u0026#34;, description = \u0026#34;Fibonacci swig\u0026#34;, ext_modules = [fib_module], py_modules = [\u0026#34;Fibonacci\u0026#34;], # name of module that we\u0026#39;re going import ) build.sh or whatever you fancy.\n#!/bin/bash swig -c++ -python fib.i python setup.py build_ext --inplace 4. Run Assign permissions (e.g. chmod 755 build.sh) and run ./build.sh. From there you can go into the python console and test by running the following:\n$ python \u0026gt;\u0026gt;\u0026gt; import Fibonacci \u0026gt;\u0026gt;\u0026gt; Fibonacci.fibonacci(10) 55 5. Conclusion Please let me know if anything here can be improved so I can update this for future readers. Regardless, I hope this helped some of you with your projects/work and saved you some time.\n","permalink":"http://localhost:1313/posts/first/","summary":"\u003cp\u003eThis is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig’s website\u003c/a\u003e for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig\u0026rsquo;s website\u003c/a\u003e and a \u003ca href=\"https://stackoverflow.com/questions/32667888/building-extension-for-python-3-with-swig-and-distutils\"\u003eStackOverflow question for Python 3\u003c/a\u003e. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\u003c/p\u003e","title":"C++ to Python Bindings with Swig"},{"content":"Biemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). Paper\nBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). Paper\nBiemer, C., \u0026amp; Cooper, S. (2022, October). Level Assembly as a Markov Decision Process. In 2022 Proceedings of the Experimental AI in Games Workshop. Paper, Talk, Code\nBiemer, C., \u0026amp; Cooper, S. (2022, August). On Linking Level Segments. In 2022 IEEE Conference on Games (CoG) (pp. 199-205). ★ Best Paper Nominee Paper, Talk, Code\nBiemer, C., Hervella, A., \u0026amp; Cooper, S. (2021, August). Gram-Elites: N-Gram Based Quality-Diversity Search. In The 16th International Conference on the Foundations of Digital Games (FDG) 2021 (pp. 1-6). Paper, Talk, Code\nVillareale, J., Biemer, C., Seif El-Nasr, M., \u0026amp; Zhu, J. (2020, September). Reflection in Game-Based Learning: A Survey of Programming Games. In International Conference on the Foundations of Digital Games (pp. 1-9). Paper\n","permalink":"http://localhost:1313/publications/","summary":"\u003cp\u003eBiemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). \u003cbr\u003e\n\u003ca href=\"/pdf/2024_solution_path_heuristics.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). \u003cbr\u003e\n\u003ca href=\"/pdf/2023_ddaviaplgviamdp.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e","title":"Publications"},{"content":"Introduction Hello, world! I\u0026rsquo;m here again :D\n","permalink":"http://localhost:1313/games/second/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eHello, world! I\u0026rsquo;m here again :D\u003c/p\u003e","title":"Second"},{"content":"Generative Design in Minecraft (GDMC) GDMC is a competition to generate settlements within a selection of a minecraft map. The project\u0026rsquo;s website provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\nMCEdit To generate settlements, the competition has gone the route of using MCEdit to allow competitors to view, generate, and modify minecraft maps. GDMC provides a wiki with easy to use instructions for installing and general set up. The wiki also provides an example cellular automata script for generating structures seen in figure one. As you can see, the output isn’t great, but it provides a nice starting point. It, also, shows how to work with the MCEdit filters which is how we can interact with the maps.\nFigure 1: Example cellular automata output from CASG_Example.py Filters A filter is how we are able to modify maps. To activate a filter, a user makes a selection on the map via a left click and dragging your mouse. From there, on the bottom of the screen, there is a potion looking icon that when pressed will open the filter menu. This provides a drop down menu of available filters. Each of these filters provides a set of options and the ability to perform their respective actions. When activated they will make modifications to the map given the users selection area. Each of the filters are Python 2.7 scripts located in the stock-filters directory.\nFilter Basics The wiki provides some helpful commentary in getting started with filters, but the script is a bit too complicated for a starting point. There are, however, two things that every filter has in common: the perform function and inputs tuple.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def perform(level, box, options): pass When a filter is activated, the engine will call the perform function and pass the level data (this data structure will be explored further in the next post), the bounding box, and the set of options a user has defined. The bounding box defines the origin of the box the user created and the size. The options is a dictionary based on the inputs defined in the above script. Therefore, to access the materials you could use options[“Material”] to be able to see what the user set.\nBox in all Eight Corners of Selection Now that we understand the basics, we can start with a simple filter. The goal of this filter is to place a user defined material in all eight corners of the user’s selection. The end result can be seen in figure two. The first step here is to define the inputs for the user. In this case, the above inputs code is exactly what we need.\nFigure 2: Example of placing blocks at all eight corners of user\u0026#39;s selection space ","permalink":"http://localhost:1313/posts/second/","summary":"\u003ch1 id=\"generative-design-in-minecraft-gdmc\"\u003eGenerative Design in Minecraft (GDMC)\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eGDMC\u003c/a\u003e is a competition to generate settlements within a selection of a minecraft map. The \u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eproject\u0026rsquo;s website\u003c/a\u003e provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\u003c/p\u003e","title":"Generative Design in Mineraft: MCEdit Basics"},{"content":"This is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, Swig’s website for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on Swig\u0026rsquo;s website and a StackOverflow question for Python 3. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\n1. Install # python-dev sudo apt-get install python-dev # python2.x sudo apt-get install python3-dev # python3.x # swig sudo apt-get install swig 2. Source c++ Fibonacci implementation, filename: fib.cpp\n#include \u0026#34;fib.h\u0026#34; int fibonacci(int n) { if(n \u0026lt;= 1) return n; return fibonacci(n-1) + fibonacci(n-2); } c++ fibonacci header file, filename: fib.h. I\u0026rsquo;m going to explain why this file exists in a moment.\nint fibonacci(int n); The next file is the interface file for swig, fib.i. This is telling swig what bindings it will need to create and is why we implemented fib.h.\n%module Fibonacci %{ #include \u0026#34;fib.h\u0026#34; %} %include \u0026#34;fib.h\u0026#34; The alternative to creating the fib.h file is directly below. For this we define each function individually for swig to then bind.\n%module Fibonacci %{ int fibonacci(int n); %} int fibonacci(int n); 3. Build setup.py, this file is taken directly from Swig\u0026rsquo;s documentation and modified slightly.\n#!/usr/bin/env python from distutils.core import setup, Extension fib_module = Extension( \u0026#39;_Fibonacci\u0026#39;, sources=[\u0026#39;fib_wrap.cxx\u0026#39;, \u0026#39;fib.cpp\u0026#39;], # fib_wrap.cxx is going to be generated by swig ) setup ( name = \u0026#39;Fibonacci\u0026#39;, version = \u0026#39;0.0\u0026#39;, author = \u0026#34;YOUR_NAME\u0026#34;, description = \u0026#34;Fibonacci swig\u0026#34;, ext_modules = [fib_module], py_modules = [\u0026#34;Fibonacci\u0026#34;], # name of module that we\u0026#39;re going import ) build.sh or whatever you fancy.\n#!/bin/bash swig -c++ -python fib.i python setup.py build_ext --inplace 4. Run Assign permissions (e.g. chmod 755 build.sh) and run ./build.sh. From there you can go into the python console and test by running the following:\n$ python \u0026gt;\u0026gt;\u0026gt; import Fibonacci \u0026gt;\u0026gt;\u0026gt; Fibonacci.fibonacci(10) 55 5. Conclusion Please let me know if anything here can be improved so I can update this for future readers. Regardless, I hope this helped some of you with your projects/work and saved you some time.\n","permalink":"http://localhost:1313/posts/first/","summary":"\u003cp\u003eThis is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig’s website\u003c/a\u003e for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig\u0026rsquo;s website\u003c/a\u003e and a \u003ca href=\"https://stackoverflow.com/questions/32667888/building-extension-for-python-3-with-swig-and-distutils\"\u003eStackOverflow question for Python 3\u003c/a\u003e. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\u003c/p\u003e","title":"C++ to Python Bindings with Swig"},{"content":"Biemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). Paper\nBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). Paper\nBiemer, C., \u0026amp; Cooper, S. (2022, October). Level Assembly as a Markov Decision Process. In 2022 Proceedings of the Experimental AI in Games Workshop. Paper, Talk, Code\nBiemer, C., \u0026amp; Cooper, S. (2022, August). On Linking Level Segments. In 2022 IEEE Conference on Games (CoG) (pp. 199-205). ★ Best Paper Nominee Paper, Talk, Code\nBiemer, C., Hervella, A., \u0026amp; Cooper, S. (2021, August). Gram-Elites: N-Gram Based Quality-Diversity Search. In The 16th International Conference on the Foundations of Digital Games (FDG) 2021 (pp. 1-6). Paper, Talk, Code\nVillareale, J., Biemer, C., Seif El-Nasr, M., \u0026amp; Zhu, J. (2020, September). Reflection in Game-Based Learning: A Survey of Programming Games. In International Conference on the Foundations of Digital Games (pp. 1-9). Paper\n","permalink":"http://localhost:1313/publications/","summary":"\u003cp\u003eBiemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). \u003cbr\u003e\n\u003ca href=\"/pdf/2024_solution_path_heuristics.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). \u003cbr\u003e\n\u003ca href=\"/pdf/2023_ddaviaplgviamdp.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e","title":"Publications"},{"content":"Introduction Hello, world! I\u0026rsquo;m here again :D\n","permalink":"http://localhost:1313/games/second/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eHello, world! I\u0026rsquo;m here again :D\u003c/p\u003e","title":"Second"},{"content":"Generative Design in Minecraft (GDMC) GDMC is a competition to generate settlements within a selection of a minecraft map. The project\u0026rsquo;s website provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\nMCEdit To generate settlements, the competition has gone the route of using MCEdit to allow competitors to view, generate, and modify minecraft maps. GDMC provides a wiki with easy to use instructions for installing and general set up. The wiki also provides an example cellular automata script for generating structures seen in figure one. As you can see, the output isn’t great, but it provides a nice starting point. It, also, shows how to work with the MCEdit filters which is how we can interact with the maps.\nFigure 1: Example cellular automata output from CASG_Example.py Filters A filter is how we are able to modify maps. To activate a filter, a user makes a selection on the map via a left click and dragging your mouse. From there, on the bottom of the screen, there is a potion looking icon that when pressed will open the filter menu. This provides a drop down menu of available filters. Each of these filters provides a set of options and the ability to perform their respective actions. When activated they will make modifications to the map given the users selection area. Each of the filters are Python 2.7 scripts located in the stock-filters directory.\nFilter Basics The wiki provides some helpful commentary in getting started with filters, but the script is a bit too complicated for a starting point. There are, however, two things that every filter has in common: the perform function and inputs tuple.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def perform(level, box, options): pass When a filter is activated, the engine will call the perform function and pass the level data (this data structure will be explored further in the next post), the bounding box, and the set of options a user has defined. The bounding box defines the origin of the box the user created and the size. The options is a dictionary based on the inputs defined in the above script. Therefore, to access the materials you could use options[“Material”] to be able to see what the user set.\nBox in all Eight Corners of Selection Now that we understand the basics, we can start with a simple filter. The goal of this filter is to place a user defined material in all eight corners of the user’s selection. The end result can be seen in figure two. The first step here is to define the inputs for the user. In this case, the above inputs code is exactly what we need.\nFigure 2: Example of placing blocks at all eight corners of user\u0026#39;s selection space ","permalink":"http://localhost:1313/posts/second/","summary":"\u003ch1 id=\"generative-design-in-minecraft-gdmc\"\u003eGenerative Design in Minecraft (GDMC)\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eGDMC\u003c/a\u003e is a competition to generate settlements within a selection of a minecraft map. The \u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eproject\u0026rsquo;s website\u003c/a\u003e provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\u003c/p\u003e","title":"Generative Design in Mineraft: MCEdit Basics"},{"content":"This is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, Swig’s website for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on Swig\u0026rsquo;s website and a StackOverflow question for Python 3. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\n1. Install # python-dev sudo apt-get install python-dev # python2.x sudo apt-get install python3-dev # python3.x # swig sudo apt-get install swig 2. Source c++ Fibonacci implementation, filename: fib.cpp\n#include \u0026#34;fib.h\u0026#34; int fibonacci(int n) { if(n \u0026lt;= 1) return n; return fibonacci(n-1) + fibonacci(n-2); } c++ fibonacci header file, filename: fib.h. I\u0026rsquo;m going to explain why this file exists in a moment.\nint fibonacci(int n); The next file is the interface file for swig, fib.i. This is telling swig what bindings it will need to create and is why we implemented fib.h.\n%module Fibonacci %{ #include \u0026#34;fib.h\u0026#34; %} %include \u0026#34;fib.h\u0026#34; The alternative to creating the fib.h file is directly below. For this we define each function individually for swig to then bind.\n%module Fibonacci %{ int fibonacci(int n); %} int fibonacci(int n); 3. Build setup.py, this file is taken directly from Swig\u0026rsquo;s documentation and modified slightly.\n#!/usr/bin/env python from distutils.core import setup, Extension fib_module = Extension( \u0026#39;_Fibonacci\u0026#39;, sources=[\u0026#39;fib_wrap.cxx\u0026#39;, \u0026#39;fib.cpp\u0026#39;], # fib_wrap.cxx is going to be generated by swig ) setup ( name = \u0026#39;Fibonacci\u0026#39;, version = \u0026#39;0.0\u0026#39;, author = \u0026#34;YOUR_NAME\u0026#34;, description = \u0026#34;Fibonacci swig\u0026#34;, ext_modules = [fib_module], py_modules = [\u0026#34;Fibonacci\u0026#34;], # name of module that we\u0026#39;re going import ) build.sh or whatever you fancy.\n#!/bin/bash swig -c++ -python fib.i python setup.py build_ext --inplace 4. Run Assign permissions (e.g. chmod 755 build.sh) and run ./build.sh. From there you can go into the python console and test by running the following:\n$ python \u0026gt;\u0026gt;\u0026gt; import Fibonacci \u0026gt;\u0026gt;\u0026gt; Fibonacci.fibonacci(10) 55 5. Conclusion Please let me know if anything here can be improved so I can update this for future readers. Regardless, I hope this helped some of you with your projects/work and saved you some time.\n","permalink":"http://localhost:1313/posts/first/","summary":"\u003cp\u003eThis is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig’s website\u003c/a\u003e for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig\u0026rsquo;s website\u003c/a\u003e and a \u003ca href=\"https://stackoverflow.com/questions/32667888/building-extension-for-python-3-with-swig-and-distutils\"\u003eStackOverflow question for Python 3\u003c/a\u003e. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\u003c/p\u003e","title":"C++ to Python Bindings with Swig"},{"content":"Biemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). Paper\nBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). Paper\nBiemer, C., \u0026amp; Cooper, S. (2022, October). Level Assembly as a Markov Decision Process. In 2022 Proceedings of the Experimental AI in Games Workshop. Paper, Talk, Code\nBiemer, C., \u0026amp; Cooper, S. (2022, August). On Linking Level Segments. In 2022 IEEE Conference on Games (CoG) (pp. 199-205). ★ Best Paper Nominee Paper, Talk, Code\nBiemer, C., Hervella, A., \u0026amp; Cooper, S. (2021, August). Gram-Elites: N-Gram Based Quality-Diversity Search. In The 16th International Conference on the Foundations of Digital Games (FDG) 2021 (pp. 1-6). Paper, Talk, Code\nVillareale, J., Biemer, C., Seif El-Nasr, M., \u0026amp; Zhu, J. (2020, September). Reflection in Game-Based Learning: A Survey of Programming Games. In International Conference on the Foundations of Digital Games (pp. 1-9). Paper\n","permalink":"http://localhost:1313/publications/","summary":"\u003cp\u003eBiemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). \u003cbr\u003e\n\u003ca href=\"/pdf/2024_solution_path_heuristics.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). \u003cbr\u003e\n\u003ca href=\"/pdf/2023_ddaviaplgviamdp.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e","title":"Publications"},{"content":"Introduction Hello, world! I\u0026rsquo;m here again :D\n","permalink":"http://localhost:1313/games/second/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eHello, world! I\u0026rsquo;m here again :D\u003c/p\u003e","title":"Second"},{"content":"Generative Design in Minecraft (GDMC) GDMC is a competition to generate settlements within a selection of a minecraft map. The project\u0026rsquo;s website provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\nMCEdit To generate settlements, the competition has gone the route of using MCEdit to allow competitors to view, generate, and modify minecraft maps. GDMC provides a wiki with easy to use instructions for installing and general set up. The wiki also provides an example cellular automata script for generating structures seen in figure one. As you can see, the output isn’t great, but it provides a nice starting point. It, also, shows how to work with the MCEdit filters which is how we can interact with the maps.\nFigure 1: Example cellular automata output from CASG_Example.py Filters A filter is how we are able to modify maps. To activate a filter, a user makes a selection on the map via a left click and dragging your mouse. From there, on the bottom of the screen, there is a potion looking icon that when pressed will open the filter menu. This provides a drop down menu of available filters. Each of these filters provides a set of options and the ability to perform their respective actions. When activated they will make modifications to the map given the users selection area. Each of the filters are Python 2.7 scripts located in the stock-filters directory.\nFilter Basics The wiki provides some helpful commentary in getting started with filters, but the script is a bit too complicated for a starting point. There are, however, two things that every filter has in common: the perform function and inputs tuple.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def perform(level, box, options): pass When a filter is activated, the engine will call the perform function and pass the level data (this data structure will be explored further in the next post), the bounding box, and the set of options a user has defined. The bounding box defines the origin of the box the user created and the size. The options is a dictionary based on the inputs defined in the above script. Therefore, to access the materials you could use options[“Material”] to be able to see what the user set.\nBox in all Eight Corners of Selection Now that we understand the basics, we can start with a simple filter. The goal of this filter is to place a user defined material in all eight corners of the user’s selection. The end result can be seen in figure two. The first step here is to define the inputs for the user. In this case, the above inputs code is exactly what we need.\nFigure 2: Example of placing blocks at all eight corners of user\u0026#39;s selection space Now we need to know how to draw a block and this can be found in the utility functions provided by NYU. I haven’t figured out the point of the function setBlockDataAt yet, but in the second post I intend to investigate more to figure it out. In the meantime, I wrote a simpler function because the data was always set to 0 in the examples I could find.\n","permalink":"http://localhost:1313/posts/second/","summary":"\u003ch1 id=\"generative-design-in-minecraft-gdmc\"\u003eGenerative Design in Minecraft (GDMC)\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eGDMC\u003c/a\u003e is a competition to generate settlements within a selection of a minecraft map. The \u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eproject\u0026rsquo;s website\u003c/a\u003e provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\u003c/p\u003e","title":"Generative Design in Mineraft: MCEdit Basics"},{"content":"This is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, Swig’s website for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on Swig\u0026rsquo;s website and a StackOverflow question for Python 3. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\n1. Install # python-dev sudo apt-get install python-dev # python2.x sudo apt-get install python3-dev # python3.x # swig sudo apt-get install swig 2. Source c++ Fibonacci implementation, filename: fib.cpp\n#include \u0026#34;fib.h\u0026#34; int fibonacci(int n) { if(n \u0026lt;= 1) return n; return fibonacci(n-1) + fibonacci(n-2); } c++ fibonacci header file, filename: fib.h. I\u0026rsquo;m going to explain why this file exists in a moment.\nint fibonacci(int n); The next file is the interface file for swig, fib.i. This is telling swig what bindings it will need to create and is why we implemented fib.h.\n%module Fibonacci %{ #include \u0026#34;fib.h\u0026#34; %} %include \u0026#34;fib.h\u0026#34; The alternative to creating the fib.h file is directly below. For this we define each function individually for swig to then bind.\n%module Fibonacci %{ int fibonacci(int n); %} int fibonacci(int n); 3. Build setup.py, this file is taken directly from Swig\u0026rsquo;s documentation and modified slightly.\n#!/usr/bin/env python from distutils.core import setup, Extension fib_module = Extension( \u0026#39;_Fibonacci\u0026#39;, sources=[\u0026#39;fib_wrap.cxx\u0026#39;, \u0026#39;fib.cpp\u0026#39;], # fib_wrap.cxx is going to be generated by swig ) setup ( name = \u0026#39;Fibonacci\u0026#39;, version = \u0026#39;0.0\u0026#39;, author = \u0026#34;YOUR_NAME\u0026#34;, description = \u0026#34;Fibonacci swig\u0026#34;, ext_modules = [fib_module], py_modules = [\u0026#34;Fibonacci\u0026#34;], # name of module that we\u0026#39;re going import ) build.sh or whatever you fancy.\n#!/bin/bash swig -c++ -python fib.i python setup.py build_ext --inplace 4. Run Assign permissions (e.g. chmod 755 build.sh) and run ./build.sh. From there you can go into the python console and test by running the following:\n$ python \u0026gt;\u0026gt;\u0026gt; import Fibonacci \u0026gt;\u0026gt;\u0026gt; Fibonacci.fibonacci(10) 55 5. Conclusion Please let me know if anything here can be improved so I can update this for future readers. Regardless, I hope this helped some of you with your projects/work and saved you some time.\n","permalink":"http://localhost:1313/posts/first/","summary":"\u003cp\u003eThis is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig’s website\u003c/a\u003e for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig\u0026rsquo;s website\u003c/a\u003e and a \u003ca href=\"https://stackoverflow.com/questions/32667888/building-extension-for-python-3-with-swig-and-distutils\"\u003eStackOverflow question for Python 3\u003c/a\u003e. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\u003c/p\u003e","title":"C++ to Python Bindings with Swig"},{"content":"Biemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). Paper\nBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). Paper\nBiemer, C., \u0026amp; Cooper, S. (2022, October). Level Assembly as a Markov Decision Process. In 2022 Proceedings of the Experimental AI in Games Workshop. Paper, Talk, Code\nBiemer, C., \u0026amp; Cooper, S. (2022, August). On Linking Level Segments. In 2022 IEEE Conference on Games (CoG) (pp. 199-205). ★ Best Paper Nominee Paper, Talk, Code\nBiemer, C., Hervella, A., \u0026amp; Cooper, S. (2021, August). Gram-Elites: N-Gram Based Quality-Diversity Search. In The 16th International Conference on the Foundations of Digital Games (FDG) 2021 (pp. 1-6). Paper, Talk, Code\nVillareale, J., Biemer, C., Seif El-Nasr, M., \u0026amp; Zhu, J. (2020, September). Reflection in Game-Based Learning: A Survey of Programming Games. In International Conference on the Foundations of Digital Games (pp. 1-9). Paper\n","permalink":"http://localhost:1313/publications/","summary":"\u003cp\u003eBiemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). \u003cbr\u003e\n\u003ca href=\"/pdf/2024_solution_path_heuristics.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). \u003cbr\u003e\n\u003ca href=\"/pdf/2023_ddaviaplgviamdp.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e","title":"Publications"},{"content":"Introduction Hello, world! I\u0026rsquo;m here again :D\n","permalink":"http://localhost:1313/games/second/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eHello, world! I\u0026rsquo;m here again :D\u003c/p\u003e","title":"Second"},{"content":"Generative Design in Minecraft (GDMC) GDMC is a competition to generate settlements within a selection of a minecraft map. The project\u0026rsquo;s website provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\nMCEdit To generate settlements, the competition has gone the route of using MCEdit to allow competitors to view, generate, and modify minecraft maps. GDMC provides a wiki with easy to use instructions for installing and general set up. The wiki also provides an example cellular automata script for generating structures seen in figure one. As you can see, the output isn’t great, but it provides a nice starting point. It, also, shows how to work with the MCEdit filters which is how we can interact with the maps.\nFigure 1: Example cellular automata output from CASG_Example.py Filters A filter is how we are able to modify maps. To activate a filter, a user makes a selection on the map via a left click and dragging your mouse. From there, on the bottom of the screen, there is a potion looking icon that when pressed will open the filter menu. This provides a drop down menu of available filters. Each of these filters provides a set of options and the ability to perform their respective actions. When activated they will make modifications to the map given the users selection area. Each of the filters are Python 2.7 scripts located in the stock-filters directory.\nFilter Basics The wiki provides some helpful commentary in getting started with filters, but the script is a bit too complicated for a starting point. There are, however, two things that every filter has in common: the perform function and inputs tuple.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def perform(level, box, options): pass When a filter is activated, the engine will call the perform function and pass the level data (this data structure will be explored further in the next post), the bounding box, and the set of options a user has defined. The bounding box defines the origin of the box the user created and the size. The options is a dictionary based on the inputs defined in the above script. Therefore, to access the materials you could use options[“Material”] to be able to see what the user set.\nBox in all Eight Corners of Selection Now that we understand the basics, we can start with a simple filter. The goal of this filter is to place a user defined material in all eight corners of the user’s selection. The end result can be seen in figure two. The first step here is to define the inputs for the user. In this case, the above inputs code is exactly what we need.\nFigure 2: Example of placing blocks at all eight corners of user\u0026#39;s selection space Now we need to know how to draw a block and this can be found in the utility functions provided by NYU. I haven’t figured out the point of the function setBlockDataAt yet, but in the second post I intend to investigate more to figure it out. In the meantime, I wrote a simpler function because the data was always set to 0 in the examples I could find.\n","permalink":"http://localhost:1313/posts/second/","summary":"\u003ch1 id=\"generative-design-in-minecraft-gdmc\"\u003eGenerative Design in Minecraft (GDMC)\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eGDMC\u003c/a\u003e is a competition to generate settlements within a selection of a minecraft map. The \u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eproject\u0026rsquo;s website\u003c/a\u003e provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\u003c/p\u003e","title":"Generative Design in Mineraft: MCEdit Basics"},{"content":"This is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, Swig’s website for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on Swig\u0026rsquo;s website and a StackOverflow question for Python 3. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\n1. Install # python-dev sudo apt-get install python-dev # python2.x sudo apt-get install python3-dev # python3.x # swig sudo apt-get install swig 2. Source c++ Fibonacci implementation, filename: fib.cpp\n#include \u0026#34;fib.h\u0026#34; int fibonacci(int n) { if(n \u0026lt;= 1) return n; return fibonacci(n-1) + fibonacci(n-2); } c++ fibonacci header file, filename: fib.h. I\u0026rsquo;m going to explain why this file exists in a moment.\nint fibonacci(int n); The next file is the interface file for swig, fib.i. This is telling swig what bindings it will need to create and is why we implemented fib.h.\n%module Fibonacci %{ #include \u0026#34;fib.h\u0026#34; %} %include \u0026#34;fib.h\u0026#34; The alternative to creating the fib.h file is directly below. For this we define each function individually for swig to then bind.\n%module Fibonacci %{ int fibonacci(int n); %} int fibonacci(int n); 3. Build setup.py, this file is taken directly from Swig\u0026rsquo;s documentation and modified slightly.\n#!/usr/bin/env python from distutils.core import setup, Extension fib_module = Extension( \u0026#39;_Fibonacci\u0026#39;, sources=[\u0026#39;fib_wrap.cxx\u0026#39;, \u0026#39;fib.cpp\u0026#39;], # fib_wrap.cxx is going to be generated by swig ) setup ( name = \u0026#39;Fibonacci\u0026#39;, version = \u0026#39;0.0\u0026#39;, author = \u0026#34;YOUR_NAME\u0026#34;, description = \u0026#34;Fibonacci swig\u0026#34;, ext_modules = [fib_module], py_modules = [\u0026#34;Fibonacci\u0026#34;], # name of module that we\u0026#39;re going import ) build.sh or whatever you fancy.\n#!/bin/bash swig -c++ -python fib.i python setup.py build_ext --inplace 4. Run Assign permissions (e.g. chmod 755 build.sh) and run ./build.sh. From there you can go into the python console and test by running the following:\n$ python \u0026gt;\u0026gt;\u0026gt; import Fibonacci \u0026gt;\u0026gt;\u0026gt; Fibonacci.fibonacci(10) 55 5. Conclusion Please let me know if anything here can be improved so I can update this for future readers. Regardless, I hope this helped some of you with your projects/work and saved you some time.\n","permalink":"http://localhost:1313/posts/first/","summary":"\u003cp\u003eThis is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig’s website\u003c/a\u003e for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig\u0026rsquo;s website\u003c/a\u003e and a \u003ca href=\"https://stackoverflow.com/questions/32667888/building-extension-for-python-3-with-swig-and-distutils\"\u003eStackOverflow question for Python 3\u003c/a\u003e. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\u003c/p\u003e","title":"C++ to Python Bindings with Swig"},{"content":"Biemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). Paper\nBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). Paper\nBiemer, C., \u0026amp; Cooper, S. (2022, October). Level Assembly as a Markov Decision Process. In 2022 Proceedings of the Experimental AI in Games Workshop. Paper, Talk, Code\nBiemer, C., \u0026amp; Cooper, S. (2022, August). On Linking Level Segments. In 2022 IEEE Conference on Games (CoG) (pp. 199-205). ★ Best Paper Nominee Paper, Talk, Code\nBiemer, C., Hervella, A., \u0026amp; Cooper, S. (2021, August). Gram-Elites: N-Gram Based Quality-Diversity Search. In The 16th International Conference on the Foundations of Digital Games (FDG) 2021 (pp. 1-6). Paper, Talk, Code\nVillareale, J., Biemer, C., Seif El-Nasr, M., \u0026amp; Zhu, J. (2020, September). Reflection in Game-Based Learning: A Survey of Programming Games. In International Conference on the Foundations of Digital Games (pp. 1-9). Paper\n","permalink":"http://localhost:1313/publications/","summary":"\u003cp\u003eBiemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). \u003cbr\u003e\n\u003ca href=\"/pdf/2024_solution_path_heuristics.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). \u003cbr\u003e\n\u003ca href=\"/pdf/2023_ddaviaplgviamdp.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e","title":"Publications"},{"content":"Introduction Hello, world! I\u0026rsquo;m here again :D\n","permalink":"http://localhost:1313/games/second/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eHello, world! I\u0026rsquo;m here again :D\u003c/p\u003e","title":"Second"},{"content":"Generative Design in Minecraft (GDMC) GDMC is a competition to generate settlements within a selection of a minecraft map. The project\u0026rsquo;s website provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\nMCEdit To generate settlements, the competition has gone the route of using MCEdit to allow competitors to view, generate, and modify minecraft maps. GDMC provides a wiki with easy to use instructions for installing and general set up. The wiki also provides an example cellular automata script for generating structures seen in figure one. As you can see, the output isn’t great, but it provides a nice starting point. It, also, shows how to work with the MCEdit filters which is how we can interact with the maps.\nFigure 1: Example cellular automata output from CASG_Example.py Filters A filter is how we are able to modify maps. To activate a filter, a user makes a selection on the map via a left click and dragging your mouse. From there, on the bottom of the screen, there is a potion looking icon that when pressed will open the filter menu. This provides a drop down menu of available filters. Each of these filters provides a set of options and the ability to perform their respective actions. When activated they will make modifications to the map given the users selection area. Each of the filters are Python 2.7 scripts located in the stock-filters directory.\nFilter Basics The wiki provides some helpful commentary in getting started with filters, but the script is a bit too complicated for a starting point. There are, however, two things that every filter has in common: the perform function and inputs tuple.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def perform(level, box, options): pass When a filter is activated, the engine will call the perform function and pass the level data (this data structure will be explored further in the next post), the bounding box, and the set of options a user has defined. The bounding box defines the origin of the box the user created and the size. The options is a dictionary based on the inputs defined in the above script. Therefore, to access the materials you could use options[“Material”] to be able to see what the user set.\nBox in all Eight Corners of Selection Now that we understand the basics, we can start with a simple filter. The goal of this filter is to place a user defined material in all eight corners of the user’s selection. The end result can be seen in figure two. The first step here is to define the inputs for the user. In this case, the above inputs code is exactly what we need.\nFigure 2: Example of placing blocks at all eight corners of user\u0026#39;s selection space Now we need to know how to draw a block and this can be found in the utility functions provided by NYU. I haven’t figured out the point of the function setBlockDataAt yet, but in the second post I intend to investigate more to figure it out. In the meantime, I wrote a simpler function because the data was always set to 0 in the examples I could find.\n","permalink":"http://localhost:1313/posts/second/","summary":"\u003ch1 id=\"generative-design-in-minecraft-gdmc\"\u003eGenerative Design in Minecraft (GDMC)\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eGDMC\u003c/a\u003e is a competition to generate settlements within a selection of a minecraft map. The \u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eproject\u0026rsquo;s website\u003c/a\u003e provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\u003c/p\u003e","title":"Generative Design in Mineraft: MCEdit Basics"},{"content":"This is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, Swig’s website for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on Swig\u0026rsquo;s website and a StackOverflow question for Python 3. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\n1. Install # python-dev sudo apt-get install python-dev # python2.x sudo apt-get install python3-dev # python3.x # swig sudo apt-get install swig 2. Source c++ Fibonacci implementation, filename: fib.cpp\n#include \u0026#34;fib.h\u0026#34; int fibonacci(int n) { if(n \u0026lt;= 1) return n; return fibonacci(n-1) + fibonacci(n-2); } c++ fibonacci header file, filename: fib.h. I\u0026rsquo;m going to explain why this file exists in a moment.\nint fibonacci(int n); The next file is the interface file for swig, fib.i. This is telling swig what bindings it will need to create and is why we implemented fib.h.\n%module Fibonacci %{ #include \u0026#34;fib.h\u0026#34; %} %include \u0026#34;fib.h\u0026#34; The alternative to creating the fib.h file is directly below. For this we define each function individually for swig to then bind.\n%module Fibonacci %{ int fibonacci(int n); %} int fibonacci(int n); 3. Build setup.py, this file is taken directly from Swig\u0026rsquo;s documentation and modified slightly.\n#!/usr/bin/env python from distutils.core import setup, Extension fib_module = Extension( \u0026#39;_Fibonacci\u0026#39;, sources=[\u0026#39;fib_wrap.cxx\u0026#39;, \u0026#39;fib.cpp\u0026#39;], # fib_wrap.cxx is going to be generated by swig ) setup ( name = \u0026#39;Fibonacci\u0026#39;, version = \u0026#39;0.0\u0026#39;, author = \u0026#34;YOUR_NAME\u0026#34;, description = \u0026#34;Fibonacci swig\u0026#34;, ext_modules = [fib_module], py_modules = [\u0026#34;Fibonacci\u0026#34;], # name of module that we\u0026#39;re going import ) build.sh or whatever you fancy.\n#!/bin/bash swig -c++ -python fib.i python setup.py build_ext --inplace 4. Run Assign permissions (e.g. chmod 755 build.sh) and run ./build.sh. From there you can go into the python console and test by running the following:\n$ python \u0026gt;\u0026gt;\u0026gt; import Fibonacci \u0026gt;\u0026gt;\u0026gt; Fibonacci.fibonacci(10) 55 5. Conclusion Please let me know if anything here can be improved so I can update this for future readers. Regardless, I hope this helped some of you with your projects/work and saved you some time.\n","permalink":"http://localhost:1313/posts/first/","summary":"\u003cp\u003eThis is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig’s website\u003c/a\u003e for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig\u0026rsquo;s website\u003c/a\u003e and a \u003ca href=\"https://stackoverflow.com/questions/32667888/building-extension-for-python-3-with-swig-and-distutils\"\u003eStackOverflow question for Python 3\u003c/a\u003e. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\u003c/p\u003e","title":"C++ to Python Bindings with Swig"},{"content":"Biemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). Paper\nBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). Paper\nBiemer, C., \u0026amp; Cooper, S. (2022, October). Level Assembly as a Markov Decision Process. In 2022 Proceedings of the Experimental AI in Games Workshop. Paper, Talk, Code\nBiemer, C., \u0026amp; Cooper, S. (2022, August). On Linking Level Segments. In 2022 IEEE Conference on Games (CoG) (pp. 199-205). ★ Best Paper Nominee Paper, Talk, Code\nBiemer, C., Hervella, A., \u0026amp; Cooper, S. (2021, August). Gram-Elites: N-Gram Based Quality-Diversity Search. In The 16th International Conference on the Foundations of Digital Games (FDG) 2021 (pp. 1-6). Paper, Talk, Code\nVillareale, J., Biemer, C., Seif El-Nasr, M., \u0026amp; Zhu, J. (2020, September). Reflection in Game-Based Learning: A Survey of Programming Games. In International Conference on the Foundations of Digital Games (pp. 1-9). Paper\n","permalink":"http://localhost:1313/publications/","summary":"\u003cp\u003eBiemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). \u003cbr\u003e\n\u003ca href=\"/pdf/2024_solution_path_heuristics.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). \u003cbr\u003e\n\u003ca href=\"/pdf/2023_ddaviaplgviamdp.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e","title":"Publications"},{"content":"Introduction Hello, world! I\u0026rsquo;m here again :D\n","permalink":"http://localhost:1313/games/second/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eHello, world! I\u0026rsquo;m here again :D\u003c/p\u003e","title":"Second"},{"content":"Generative Design in Minecraft (GDMC) GDMC is a competition to generate settlements within a selection of a minecraft map. The project\u0026rsquo;s website provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\nMCEdit To generate settlements, the competition has gone the route of using MCEdit to allow competitors to view, generate, and modify minecraft maps. GDMC provides a wiki with easy to use instructions for installing and general set up. The wiki also provides an example cellular automata script for generating structures seen in figure one. As you can see, the output isn’t great, but it provides a nice starting point. It, also, shows how to work with the MCEdit filters which is how we can interact with the maps.\nFigure 1: Example cellular automata output from CASG_Example.py Filters A filter is how we are able to modify maps. To activate a filter, a user makes a selection on the map via a left click and dragging your mouse. From there, on the bottom of the screen, there is a potion looking icon that when pressed will open the filter menu. This provides a drop down menu of available filters. Each of these filters provides a set of options and the ability to perform their respective actions. When activated they will make modifications to the map given the users selection area. Each of the filters are Python 2.7 scripts located in the stock-filters directory.\nFilter Basics The wiki provides some helpful commentary in getting started with filters, but the script is a bit too complicated for a starting point. There are, however, two things that every filter has in common: the perform function and inputs tuple.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def perform(level, box, options): pass When a filter is activated, the engine will call the perform function and pass the level data (this data structure will be explored further in the next post), the bounding box, and the set of options a user has defined. The bounding box defines the origin of the box the user created and the size. The options is a dictionary based on the inputs defined in the above script. Therefore, to access the materials you could use options[“Material”] to be able to see what the user set.\nBox in all Eight Corners of Selection Now that we understand the basics, we can start with a simple filter. The goal of this filter is to place a user defined material in all eight corners of the user’s selection. The end result can be seen in figure two. The first step here is to define the inputs for the user. In this case, the above inputs code is exactly what we need.\nFigure 2: Example of placing blocks at all eight corners of user\u0026#39;s selection space Now we need to know how to draw a block and this can be found in the utility functions provided by NYU. I haven’t figured out the point of the function setBlockDataAt yet, but in the second post I intend to investigate more to figure it out. In the meantime, I wrote a simpler function because the data was always set to 0 in the examples I could find.\n","permalink":"http://localhost:1313/posts/second/","summary":"\u003ch1 id=\"generative-design-in-minecraft-gdmc\"\u003eGenerative Design in Minecraft (GDMC)\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eGDMC\u003c/a\u003e is a competition to generate settlements within a selection of a minecraft map. The \u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eproject\u0026rsquo;s website\u003c/a\u003e provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\u003c/p\u003e","title":"Generative Design in Mineraft: MCEdit Basics"},{"content":"This is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, Swig’s website for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on Swig\u0026rsquo;s website and a StackOverflow question for Python 3. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\n1. Install # python-dev sudo apt-get install python-dev # python2.x sudo apt-get install python3-dev # python3.x # swig sudo apt-get install swig 2. Source c++ Fibonacci implementation, filename: fib.cpp\n#include \u0026#34;fib.h\u0026#34; int fibonacci(int n) { if(n \u0026lt;= 1) return n; return fibonacci(n-1) + fibonacci(n-2); } c++ fibonacci header file, filename: fib.h. I\u0026rsquo;m going to explain why this file exists in a moment.\nint fibonacci(int n); The next file is the interface file for swig, fib.i. This is telling swig what bindings it will need to create and is why we implemented fib.h.\n%module Fibonacci %{ #include \u0026#34;fib.h\u0026#34; %} %include \u0026#34;fib.h\u0026#34; The alternative to creating the fib.h file is directly below. For this we define each function individually for swig to then bind.\n%module Fibonacci %{ int fibonacci(int n); %} int fibonacci(int n); 3. Build setup.py, this file is taken directly from Swig\u0026rsquo;s documentation and modified slightly.\n#!/usr/bin/env python from distutils.core import setup, Extension fib_module = Extension( \u0026#39;_Fibonacci\u0026#39;, sources=[\u0026#39;fib_wrap.cxx\u0026#39;, \u0026#39;fib.cpp\u0026#39;], # fib_wrap.cxx is going to be generated by swig ) setup ( name = \u0026#39;Fibonacci\u0026#39;, version = \u0026#39;0.0\u0026#39;, author = \u0026#34;YOUR_NAME\u0026#34;, description = \u0026#34;Fibonacci swig\u0026#34;, ext_modules = [fib_module], py_modules = [\u0026#34;Fibonacci\u0026#34;], # name of module that we\u0026#39;re going import ) build.sh or whatever you fancy.\n#!/bin/bash swig -c++ -python fib.i python setup.py build_ext --inplace 4. Run Assign permissions (e.g. chmod 755 build.sh) and run ./build.sh. From there you can go into the python console and test by running the following:\n$ python \u0026gt;\u0026gt;\u0026gt; import Fibonacci \u0026gt;\u0026gt;\u0026gt; Fibonacci.fibonacci(10) 55 5. Conclusion Please let me know if anything here can be improved so I can update this for future readers. Regardless, I hope this helped some of you with your projects/work and saved you some time.\n","permalink":"http://localhost:1313/posts/first/","summary":"\u003cp\u003eThis is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig’s website\u003c/a\u003e for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig\u0026rsquo;s website\u003c/a\u003e and a \u003ca href=\"https://stackoverflow.com/questions/32667888/building-extension-for-python-3-with-swig-and-distutils\"\u003eStackOverflow question for Python 3\u003c/a\u003e. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\u003c/p\u003e","title":"C++ to Python Bindings with Swig"},{"content":"Biemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). Paper\nBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). Paper\nBiemer, C., \u0026amp; Cooper, S. (2022, October). Level Assembly as a Markov Decision Process. In 2022 Proceedings of the Experimental AI in Games Workshop. Paper, Talk, Code\nBiemer, C., \u0026amp; Cooper, S. (2022, August). On Linking Level Segments. In 2022 IEEE Conference on Games (CoG) (pp. 199-205). ★ Best Paper Nominee Paper, Talk, Code\nBiemer, C., Hervella, A., \u0026amp; Cooper, S. (2021, August). Gram-Elites: N-Gram Based Quality-Diversity Search. In The 16th International Conference on the Foundations of Digital Games (FDG) 2021 (pp. 1-6). Paper, Talk, Code\nVillareale, J., Biemer, C., Seif El-Nasr, M., \u0026amp; Zhu, J. (2020, September). Reflection in Game-Based Learning: A Survey of Programming Games. In International Conference on the Foundations of Digital Games (pp. 1-9). Paper\n","permalink":"http://localhost:1313/publications/","summary":"\u003cp\u003eBiemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). \u003cbr\u003e\n\u003ca href=\"/pdf/2024_solution_path_heuristics.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). \u003cbr\u003e\n\u003ca href=\"/pdf/2023_ddaviaplgviamdp.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e","title":"Publications"},{"content":"Introduction Hello, world! I\u0026rsquo;m here again :D\n","permalink":"http://localhost:1313/games/second/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eHello, world! I\u0026rsquo;m here again :D\u003c/p\u003e","title":"Second"},{"content":"Generative Design in Minecraft (GDMC) GDMC is a competition to generate settlements within a selection of a minecraft map. The project\u0026rsquo;s website provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\nMCEdit To generate settlements, the competition has gone the route of using MCEdit to allow competitors to view, generate, and modify minecraft maps. GDMC provides a wiki with easy to use instructions for installing and general set up. The wiki also provides an example cellular automata script for generating structures seen in figure one. As you can see, the output isn’t great, but it provides a nice starting point. It, also, shows how to work with the MCEdit filters which is how we can interact with the maps.\nFigure 1: Example cellular automata output from CASG_Example.py Filters A filter is how we are able to modify maps. To activate a filter, a user makes a selection on the map via a left click and dragging your mouse. From there, on the bottom of the screen, there is a potion looking icon that when pressed will open the filter menu. This provides a drop down menu of available filters. Each of these filters provides a set of options and the ability to perform their respective actions. When activated they will make modifications to the map given the users selection area. Each of the filters are Python 2.7 scripts located in the stock-filters directory.\nFilter Basics The wiki provides some helpful commentary in getting started with filters, but the script is a bit too complicated for a starting point. There are, however, two things that every filter has in common: the perform function and inputs tuple.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def perform(level, box, options): pass When a filter is activated, the engine will call the perform function and pass the level data (this data structure will be explored further in the next post), the bounding box, and the set of options a user has defined. The bounding box defines the origin of the box the user created and the size. The options is a dictionary based on the inputs defined in the above script. Therefore, to access the materials you could use options[“Material”] to be able to see what the user set.\nBox in all Eight Corners of Selection Now that we understand the basics, we can start with a simple filter. The goal of this filter is to place a user defined material in all eight corners of the user’s selection. The end result can be seen in figure two. The first step here is to define the inputs for the user. In this case, the above inputs code is exactly what we need.\nFigure 2: Example of placing blocks at all eight corners of user\u0026#39;s selection space Now we need to know how to draw a block and this can be found in the utility functions provided by NYU. I haven’t figured out the point of the function setBlockDataAt yet, but in the second post I intend to investigate more to figure it out. In the meantime, I wrote a simpler function because the data was always set to 0 in the examples I could find.\ndef draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) ","permalink":"http://localhost:1313/posts/second/","summary":"\u003ch1 id=\"generative-design-in-minecraft-gdmc\"\u003eGenerative Design in Minecraft (GDMC)\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eGDMC\u003c/a\u003e is a competition to generate settlements within a selection of a minecraft map. The \u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eproject\u0026rsquo;s website\u003c/a\u003e provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\u003c/p\u003e","title":"Generative Design in Mineraft: MCEdit Basics"},{"content":"This is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, Swig’s website for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on Swig\u0026rsquo;s website and a StackOverflow question for Python 3. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\n1. Install # python-dev sudo apt-get install python-dev # python2.x sudo apt-get install python3-dev # python3.x # swig sudo apt-get install swig 2. Source c++ Fibonacci implementation, filename: fib.cpp\n#include \u0026#34;fib.h\u0026#34; int fibonacci(int n) { if(n \u0026lt;= 1) return n; return fibonacci(n-1) + fibonacci(n-2); } c++ fibonacci header file, filename: fib.h. I\u0026rsquo;m going to explain why this file exists in a moment.\nint fibonacci(int n); The next file is the interface file for swig, fib.i. This is telling swig what bindings it will need to create and is why we implemented fib.h.\n%module Fibonacci %{ #include \u0026#34;fib.h\u0026#34; %} %include \u0026#34;fib.h\u0026#34; The alternative to creating the fib.h file is directly below. For this we define each function individually for swig to then bind.\n%module Fibonacci %{ int fibonacci(int n); %} int fibonacci(int n); 3. Build setup.py, this file is taken directly from Swig\u0026rsquo;s documentation and modified slightly.\n#!/usr/bin/env python from distutils.core import setup, Extension fib_module = Extension( \u0026#39;_Fibonacci\u0026#39;, sources=[\u0026#39;fib_wrap.cxx\u0026#39;, \u0026#39;fib.cpp\u0026#39;], # fib_wrap.cxx is going to be generated by swig ) setup ( name = \u0026#39;Fibonacci\u0026#39;, version = \u0026#39;0.0\u0026#39;, author = \u0026#34;YOUR_NAME\u0026#34;, description = \u0026#34;Fibonacci swig\u0026#34;, ext_modules = [fib_module], py_modules = [\u0026#34;Fibonacci\u0026#34;], # name of module that we\u0026#39;re going import ) build.sh or whatever you fancy.\n#!/bin/bash swig -c++ -python fib.i python setup.py build_ext --inplace 4. Run Assign permissions (e.g. chmod 755 build.sh) and run ./build.sh. From there you can go into the python console and test by running the following:\n$ python \u0026gt;\u0026gt;\u0026gt; import Fibonacci \u0026gt;\u0026gt;\u0026gt; Fibonacci.fibonacci(10) 55 5. Conclusion Please let me know if anything here can be improved so I can update this for future readers. Regardless, I hope this helped some of you with your projects/work and saved you some time.\n","permalink":"http://localhost:1313/posts/first/","summary":"\u003cp\u003eThis is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig’s website\u003c/a\u003e for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig\u0026rsquo;s website\u003c/a\u003e and a \u003ca href=\"https://stackoverflow.com/questions/32667888/building-extension-for-python-3-with-swig-and-distutils\"\u003eStackOverflow question for Python 3\u003c/a\u003e. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\u003c/p\u003e","title":"C++ to Python Bindings with Swig"},{"content":"Biemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). Paper\nBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). Paper\nBiemer, C., \u0026amp; Cooper, S. (2022, October). Level Assembly as a Markov Decision Process. In 2022 Proceedings of the Experimental AI in Games Workshop. Paper, Talk, Code\nBiemer, C., \u0026amp; Cooper, S. (2022, August). On Linking Level Segments. In 2022 IEEE Conference on Games (CoG) (pp. 199-205). ★ Best Paper Nominee Paper, Talk, Code\nBiemer, C., Hervella, A., \u0026amp; Cooper, S. (2021, August). Gram-Elites: N-Gram Based Quality-Diversity Search. In The 16th International Conference on the Foundations of Digital Games (FDG) 2021 (pp. 1-6). Paper, Talk, Code\nVillareale, J., Biemer, C., Seif El-Nasr, M., \u0026amp; Zhu, J. (2020, September). Reflection in Game-Based Learning: A Survey of Programming Games. In International Conference on the Foundations of Digital Games (pp. 1-9). Paper\n","permalink":"http://localhost:1313/publications/","summary":"\u003cp\u003eBiemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). \u003cbr\u003e\n\u003ca href=\"/pdf/2024_solution_path_heuristics.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). \u003cbr\u003e\n\u003ca href=\"/pdf/2023_ddaviaplgviamdp.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e","title":"Publications"},{"content":"Introduction Hello, world! I\u0026rsquo;m here again :D\n","permalink":"http://localhost:1313/games/second/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eHello, world! I\u0026rsquo;m here again :D\u003c/p\u003e","title":"Second"},{"content":"Generative Design in Minecraft (GDMC) GDMC is a competition to generate settlements within a selection of a minecraft map. The project\u0026rsquo;s website provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\nMCEdit To generate settlements, the competition has gone the route of using MCEdit to allow competitors to view, generate, and modify minecraft maps. GDMC provides a wiki with easy to use instructions for installing and general set up. The wiki also provides an example cellular automata script for generating structures seen in figure one. As you can see, the output isn’t great, but it provides a nice starting point. It, also, shows how to work with the MCEdit filters which is how we can interact with the maps.\nFigure 1: Example cellular automata output from CASG_Example.py Filters A filter is how we are able to modify maps. To activate a filter, a user makes a selection on the map via a left click and dragging your mouse. From there, on the bottom of the screen, there is a potion looking icon that when pressed will open the filter menu. This provides a drop down menu of available filters. Each of these filters provides a set of options and the ability to perform their respective actions. When activated they will make modifications to the map given the users selection area. Each of the filters are Python 2.7 scripts located in the stock-filters directory.\nFilter Basics The wiki provides some helpful commentary in getting started with filters, but the script is a bit too complicated for a starting point. There are, however, two things that every filter has in common: the perform function and inputs tuple.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def perform(level, box, options): pass When a filter is activated, the engine will call the perform function and pass the level data (this data structure will be explored further in the next post), the bounding box, and the set of options a user has defined. The bounding box defines the origin of the box the user created and the size. The options is a dictionary based on the inputs defined in the above script. Therefore, to access the materials you could use options[“Material”] to be able to see what the user set.\nBox in all Eight Corners of Selection Now that we understand the basics, we can start with a simple filter. The goal of this filter is to place a user defined material in all eight corners of the user’s selection. The end result can be seen in figure two. The first step here is to define the inputs for the user. In this case, the above inputs code is exactly what we need.\nFigure 2: Example of placing blocks at all eight corners of user\u0026#39;s selection space Now we need to know how to draw a block and this can be found in the utility functions provided by NYU. I haven’t figured out the point of the function setBlockDataAt yet, but in the second post I intend to investigate more to figure it out. In the meantime, I wrote a simpler function because the data was always set to 0 in the examples I could find.\ndef draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) With that complete, the only problem now is figuring out how to use the bounding box to find the eight corners. As noted above, the way the bounding box works is by providing an origin and size vector. All variations of adding these two together will provide eight values which are, coincidentally, the corners of the cube. The full filter can be seen below.\n","permalink":"http://localhost:1313/posts/second/","summary":"\u003ch1 id=\"generative-design-in-minecraft-gdmc\"\u003eGenerative Design in Minecraft (GDMC)\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eGDMC\u003c/a\u003e is a competition to generate settlements within a selection of a minecraft map. The \u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eproject\u0026rsquo;s website\u003c/a\u003e provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\u003c/p\u003e","title":"Generative Design in Mineraft: MCEdit Basics"},{"content":"This is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, Swig’s website for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on Swig\u0026rsquo;s website and a StackOverflow question for Python 3. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\n1. Install # python-dev sudo apt-get install python-dev # python2.x sudo apt-get install python3-dev # python3.x # swig sudo apt-get install swig 2. Source c++ Fibonacci implementation, filename: fib.cpp\n#include \u0026#34;fib.h\u0026#34; int fibonacci(int n) { if(n \u0026lt;= 1) return n; return fibonacci(n-1) + fibonacci(n-2); } c++ fibonacci header file, filename: fib.h. I\u0026rsquo;m going to explain why this file exists in a moment.\nint fibonacci(int n); The next file is the interface file for swig, fib.i. This is telling swig what bindings it will need to create and is why we implemented fib.h.\n%module Fibonacci %{ #include \u0026#34;fib.h\u0026#34; %} %include \u0026#34;fib.h\u0026#34; The alternative to creating the fib.h file is directly below. For this we define each function individually for swig to then bind.\n%module Fibonacci %{ int fibonacci(int n); %} int fibonacci(int n); 3. Build setup.py, this file is taken directly from Swig\u0026rsquo;s documentation and modified slightly.\n#!/usr/bin/env python from distutils.core import setup, Extension fib_module = Extension( \u0026#39;_Fibonacci\u0026#39;, sources=[\u0026#39;fib_wrap.cxx\u0026#39;, \u0026#39;fib.cpp\u0026#39;], # fib_wrap.cxx is going to be generated by swig ) setup ( name = \u0026#39;Fibonacci\u0026#39;, version = \u0026#39;0.0\u0026#39;, author = \u0026#34;YOUR_NAME\u0026#34;, description = \u0026#34;Fibonacci swig\u0026#34;, ext_modules = [fib_module], py_modules = [\u0026#34;Fibonacci\u0026#34;], # name of module that we\u0026#39;re going import ) build.sh or whatever you fancy.\n#!/bin/bash swig -c++ -python fib.i python setup.py build_ext --inplace 4. Run Assign permissions (e.g. chmod 755 build.sh) and run ./build.sh. From there you can go into the python console and test by running the following:\n$ python \u0026gt;\u0026gt;\u0026gt; import Fibonacci \u0026gt;\u0026gt;\u0026gt; Fibonacci.fibonacci(10) 55 5. Conclusion Please let me know if anything here can be improved so I can update this for future readers. Regardless, I hope this helped some of you with your projects/work and saved you some time.\n","permalink":"http://localhost:1313/posts/first/","summary":"\u003cp\u003eThis is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig’s website\u003c/a\u003e for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig\u0026rsquo;s website\u003c/a\u003e and a \u003ca href=\"https://stackoverflow.com/questions/32667888/building-extension-for-python-3-with-swig-and-distutils\"\u003eStackOverflow question for Python 3\u003c/a\u003e. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\u003c/p\u003e","title":"C++ to Python Bindings with Swig"},{"content":"Biemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). Paper\nBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). Paper\nBiemer, C., \u0026amp; Cooper, S. (2022, October). Level Assembly as a Markov Decision Process. In 2022 Proceedings of the Experimental AI in Games Workshop. Paper, Talk, Code\nBiemer, C., \u0026amp; Cooper, S. (2022, August). On Linking Level Segments. In 2022 IEEE Conference on Games (CoG) (pp. 199-205). ★ Best Paper Nominee Paper, Talk, Code\nBiemer, C., Hervella, A., \u0026amp; Cooper, S. (2021, August). Gram-Elites: N-Gram Based Quality-Diversity Search. In The 16th International Conference on the Foundations of Digital Games (FDG) 2021 (pp. 1-6). Paper, Talk, Code\nVillareale, J., Biemer, C., Seif El-Nasr, M., \u0026amp; Zhu, J. (2020, September). Reflection in Game-Based Learning: A Survey of Programming Games. In International Conference on the Foundations of Digital Games (pp. 1-9). Paper\n","permalink":"http://localhost:1313/publications/","summary":"\u003cp\u003eBiemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). \u003cbr\u003e\n\u003ca href=\"/pdf/2024_solution_path_heuristics.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). \u003cbr\u003e\n\u003ca href=\"/pdf/2023_ddaviaplgviamdp.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e","title":"Publications"},{"content":"Introduction Hello, world! I\u0026rsquo;m here again :D\n","permalink":"http://localhost:1313/games/second/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eHello, world! I\u0026rsquo;m here again :D\u003c/p\u003e","title":"Second"},{"content":"Generative Design in Minecraft (GDMC) GDMC is a competition to generate settlements within a selection of a minecraft map. The project\u0026rsquo;s website provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\nMCEdit To generate settlements, the competition has gone the route of using MCEdit to allow competitors to view, generate, and modify minecraft maps. GDMC provides a wiki with easy to use instructions for installing and general set up. The wiki also provides an example cellular automata script for generating structures seen in figure one. As you can see, the output isn’t great, but it provides a nice starting point. It, also, shows how to work with the MCEdit filters which is how we can interact with the maps.\nFigure 1: Example cellular automata output from CASG_Example.py Filters A filter is how we are able to modify maps. To activate a filter, a user makes a selection on the map via a left click and dragging your mouse. From there, on the bottom of the screen, there is a potion looking icon that when pressed will open the filter menu. This provides a drop down menu of available filters. Each of these filters provides a set of options and the ability to perform their respective actions. When activated they will make modifications to the map given the users selection area. Each of the filters are Python 2.7 scripts located in the stock-filters directory.\nFilter Basics The wiki provides some helpful commentary in getting started with filters, but the script is a bit too complicated for a starting point. There are, however, two things that every filter has in common: the perform function and inputs tuple.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def perform(level, box, options): pass When a filter is activated, the engine will call the perform function and pass the level data (this data structure will be explored further in the next post), the bounding box, and the set of options a user has defined. The bounding box defines the origin of the box the user created and the size. The options is a dictionary based on the inputs defined in the above script. Therefore, to access the materials you could use options[“Material”] to be able to see what the user set.\nBox in all Eight Corners of Selection Now that we understand the basics, we can start with a simple filter. The goal of this filter is to place a user defined material in all eight corners of the user’s selection. The end result can be seen in figure two. The first step here is to define the inputs for the user. In this case, the above inputs code is exactly what we need.\nFigure 2: Example of placing blocks at all eight corners of user\u0026#39;s selection space Now we need to know how to draw a block and this can be found in the utility functions provided by NYU. I haven’t figured out the point of the function setBlockDataAt yet, but in the second post I intend to investigate more to figure it out. In the meantime, I wrote a simpler function because the data was always set to 0 in the examples I could find.\ndef draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) With that complete, the only problem now is figuring out how to use the bounding box to find the eight corners. As noted above, the way the bounding box works is by providing an origin and size vector. All variations of adding these two together will provide eight values which are, coincidentally, the corners of the cube. The full filter can be seen below.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) def perform(level, box, options): material = options[\u0026#34;Material\u0026#34;] draw_block(level, box.origin.x, box.origin.y, box.origin.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y, box.origin.z, material) draw_block(level, box.origin.x, box.origin.y + box.size.y, box.origin.z, material) draw_block(level, box.origin.x, box.origin.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x, box.origin.y + box.size.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z + box.size.z, material) ","permalink":"http://localhost:1313/posts/second/","summary":"\u003ch1 id=\"generative-design-in-minecraft-gdmc\"\u003eGenerative Design in Minecraft (GDMC)\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eGDMC\u003c/a\u003e is a competition to generate settlements within a selection of a minecraft map. The \u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eproject\u0026rsquo;s website\u003c/a\u003e provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\u003c/p\u003e","title":"Generative Design in Mineraft: MCEdit Basics"},{"content":"This is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, Swig’s website for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on Swig\u0026rsquo;s website and a StackOverflow question for Python 3. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\n1. Install # python-dev sudo apt-get install python-dev # python2.x sudo apt-get install python3-dev # python3.x # swig sudo apt-get install swig 2. Source c++ Fibonacci implementation, filename: fib.cpp\n#include \u0026#34;fib.h\u0026#34; int fibonacci(int n) { if(n \u0026lt;= 1) return n; return fibonacci(n-1) + fibonacci(n-2); } c++ fibonacci header file, filename: fib.h. I\u0026rsquo;m going to explain why this file exists in a moment.\nint fibonacci(int n); The next file is the interface file for swig, fib.i. This is telling swig what bindings it will need to create and is why we implemented fib.h.\n%module Fibonacci %{ #include \u0026#34;fib.h\u0026#34; %} %include \u0026#34;fib.h\u0026#34; The alternative to creating the fib.h file is directly below. For this we define each function individually for swig to then bind.\n%module Fibonacci %{ int fibonacci(int n); %} int fibonacci(int n); 3. Build setup.py, this file is taken directly from Swig\u0026rsquo;s documentation and modified slightly.\n#!/usr/bin/env python from distutils.core import setup, Extension fib_module = Extension( \u0026#39;_Fibonacci\u0026#39;, sources=[\u0026#39;fib_wrap.cxx\u0026#39;, \u0026#39;fib.cpp\u0026#39;], # fib_wrap.cxx is going to be generated by swig ) setup ( name = \u0026#39;Fibonacci\u0026#39;, version = \u0026#39;0.0\u0026#39;, author = \u0026#34;YOUR_NAME\u0026#34;, description = \u0026#34;Fibonacci swig\u0026#34;, ext_modules = [fib_module], py_modules = [\u0026#34;Fibonacci\u0026#34;], # name of module that we\u0026#39;re going import ) build.sh or whatever you fancy.\n#!/bin/bash swig -c++ -python fib.i python setup.py build_ext --inplace 4. Run Assign permissions (e.g. chmod 755 build.sh) and run ./build.sh. From there you can go into the python console and test by running the following:\n$ python \u0026gt;\u0026gt;\u0026gt; import Fibonacci \u0026gt;\u0026gt;\u0026gt; Fibonacci.fibonacci(10) 55 5. Conclusion Please let me know if anything here can be improved so I can update this for future readers. Regardless, I hope this helped some of you with your projects/work and saved you some time.\n","permalink":"http://localhost:1313/posts/first/","summary":"\u003cp\u003eThis is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig’s website\u003c/a\u003e for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig\u0026rsquo;s website\u003c/a\u003e and a \u003ca href=\"https://stackoverflow.com/questions/32667888/building-extension-for-python-3-with-swig-and-distutils\"\u003eStackOverflow question for Python 3\u003c/a\u003e. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\u003c/p\u003e","title":"C++ to Python Bindings with Swig"},{"content":"Biemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). Paper\nBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). Paper\nBiemer, C., \u0026amp; Cooper, S. (2022, October). Level Assembly as a Markov Decision Process. In 2022 Proceedings of the Experimental AI in Games Workshop. Paper, Talk, Code\nBiemer, C., \u0026amp; Cooper, S. (2022, August). On Linking Level Segments. In 2022 IEEE Conference on Games (CoG) (pp. 199-205). ★ Best Paper Nominee Paper, Talk, Code\nBiemer, C., Hervella, A., \u0026amp; Cooper, S. (2021, August). Gram-Elites: N-Gram Based Quality-Diversity Search. In The 16th International Conference on the Foundations of Digital Games (FDG) 2021 (pp. 1-6). Paper, Talk, Code\nVillareale, J., Biemer, C., Seif El-Nasr, M., \u0026amp; Zhu, J. (2020, September). Reflection in Game-Based Learning: A Survey of Programming Games. In International Conference on the Foundations of Digital Games (pp. 1-9). Paper\n","permalink":"http://localhost:1313/publications/","summary":"\u003cp\u003eBiemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). \u003cbr\u003e\n\u003ca href=\"/pdf/2024_solution_path_heuristics.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). \u003cbr\u003e\n\u003ca href=\"/pdf/2023_ddaviaplgviamdp.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e","title":"Publications"},{"content":"Introduction Hello, world! I\u0026rsquo;m here again :D\n","permalink":"http://localhost:1313/games/second/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eHello, world! I\u0026rsquo;m here again :D\u003c/p\u003e","title":"Second"},{"content":"Generative Design in Minecraft (GDMC) GDMC is a competition to generate settlements within a selection of a minecraft map. The project\u0026rsquo;s website provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\nMCEdit To generate settlements, the competition has gone the route of using MCEdit to allow competitors to view, generate, and modify minecraft maps. GDMC provides a wiki with easy to use instructions for installing and general set up. The wiki also provides an example cellular automata script for generating structures seen in figure one. As you can see, the output isn’t great, but it provides a nice starting point. It, also, shows how to work with the MCEdit filters which is how we can interact with the maps.\nFigure 1: Example cellular automata output from CASG_Example.py Filters A filter is how we are able to modify maps. To activate a filter, a user makes a selection on the map via a left click and dragging your mouse. From there, on the bottom of the screen, there is a potion looking icon that when pressed will open the filter menu. This provides a drop down menu of available filters. Each of these filters provides a set of options and the ability to perform their respective actions. When activated they will make modifications to the map given the users selection area. Each of the filters are Python 2.7 scripts located in the stock-filters directory.\nFilter Basics The wiki provides some helpful commentary in getting started with filters, but the script is a bit too complicated for a starting point. There are, however, two things that every filter has in common: the perform function and inputs tuple.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def perform(level, box, options): pass When a filter is activated, the engine will call the perform function and pass the level data (this data structure will be explored further in the next post), the bounding box, and the set of options a user has defined. The bounding box defines the origin of the box the user created and the size. The options is a dictionary based on the inputs defined in the above script. Therefore, to access the materials you could use options[“Material”] to be able to see what the user set.\nBox in all Eight Corners of Selection Now that we understand the basics, we can start with a simple filter. The goal of this filter is to place a user defined material in all eight corners of the user’s selection. The end result can be seen in figure two. The first step here is to define the inputs for the user. In this case, the above inputs code is exactly what we need.\nFigure 2: Example of placing blocks at all eight corners of user\u0026#39;s selection space Now we need to know how to draw a block and this can be found in the utility functions provided by NYU. I haven’t figured out the point of the function setBlockDataAt yet, but in the second post I intend to investigate more to figure it out. In the meantime, I wrote a simpler function because the data was always set to 0 in the examples I could find.\ndef draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) With that complete, the only problem now is figuring out how to use the bounding box to find the eight corners. As noted above, the way the bounding box works is by providing an origin and size vector. All variations of adding these two together will provide eight values which are, coincidentally, the corners of the cube. The full filter can be seen below.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) def perform(level, box, options): material = options[\u0026#34;Material\u0026#34;] draw_block(level, box.origin.x, box.origin.y, box.origin.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y, box.origin.z, material) draw_block(level, box.origin.x, box.origin.y + box.size.y, box.origin.z, material) draw_block(level, box.origin.x, box.origin.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x, box.origin.y + box.size.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z + box.size.z, material) Fill Selection In comparison to the eight boxes, this is a lot easier conceptually. All we want to do is fill the entire users selection with a material. The end result can be seen in figure three.\nFigure 3: Two examples of filling in users selection with a different materials The setup is exactly the same as last time where you can use the inputs to define the material. We can even use the draw_block function. At this point, it is probably best to create a script that contains common functions that could be useful in the future. From there, we need to create a function fill_box which takes in the level, origin, size, and material. To fill the box, it is as simple as three for loops that go through all possible x, y, and z values. It is important that you loop from the minimum to the maximum of these, else there is a chance you will not completely fill in the box.\n","permalink":"http://localhost:1313/posts/second/","summary":"\u003ch1 id=\"generative-design-in-minecraft-gdmc\"\u003eGenerative Design in Minecraft (GDMC)\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eGDMC\u003c/a\u003e is a competition to generate settlements within a selection of a minecraft map. The \u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eproject\u0026rsquo;s website\u003c/a\u003e provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\u003c/p\u003e","title":"Generative Design in Mineraft: MCEdit Basics"},{"content":"This is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, Swig’s website for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on Swig\u0026rsquo;s website and a StackOverflow question for Python 3. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\n1. Install # python-dev sudo apt-get install python-dev # python2.x sudo apt-get install python3-dev # python3.x # swig sudo apt-get install swig 2. Source c++ Fibonacci implementation, filename: fib.cpp\n#include \u0026#34;fib.h\u0026#34; int fibonacci(int n) { if(n \u0026lt;= 1) return n; return fibonacci(n-1) + fibonacci(n-2); } c++ fibonacci header file, filename: fib.h. I\u0026rsquo;m going to explain why this file exists in a moment.\nint fibonacci(int n); The next file is the interface file for swig, fib.i. This is telling swig what bindings it will need to create and is why we implemented fib.h.\n%module Fibonacci %{ #include \u0026#34;fib.h\u0026#34; %} %include \u0026#34;fib.h\u0026#34; The alternative to creating the fib.h file is directly below. For this we define each function individually for swig to then bind.\n%module Fibonacci %{ int fibonacci(int n); %} int fibonacci(int n); 3. Build setup.py, this file is taken directly from Swig\u0026rsquo;s documentation and modified slightly.\n#!/usr/bin/env python from distutils.core import setup, Extension fib_module = Extension( \u0026#39;_Fibonacci\u0026#39;, sources=[\u0026#39;fib_wrap.cxx\u0026#39;, \u0026#39;fib.cpp\u0026#39;], # fib_wrap.cxx is going to be generated by swig ) setup ( name = \u0026#39;Fibonacci\u0026#39;, version = \u0026#39;0.0\u0026#39;, author = \u0026#34;YOUR_NAME\u0026#34;, description = \u0026#34;Fibonacci swig\u0026#34;, ext_modules = [fib_module], py_modules = [\u0026#34;Fibonacci\u0026#34;], # name of module that we\u0026#39;re going import ) build.sh or whatever you fancy.\n#!/bin/bash swig -c++ -python fib.i python setup.py build_ext --inplace 4. Run Assign permissions (e.g. chmod 755 build.sh) and run ./build.sh. From there you can go into the python console and test by running the following:\n$ python \u0026gt;\u0026gt;\u0026gt; import Fibonacci \u0026gt;\u0026gt;\u0026gt; Fibonacci.fibonacci(10) 55 5. Conclusion Please let me know if anything here can be improved so I can update this for future readers. Regardless, I hope this helped some of you with your projects/work and saved you some time.\n","permalink":"http://localhost:1313/posts/first/","summary":"\u003cp\u003eThis is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig’s website\u003c/a\u003e for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig\u0026rsquo;s website\u003c/a\u003e and a \u003ca href=\"https://stackoverflow.com/questions/32667888/building-extension-for-python-3-with-swig-and-distutils\"\u003eStackOverflow question for Python 3\u003c/a\u003e. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\u003c/p\u003e","title":"C++ to Python Bindings with Swig"},{"content":"Biemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). Paper\nBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). Paper\nBiemer, C., \u0026amp; Cooper, S. (2022, October). Level Assembly as a Markov Decision Process. In 2022 Proceedings of the Experimental AI in Games Workshop. Paper, Talk, Code\nBiemer, C., \u0026amp; Cooper, S. (2022, August). On Linking Level Segments. In 2022 IEEE Conference on Games (CoG) (pp. 199-205). ★ Best Paper Nominee Paper, Talk, Code\nBiemer, C., Hervella, A., \u0026amp; Cooper, S. (2021, August). Gram-Elites: N-Gram Based Quality-Diversity Search. In The 16th International Conference on the Foundations of Digital Games (FDG) 2021 (pp. 1-6). Paper, Talk, Code\nVillareale, J., Biemer, C., Seif El-Nasr, M., \u0026amp; Zhu, J. (2020, September). Reflection in Game-Based Learning: A Survey of Programming Games. In International Conference on the Foundations of Digital Games (pp. 1-9). Paper\n","permalink":"http://localhost:1313/publications/","summary":"\u003cp\u003eBiemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). \u003cbr\u003e\n\u003ca href=\"/pdf/2024_solution_path_heuristics.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). \u003cbr\u003e\n\u003ca href=\"/pdf/2023_ddaviaplgviamdp.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e","title":"Publications"},{"content":"Introduction Hello, world! I\u0026rsquo;m here again :D\n","permalink":"http://localhost:1313/games/second/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eHello, world! I\u0026rsquo;m here again :D\u003c/p\u003e","title":"Second"},{"content":"Generative Design in Minecraft (GDMC) GDMC is a competition to generate settlements within a selection of a minecraft map. The project\u0026rsquo;s website provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\nMCEdit To generate settlements, the competition has gone the route of using MCEdit to allow competitors to view, generate, and modify minecraft maps. GDMC provides a wiki with easy to use instructions for installing and general set up. The wiki also provides an example cellular automata script for generating structures seen in figure one. As you can see, the output isn’t great, but it provides a nice starting point. It, also, shows how to work with the MCEdit filters which is how we can interact with the maps.\nFigure 1: Example cellular automata output from CASG_Example.py Filters A filter is how we are able to modify maps. To activate a filter, a user makes a selection on the map via a left click and dragging your mouse. From there, on the bottom of the screen, there is a potion looking icon that when pressed will open the filter menu. This provides a drop down menu of available filters. Each of these filters provides a set of options and the ability to perform their respective actions. When activated they will make modifications to the map given the users selection area. Each of the filters are Python 2.7 scripts located in the stock-filters directory.\nFilter Basics The wiki provides some helpful commentary in getting started with filters, but the script is a bit too complicated for a starting point. There are, however, two things that every filter has in common: the perform function and inputs tuple.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def perform(level, box, options): pass When a filter is activated, the engine will call the perform function and pass the level data (this data structure will be explored further in the next post), the bounding box, and the set of options a user has defined. The bounding box defines the origin of the box the user created and the size. The options is a dictionary based on the inputs defined in the above script. Therefore, to access the materials you could use options[“Material”] to be able to see what the user set.\nBox in all Eight Corners of Selection Now that we understand the basics, we can start with a simple filter. The goal of this filter is to place a user defined material in all eight corners of the user’s selection. The end result can be seen in figure two. The first step here is to define the inputs for the user. In this case, the above inputs code is exactly what we need.\nFigure 2: Example of placing blocks at all eight corners of user\u0026#39;s selection space Now we need to know how to draw a block and this can be found in the utility functions provided by NYU. I haven’t figured out the point of the function setBlockDataAt yet, but in the second post I intend to investigate more to figure it out. In the meantime, I wrote a simpler function because the data was always set to 0 in the examples I could find.\ndef draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) With that complete, the only problem now is figuring out how to use the bounding box to find the eight corners. As noted above, the way the bounding box works is by providing an origin and size vector. All variations of adding these two together will provide eight values which are, coincidentally, the corners of the cube. The full filter can be seen below.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) def perform(level, box, options): material = options[\u0026#34;Material\u0026#34;] draw_block(level, box.origin.x, box.origin.y, box.origin.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y, box.origin.z, material) draw_block(level, box.origin.x, box.origin.y + box.size.y, box.origin.z, material) draw_block(level, box.origin.x, box.origin.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x, box.origin.y + box.size.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z + box.size.z, material) Fill Selection In comparison to the eight boxes, this is a lot easier conceptually. All we want to do is fill the entire users selection with a material. The end result can be seen in figure three.\nFigure 3: Two examples of filling in users selection with a different materials The setup is exactly the same as last time where you can use the inputs to define the material. We can even use the draw_block function. At this point, it is probably best to create a script that contains common functions that could be useful in the future. From there, we need to create a function fill_box which takes in the level, origin, size, and material. To fill the box, it is as simple as three for loops that go through all possible x, y, and z values. It is important that you loop from the minimum to the maximum of these, else there is a chance you will not completely fill in the box.\n","permalink":"http://localhost:1313/posts/second/","summary":"\u003ch1 id=\"generative-design-in-minecraft-gdmc\"\u003eGenerative Design in Minecraft (GDMC)\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eGDMC\u003c/a\u003e is a competition to generate settlements within a selection of a minecraft map. The \u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eproject\u0026rsquo;s website\u003c/a\u003e provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\u003c/p\u003e","title":"Generative Design in Mineraft: MCEdit Basics"},{"content":"This is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, Swig’s website for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on Swig\u0026rsquo;s website and a StackOverflow question for Python 3. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\n1. Install # python-dev sudo apt-get install python-dev # python2.x sudo apt-get install python3-dev # python3.x # swig sudo apt-get install swig 2. Source c++ Fibonacci implementation, filename: fib.cpp\n#include \u0026#34;fib.h\u0026#34; int fibonacci(int n) { if(n \u0026lt;= 1) return n; return fibonacci(n-1) + fibonacci(n-2); } c++ fibonacci header file, filename: fib.h. I\u0026rsquo;m going to explain why this file exists in a moment.\nint fibonacci(int n); The next file is the interface file for swig, fib.i. This is telling swig what bindings it will need to create and is why we implemented fib.h.\n%module Fibonacci %{ #include \u0026#34;fib.h\u0026#34; %} %include \u0026#34;fib.h\u0026#34; The alternative to creating the fib.h file is directly below. For this we define each function individually for swig to then bind.\n%module Fibonacci %{ int fibonacci(int n); %} int fibonacci(int n); 3. Build setup.py, this file is taken directly from Swig\u0026rsquo;s documentation and modified slightly.\n#!/usr/bin/env python from distutils.core import setup, Extension fib_module = Extension( \u0026#39;_Fibonacci\u0026#39;, sources=[\u0026#39;fib_wrap.cxx\u0026#39;, \u0026#39;fib.cpp\u0026#39;], # fib_wrap.cxx is going to be generated by swig ) setup ( name = \u0026#39;Fibonacci\u0026#39;, version = \u0026#39;0.0\u0026#39;, author = \u0026#34;YOUR_NAME\u0026#34;, description = \u0026#34;Fibonacci swig\u0026#34;, ext_modules = [fib_module], py_modules = [\u0026#34;Fibonacci\u0026#34;], # name of module that we\u0026#39;re going import ) build.sh or whatever you fancy.\n#!/bin/bash swig -c++ -python fib.i python setup.py build_ext --inplace 4. Run Assign permissions (e.g. chmod 755 build.sh) and run ./build.sh. From there you can go into the python console and test by running the following:\n$ python \u0026gt;\u0026gt;\u0026gt; import Fibonacci \u0026gt;\u0026gt;\u0026gt; Fibonacci.fibonacci(10) 55 5. Conclusion Please let me know if anything here can be improved so I can update this for future readers. Regardless, I hope this helped some of you with your projects/work and saved you some time.\n","permalink":"http://localhost:1313/posts/first/","summary":"\u003cp\u003eThis is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig’s website\u003c/a\u003e for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig\u0026rsquo;s website\u003c/a\u003e and a \u003ca href=\"https://stackoverflow.com/questions/32667888/building-extension-for-python-3-with-swig-and-distutils\"\u003eStackOverflow question for Python 3\u003c/a\u003e. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\u003c/p\u003e","title":"C++ to Python Bindings with Swig"},{"content":"Biemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). Paper\nBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). Paper\nBiemer, C., \u0026amp; Cooper, S. (2022, October). Level Assembly as a Markov Decision Process. In 2022 Proceedings of the Experimental AI in Games Workshop. Paper, Talk, Code\nBiemer, C., \u0026amp; Cooper, S. (2022, August). On Linking Level Segments. In 2022 IEEE Conference on Games (CoG) (pp. 199-205). ★ Best Paper Nominee Paper, Talk, Code\nBiemer, C., Hervella, A., \u0026amp; Cooper, S. (2021, August). Gram-Elites: N-Gram Based Quality-Diversity Search. In The 16th International Conference on the Foundations of Digital Games (FDG) 2021 (pp. 1-6). Paper, Talk, Code\nVillareale, J., Biemer, C., Seif El-Nasr, M., \u0026amp; Zhu, J. (2020, September). Reflection in Game-Based Learning: A Survey of Programming Games. In International Conference on the Foundations of Digital Games (pp. 1-9). Paper\n","permalink":"http://localhost:1313/publications/","summary":"\u003cp\u003eBiemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). \u003cbr\u003e\n\u003ca href=\"/pdf/2024_solution_path_heuristics.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). \u003cbr\u003e\n\u003ca href=\"/pdf/2023_ddaviaplgviamdp.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e","title":"Publications"},{"content":"Introduction Hello, world! I\u0026rsquo;m here again :D\n","permalink":"http://localhost:1313/games/second/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eHello, world! I\u0026rsquo;m here again :D\u003c/p\u003e","title":"Second"},{"content":"Generative Design in Minecraft (GDMC) GDMC is a competition to generate settlements within a selection of a minecraft map. The project\u0026rsquo;s website provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\nMCEdit To generate settlements, the competition has gone the route of using MCEdit to allow competitors to view, generate, and modify minecraft maps. GDMC provides a wiki with easy to use instructions for installing and general set up. The wiki also provides an example cellular automata script for generating structures seen in figure one. As you can see, the output isn’t great, but it provides a nice starting point. It, also, shows how to work with the MCEdit filters which is how we can interact with the maps.\nFigure 1: Example cellular automata output from CASG_Example.py Filters A filter is how we are able to modify maps. To activate a filter, a user makes a selection on the map via a left click and dragging your mouse. From there, on the bottom of the screen, there is a potion looking icon that when pressed will open the filter menu. This provides a drop down menu of available filters. Each of these filters provides a set of options and the ability to perform their respective actions. When activated they will make modifications to the map given the users selection area. Each of the filters are Python 2.7 scripts located in the stock-filters directory.\nFilter Basics The wiki provides some helpful commentary in getting started with filters, but the script is a bit too complicated for a starting point. There are, however, two things that every filter has in common: the perform function and inputs tuple.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def perform(level, box, options): pass When a filter is activated, the engine will call the perform function and pass the level data (this data structure will be explored further in the next post), the bounding box, and the set of options a user has defined. The bounding box defines the origin of the box the user created and the size. The options is a dictionary based on the inputs defined in the above script. Therefore, to access the materials you could use options[“Material”] to be able to see what the user set.\nBox in all Eight Corners of Selection Now that we understand the basics, we can start with a simple filter. The goal of this filter is to place a user defined material in all eight corners of the user’s selection. The end result can be seen in figure two. The first step here is to define the inputs for the user. In this case, the above inputs code is exactly what we need.\nFigure 2: Example of placing blocks at all eight corners of user\u0026#39;s selection space Now we need to know how to draw a block and this can be found in the utility functions provided by NYU. I haven’t figured out the point of the function setBlockDataAt yet, but in the second post I intend to investigate more to figure it out. In the meantime, I wrote a simpler function because the data was always set to 0 in the examples I could find.\ndef draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) With that complete, the only problem now is figuring out how to use the bounding box to find the eight corners. As noted above, the way the bounding box works is by providing an origin and size vector. All variations of adding these two together will provide eight values which are, coincidentally, the corners of the cube. The full filter can be seen below.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) def perform(level, box, options): material = options[\u0026#34;Material\u0026#34;] draw_block(level, box.origin.x, box.origin.y, box.origin.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y, box.origin.z, material) draw_block(level, box.origin.x, box.origin.y + box.size.y, box.origin.z, material) draw_block(level, box.origin.x, box.origin.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x, box.origin.y + box.size.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z + box.size.z, material) Fill Selection In comparison to the eight boxes, this is a lot easier conceptually. All we want to do is fill the entire users selection with a material. The end result can be seen in figure three.\nFigure 3: Two examples of filling in users selection with a different materials The setup is exactly the same as last time where you can use the inputs to define the material. We can even use the draw_block function. At this point, it is probably best to create a script that contains common functions that could be useful in the future. From there, we need to create a function fill_box which takes in the level, origin, size, and material. To fill the box, it is as simple as three for loops that go through all possible x, y, and z values. It is important that you loop from the minimum to the maximum of these, else there is a chance you will not completely fill in the box.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace All\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) def fill_box(level, origin, size, material): final_x = origin.x + size.x final_y = origin.y + size.y final_z = origin.z + size.z for x in range(min(origin.x, final_x), max(origin.x, final_x)): for y in range(min(origin.y, final_y), max(origin.y, final_y)): for z in range(min(origin.z, final_z), max(origin.z, final_z)): draw_block(level, x, y, z, material) def perform(level, box, options): fill_box(level, box.origin, box.size, options[\u0026#34;Material\u0026#34;]) ","permalink":"http://localhost:1313/posts/second/","summary":"\u003ch1 id=\"generative-design-in-minecraft-gdmc\"\u003eGenerative Design in Minecraft (GDMC)\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eGDMC\u003c/a\u003e is a competition to generate settlements within a selection of a minecraft map. The \u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eproject\u0026rsquo;s website\u003c/a\u003e provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\u003c/p\u003e","title":"Generative Design in Mineraft: MCEdit Basics"},{"content":"This is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, Swig’s website for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on Swig\u0026rsquo;s website and a StackOverflow question for Python 3. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\n1. Install # python-dev sudo apt-get install python-dev # python2.x sudo apt-get install python3-dev # python3.x # swig sudo apt-get install swig 2. Source c++ Fibonacci implementation, filename: fib.cpp\n#include \u0026#34;fib.h\u0026#34; int fibonacci(int n) { if(n \u0026lt;= 1) return n; return fibonacci(n-1) + fibonacci(n-2); } c++ fibonacci header file, filename: fib.h. I\u0026rsquo;m going to explain why this file exists in a moment.\nint fibonacci(int n); The next file is the interface file for swig, fib.i. This is telling swig what bindings it will need to create and is why we implemented fib.h.\n%module Fibonacci %{ #include \u0026#34;fib.h\u0026#34; %} %include \u0026#34;fib.h\u0026#34; The alternative to creating the fib.h file is directly below. For this we define each function individually for swig to then bind.\n%module Fibonacci %{ int fibonacci(int n); %} int fibonacci(int n); 3. Build setup.py, this file is taken directly from Swig\u0026rsquo;s documentation and modified slightly.\n#!/usr/bin/env python from distutils.core import setup, Extension fib_module = Extension( \u0026#39;_Fibonacci\u0026#39;, sources=[\u0026#39;fib_wrap.cxx\u0026#39;, \u0026#39;fib.cpp\u0026#39;], # fib_wrap.cxx is going to be generated by swig ) setup ( name = \u0026#39;Fibonacci\u0026#39;, version = \u0026#39;0.0\u0026#39;, author = \u0026#34;YOUR_NAME\u0026#34;, description = \u0026#34;Fibonacci swig\u0026#34;, ext_modules = [fib_module], py_modules = [\u0026#34;Fibonacci\u0026#34;], # name of module that we\u0026#39;re going import ) build.sh or whatever you fancy.\n#!/bin/bash swig -c++ -python fib.i python setup.py build_ext --inplace 4. Run Assign permissions (e.g. chmod 755 build.sh) and run ./build.sh. From there you can go into the python console and test by running the following:\n$ python \u0026gt;\u0026gt;\u0026gt; import Fibonacci \u0026gt;\u0026gt;\u0026gt; Fibonacci.fibonacci(10) 55 5. Conclusion Please let me know if anything here can be improved so I can update this for future readers. Regardless, I hope this helped some of you with your projects/work and saved you some time.\n","permalink":"http://localhost:1313/posts/first/","summary":"\u003cp\u003eThis is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig’s website\u003c/a\u003e for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig\u0026rsquo;s website\u003c/a\u003e and a \u003ca href=\"https://stackoverflow.com/questions/32667888/building-extension-for-python-3-with-swig-and-distutils\"\u003eStackOverflow question for Python 3\u003c/a\u003e. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\u003c/p\u003e","title":"C++ to Python Bindings with Swig"},{"content":"Biemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). Paper\nBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). Paper\nBiemer, C., \u0026amp; Cooper, S. (2022, October). Level Assembly as a Markov Decision Process. In 2022 Proceedings of the Experimental AI in Games Workshop. Paper, Talk, Code\nBiemer, C., \u0026amp; Cooper, S. (2022, August). On Linking Level Segments. In 2022 IEEE Conference on Games (CoG) (pp. 199-205). ★ Best Paper Nominee Paper, Talk, Code\nBiemer, C., Hervella, A., \u0026amp; Cooper, S. (2021, August). Gram-Elites: N-Gram Based Quality-Diversity Search. In The 16th International Conference on the Foundations of Digital Games (FDG) 2021 (pp. 1-6). Paper, Talk, Code\nVillareale, J., Biemer, C., Seif El-Nasr, M., \u0026amp; Zhu, J. (2020, September). Reflection in Game-Based Learning: A Survey of Programming Games. In International Conference on the Foundations of Digital Games (pp. 1-9). Paper\n","permalink":"http://localhost:1313/publications/","summary":"\u003cp\u003eBiemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). \u003cbr\u003e\n\u003ca href=\"/pdf/2024_solution_path_heuristics.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). \u003cbr\u003e\n\u003ca href=\"/pdf/2023_ddaviaplgviamdp.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e","title":"Publications"},{"content":"Introduction Hello, world! I\u0026rsquo;m here again :D\n","permalink":"http://localhost:1313/games/second/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eHello, world! I\u0026rsquo;m here again :D\u003c/p\u003e","title":"Second"},{"content":"Generative Design in Minecraft (GDMC) GDMC is a competition to generate settlements within a selection of a minecraft map. The project\u0026rsquo;s website provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\nMCEdit To generate settlements, the competition has gone the route of using MCEdit to allow competitors to view, generate, and modify minecraft maps. GDMC provides a wiki with easy to use instructions for installing and general set up. The wiki also provides an example cellular automata script for generating structures seen in figure one. As you can see, the output isn’t great, but it provides a nice starting point. It, also, shows how to work with the MCEdit filters which is how we can interact with the maps.\nFigure 1: Example cellular automata output from CASG_Example.py Filters A filter is how we are able to modify maps. To activate a filter, a user makes a selection on the map via a left click and dragging your mouse. From there, on the bottom of the screen, there is a potion looking icon that when pressed will open the filter menu. This provides a drop down menu of available filters. Each of these filters provides a set of options and the ability to perform their respective actions. When activated they will make modifications to the map given the users selection area. Each of the filters are Python 2.7 scripts located in the stock-filters directory.\nFilter Basics The wiki provides some helpful commentary in getting started with filters, but the script is a bit too complicated for a starting point. There are, however, two things that every filter has in common: the perform function and inputs tuple.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def perform(level, box, options): pass When a filter is activated, the engine will call the perform function and pass the level data (this data structure will be explored further in the next post), the bounding box, and the set of options a user has defined. The bounding box defines the origin of the box the user created and the size. The options is a dictionary based on the inputs defined in the above script. Therefore, to access the materials you could use options[“Material”] to be able to see what the user set.\nBox in all Eight Corners of Selection Now that we understand the basics, we can start with a simple filter. The goal of this filter is to place a user defined material in all eight corners of the user’s selection. The end result can be seen in figure two. The first step here is to define the inputs for the user. In this case, the above inputs code is exactly what we need.\nFigure 2: Example of placing blocks at all eight corners of user\u0026#39;s selection space Now we need to know how to draw a block and this can be found in the utility functions provided by NYU. I haven’t figured out the point of the function setBlockDataAt yet, but in the second post I intend to investigate more to figure it out. In the meantime, I wrote a simpler function because the data was always set to 0 in the examples I could find.\ndef draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) With that complete, the only problem now is figuring out how to use the bounding box to find the eight corners. As noted above, the way the bounding box works is by providing an origin and size vector. All variations of adding these two together will provide eight values which are, coincidentally, the corners of the cube. The full filter can be seen below.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) def perform(level, box, options): material = options[\u0026#34;Material\u0026#34;] draw_block(level, box.origin.x, box.origin.y, box.origin.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y, box.origin.z, material) draw_block(level, box.origin.x, box.origin.y + box.size.y, box.origin.z, material) draw_block(level, box.origin.x, box.origin.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x, box.origin.y + box.size.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z + box.size.z, material) Fill Selection In comparison to the eight boxes, this is a lot easier conceptually. All we want to do is fill the entire users selection with a material. The end result can be seen in figure three.\nFigure 3: Two examples of filling in users selection with a different materials The setup is exactly the same as last time where you can use the inputs to define the material. We can even use the draw_block function. At this point, it is probably best to create a script that contains common functions that could be useful in the future. From there, we need to create a function fill_box which takes in the level, origin, size, and material. To fill the box, it is as simple as three for loops that go through all possible x, y, and z values. It is important that you loop from the minimum to the maximum of these, else there is a chance you will not completely fill in the box.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace All\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) def fill_box(level, origin, size, material): final_x = origin.x + size.x final_y = origin.y + size.y final_z = origin.z + size.z for x in range(min(origin.x, final_x), max(origin.x, final_x)): for y in range(min(origin.y, final_y), max(origin.y, final_y)): for z in range(min(origin.z, final_z), max(origin.z, final_z)): draw_block(level, x, y, z, material) def perform(level, box, options): fill_box(level, box.origin, box.size, options[\u0026#34;Material\u0026#34;]) ","permalink":"http://localhost:1313/posts/second/","summary":"\u003ch1 id=\"generative-design-in-minecraft-gdmc\"\u003eGenerative Design in Minecraft (GDMC)\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eGDMC\u003c/a\u003e is a competition to generate settlements within a selection of a minecraft map. The \u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eproject\u0026rsquo;s website\u003c/a\u003e provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\u003c/p\u003e","title":"Generative Design in Mineraft: MCEdit Basics"},{"content":"This is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, Swig’s website for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on Swig\u0026rsquo;s website and a StackOverflow question for Python 3. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\n1. Install # python-dev sudo apt-get install python-dev # python2.x sudo apt-get install python3-dev # python3.x # swig sudo apt-get install swig 2. Source c++ Fibonacci implementation, filename: fib.cpp\n#include \u0026#34;fib.h\u0026#34; int fibonacci(int n) { if(n \u0026lt;= 1) return n; return fibonacci(n-1) + fibonacci(n-2); } c++ fibonacci header file, filename: fib.h. I\u0026rsquo;m going to explain why this file exists in a moment.\nint fibonacci(int n); The next file is the interface file for swig, fib.i. This is telling swig what bindings it will need to create and is why we implemented fib.h.\n%module Fibonacci %{ #include \u0026#34;fib.h\u0026#34; %} %include \u0026#34;fib.h\u0026#34; The alternative to creating the fib.h file is directly below. For this we define each function individually for swig to then bind.\n%module Fibonacci %{ int fibonacci(int n); %} int fibonacci(int n); 3. Build setup.py, this file is taken directly from Swig\u0026rsquo;s documentation and modified slightly.\n#!/usr/bin/env python from distutils.core import setup, Extension fib_module = Extension( \u0026#39;_Fibonacci\u0026#39;, sources=[\u0026#39;fib_wrap.cxx\u0026#39;, \u0026#39;fib.cpp\u0026#39;], # fib_wrap.cxx is going to be generated by swig ) setup ( name = \u0026#39;Fibonacci\u0026#39;, version = \u0026#39;0.0\u0026#39;, author = \u0026#34;YOUR_NAME\u0026#34;, description = \u0026#34;Fibonacci swig\u0026#34;, ext_modules = [fib_module], py_modules = [\u0026#34;Fibonacci\u0026#34;], # name of module that we\u0026#39;re going import ) build.sh or whatever you fancy.\n#!/bin/bash swig -c++ -python fib.i python setup.py build_ext --inplace 4. Run Assign permissions (e.g. chmod 755 build.sh) and run ./build.sh. From there you can go into the python console and test by running the following:\n$ python \u0026gt;\u0026gt;\u0026gt; import Fibonacci \u0026gt;\u0026gt;\u0026gt; Fibonacci.fibonacci(10) 55 5. Conclusion Please let me know if anything here can be improved so I can update this for future readers. Regardless, I hope this helped some of you with your projects/work and saved you some time.\n","permalink":"http://localhost:1313/posts/first/","summary":"\u003cp\u003eThis is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig’s website\u003c/a\u003e for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig\u0026rsquo;s website\u003c/a\u003e and a \u003ca href=\"https://stackoverflow.com/questions/32667888/building-extension-for-python-3-with-swig-and-distutils\"\u003eStackOverflow question for Python 3\u003c/a\u003e. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\u003c/p\u003e","title":"C++ to Python Bindings with Swig"},{"content":"Biemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). Paper\nBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). Paper\nBiemer, C., \u0026amp; Cooper, S. (2022, October). Level Assembly as a Markov Decision Process. In 2022 Proceedings of the Experimental AI in Games Workshop. Paper, Talk, Code\nBiemer, C., \u0026amp; Cooper, S. (2022, August). On Linking Level Segments. In 2022 IEEE Conference on Games (CoG) (pp. 199-205). ★ Best Paper Nominee Paper, Talk, Code\nBiemer, C., Hervella, A., \u0026amp; Cooper, S. (2021, August). Gram-Elites: N-Gram Based Quality-Diversity Search. In The 16th International Conference on the Foundations of Digital Games (FDG) 2021 (pp. 1-6). Paper, Talk, Code\nVillareale, J., Biemer, C., Seif El-Nasr, M., \u0026amp; Zhu, J. (2020, September). Reflection in Game-Based Learning: A Survey of Programming Games. In International Conference on the Foundations of Digital Games (pp. 1-9). Paper\n","permalink":"http://localhost:1313/publications/","summary":"\u003cp\u003eBiemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). \u003cbr\u003e\n\u003ca href=\"/pdf/2024_solution_path_heuristics.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). \u003cbr\u003e\n\u003ca href=\"/pdf/2023_ddaviaplgviamdp.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e","title":"Publications"},{"content":"Introduction Hello, world! I\u0026rsquo;m here again :D\n","permalink":"http://localhost:1313/games/second/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eHello, world! I\u0026rsquo;m here again :D\u003c/p\u003e","title":"Second"},{"content":"Generative Design in Minecraft (GDMC) GDMC is a competition to generate settlements within a selection of a minecraft map. The project\u0026rsquo;s website provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\nMCEdit To generate settlements, the competition has gone the route of using MCEdit to allow competitors to view, generate, and modify minecraft maps. GDMC provides a wiki with easy to use instructions for installing and general set up. The wiki also provides an example cellular automata script for generating structures seen in figure one. As you can see, the output isn’t great, but it provides a nice starting point. It, also, shows how to work with the MCEdit filters which is how we can interact with the maps.\nFigure 1: Example cellular automata output from CASG_Example.py Filters A filter is how we are able to modify maps. To activate a filter, a user makes a selection on the map via a left click and dragging your mouse. From there, on the bottom of the screen, there is a potion looking icon that when pressed will open the filter menu. This provides a drop down menu of available filters. Each of these filters provides a set of options and the ability to perform their respective actions. When activated they will make modifications to the map given the users selection area. Each of the filters are Python 2.7 scripts located in the stock-filters directory.\nFilter Basics The wiki provides some helpful commentary in getting started with filters, but the script is a bit too complicated for a starting point. There are, however, two things that every filter has in common: the perform function and inputs tuple.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def perform(level, box, options): pass When a filter is activated, the engine will call the perform function and pass the level data (this data structure will be explored further in the next post), the bounding box, and the set of options a user has defined. The bounding box defines the origin of the box the user created and the size. The options is a dictionary based on the inputs defined in the above script. Therefore, to access the materials you could use options[“Material”] to be able to see what the user set.\nBox in all Eight Corners of Selection Now that we understand the basics, we can start with a simple filter. The goal of this filter is to place a user defined material in all eight corners of the user’s selection. The end result can be seen in figure two. The first step here is to define the inputs for the user. In this case, the above inputs code is exactly what we need.\nFigure 2: Example of placing blocks at all eight corners of user\u0026#39;s selection space Now we need to know how to draw a block and this can be found in the utility functions provided by NYU. I haven’t figured out the point of the function setBlockDataAt yet, but in the second post I intend to investigate more to figure it out. In the meantime, I wrote a simpler function because the data was always set to 0 in the examples I could find.\ndef draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) With that complete, the only problem now is figuring out how to use the bounding box to find the eight corners. As noted above, the way the bounding box works is by providing an origin and size vector. All variations of adding these two together will provide eight values which are, coincidentally, the corners of the cube. The full filter can be seen below.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) def perform(level, box, options): material = options[\u0026#34;Material\u0026#34;] draw_block(level, box.origin.x, box.origin.y, box.origin.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y, box.origin.z, material) draw_block(level, box.origin.x, box.origin.y + box.size.y, box.origin.z, material) draw_block(level, box.origin.x, box.origin.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x, box.origin.y + box.size.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z + box.size.z, material) Fill Selection In comparison to the eight boxes, this is a lot easier conceptually. All we want to do is fill the entire users selection with a material. The end result can be seen in figure three.\nFigure 3: Two examples of filling in users selection with a different materials The setup is exactly the same as last time where you can use the inputs to define the material. We can even use the draw_block function. At this point, it is probably best to create a script that contains common functions that could be useful in the future. From there, we need to create a function fill_box which takes in the level, origin, size, and material. To fill the box, it is as simple as three for loops that go through all possible x, y, and z values. It is important that you loop from the minimum to the maximum of these, else there is a chance you will not completely fill in the box.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace All\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) def fill_box(level, origin, size, material): final_x = origin.x + size.x final_y = origin.y + size.y final_z = origin.z + size.z for x in range(min(origin.x, final_x), max(origin.x, final_x)): for y in range(min(origin.y, final_y), max(origin.y, final_y)): for z in range(min(origin.z, final_z), max(origin.z, final_z)): draw_block(level, x, y, z, material) def perform(level, box, options): fill_box(level, box.origin, box.size, options[\u0026#34;Material\u0026#34;]) Box Outline In this case we want to take the user’s selection and draw blocks along the edges, an example can be seen in figure four. The complexity for this problem is creating a function that will properly draw lines. Specifically, it is necessary to make sure it can draw diagonal lines for the sake of completeness.\nFigure 4: Example of drawing the edges for a user\u0026#39;s selection ","permalink":"http://localhost:1313/posts/second/","summary":"\u003ch1 id=\"generative-design-in-minecraft-gdmc\"\u003eGenerative Design in Minecraft (GDMC)\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eGDMC\u003c/a\u003e is a competition to generate settlements within a selection of a minecraft map. The \u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eproject\u0026rsquo;s website\u003c/a\u003e provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\u003c/p\u003e","title":"Generative Design in Mineraft: MCEdit Basics"},{"content":"This is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, Swig’s website for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on Swig\u0026rsquo;s website and a StackOverflow question for Python 3. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\n1. Install # python-dev sudo apt-get install python-dev # python2.x sudo apt-get install python3-dev # python3.x # swig sudo apt-get install swig 2. Source c++ Fibonacci implementation, filename: fib.cpp\n#include \u0026#34;fib.h\u0026#34; int fibonacci(int n) { if(n \u0026lt;= 1) return n; return fibonacci(n-1) + fibonacci(n-2); } c++ fibonacci header file, filename: fib.h. I\u0026rsquo;m going to explain why this file exists in a moment.\nint fibonacci(int n); The next file is the interface file for swig, fib.i. This is telling swig what bindings it will need to create and is why we implemented fib.h.\n%module Fibonacci %{ #include \u0026#34;fib.h\u0026#34; %} %include \u0026#34;fib.h\u0026#34; The alternative to creating the fib.h file is directly below. For this we define each function individually for swig to then bind.\n%module Fibonacci %{ int fibonacci(int n); %} int fibonacci(int n); 3. Build setup.py, this file is taken directly from Swig\u0026rsquo;s documentation and modified slightly.\n#!/usr/bin/env python from distutils.core import setup, Extension fib_module = Extension( \u0026#39;_Fibonacci\u0026#39;, sources=[\u0026#39;fib_wrap.cxx\u0026#39;, \u0026#39;fib.cpp\u0026#39;], # fib_wrap.cxx is going to be generated by swig ) setup ( name = \u0026#39;Fibonacci\u0026#39;, version = \u0026#39;0.0\u0026#39;, author = \u0026#34;YOUR_NAME\u0026#34;, description = \u0026#34;Fibonacci swig\u0026#34;, ext_modules = [fib_module], py_modules = [\u0026#34;Fibonacci\u0026#34;], # name of module that we\u0026#39;re going import ) build.sh or whatever you fancy.\n#!/bin/bash swig -c++ -python fib.i python setup.py build_ext --inplace 4. Run Assign permissions (e.g. chmod 755 build.sh) and run ./build.sh. From there you can go into the python console and test by running the following:\n$ python \u0026gt;\u0026gt;\u0026gt; import Fibonacci \u0026gt;\u0026gt;\u0026gt; Fibonacci.fibonacci(10) 55 5. Conclusion Please let me know if anything here can be improved so I can update this for future readers. Regardless, I hope this helped some of you with your projects/work and saved you some time.\n","permalink":"http://localhost:1313/posts/first/","summary":"\u003cp\u003eThis is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig’s website\u003c/a\u003e for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig\u0026rsquo;s website\u003c/a\u003e and a \u003ca href=\"https://stackoverflow.com/questions/32667888/building-extension-for-python-3-with-swig-and-distutils\"\u003eStackOverflow question for Python 3\u003c/a\u003e. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\u003c/p\u003e","title":"C++ to Python Bindings with Swig"},{"content":"Biemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). Paper\nBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). Paper\nBiemer, C., \u0026amp; Cooper, S. (2022, October). Level Assembly as a Markov Decision Process. In 2022 Proceedings of the Experimental AI in Games Workshop. Paper, Talk, Code\nBiemer, C., \u0026amp; Cooper, S. (2022, August). On Linking Level Segments. In 2022 IEEE Conference on Games (CoG) (pp. 199-205). ★ Best Paper Nominee Paper, Talk, Code\nBiemer, C., Hervella, A., \u0026amp; Cooper, S. (2021, August). Gram-Elites: N-Gram Based Quality-Diversity Search. In The 16th International Conference on the Foundations of Digital Games (FDG) 2021 (pp. 1-6). Paper, Talk, Code\nVillareale, J., Biemer, C., Seif El-Nasr, M., \u0026amp; Zhu, J. (2020, September). Reflection in Game-Based Learning: A Survey of Programming Games. In International Conference on the Foundations of Digital Games (pp. 1-9). Paper\n","permalink":"http://localhost:1313/publications/","summary":"\u003cp\u003eBiemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). \u003cbr\u003e\n\u003ca href=\"/pdf/2024_solution_path_heuristics.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). \u003cbr\u003e\n\u003ca href=\"/pdf/2023_ddaviaplgviamdp.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e","title":"Publications"},{"content":"Introduction Hello, world! I\u0026rsquo;m here again :D\n","permalink":"http://localhost:1313/games/second/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eHello, world! I\u0026rsquo;m here again :D\u003c/p\u003e","title":"Second"},{"content":"Generative Design in Minecraft (GDMC) GDMC is a competition to generate settlements within a selection of a minecraft map. The project\u0026rsquo;s website provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\nMCEdit To generate settlements, the competition has gone the route of using MCEdit to allow competitors to view, generate, and modify minecraft maps. GDMC provides a wiki with easy to use instructions for installing and general set up. The wiki also provides an example cellular automata script for generating structures seen in figure one. As you can see, the output isn’t great, but it provides a nice starting point. It, also, shows how to work with the MCEdit filters which is how we can interact with the maps.\nFigure 1: Example cellular automata output from CASG_Example.py Filters A filter is how we are able to modify maps. To activate a filter, a user makes a selection on the map via a left click and dragging your mouse. From there, on the bottom of the screen, there is a potion looking icon that when pressed will open the filter menu. This provides a drop down menu of available filters. Each of these filters provides a set of options and the ability to perform their respective actions. When activated they will make modifications to the map given the users selection area. Each of the filters are Python 2.7 scripts located in the stock-filters directory.\nFilter Basics The wiki provides some helpful commentary in getting started with filters, but the script is a bit too complicated for a starting point. There are, however, two things that every filter has in common: the perform function and inputs tuple.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def perform(level, box, options): pass When a filter is activated, the engine will call the perform function and pass the level data (this data structure will be explored further in the next post), the bounding box, and the set of options a user has defined. The bounding box defines the origin of the box the user created and the size. The options is a dictionary based on the inputs defined in the above script. Therefore, to access the materials you could use options[“Material”] to be able to see what the user set.\nBox in all Eight Corners of Selection Now that we understand the basics, we can start with a simple filter. The goal of this filter is to place a user defined material in all eight corners of the user’s selection. The end result can be seen in figure two. The first step here is to define the inputs for the user. In this case, the above inputs code is exactly what we need.\nFigure 2: Example of placing blocks at all eight corners of user\u0026#39;s selection space Now we need to know how to draw a block and this can be found in the utility functions provided by NYU. I haven’t figured out the point of the function setBlockDataAt yet, but in the second post I intend to investigate more to figure it out. In the meantime, I wrote a simpler function because the data was always set to 0 in the examples I could find.\ndef draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) With that complete, the only problem now is figuring out how to use the bounding box to find the eight corners. As noted above, the way the bounding box works is by providing an origin and size vector. All variations of adding these two together will provide eight values which are, coincidentally, the corners of the cube. The full filter can be seen below.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) def perform(level, box, options): material = options[\u0026#34;Material\u0026#34;] draw_block(level, box.origin.x, box.origin.y, box.origin.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y, box.origin.z, material) draw_block(level, box.origin.x, box.origin.y + box.size.y, box.origin.z, material) draw_block(level, box.origin.x, box.origin.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x, box.origin.y + box.size.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z + box.size.z, material) Fill Selection In comparison to the eight boxes, this is a lot easier conceptually. All we want to do is fill the entire users selection with a material. The end result can be seen in figure three.\nFigure 3: Two examples of filling in users selection with a different materials The setup is exactly the same as last time where you can use the inputs to define the material. We can even use the draw_block function. At this point, it is probably best to create a script that contains common functions that could be useful in the future. From there, we need to create a function fill_box which takes in the level, origin, size, and material. To fill the box, it is as simple as three for loops that go through all possible x, y, and z values. It is important that you loop from the minimum to the maximum of these, else there is a chance you will not completely fill in the box.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace All\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) def fill_box(level, origin, size, material): final_x = origin.x + size.x final_y = origin.y + size.y final_z = origin.z + size.z for x in range(min(origin.x, final_x), max(origin.x, final_x)): for y in range(min(origin.y, final_y), max(origin.y, final_y)): for z in range(min(origin.z, final_z), max(origin.z, final_z)): draw_block(level, x, y, z, material) def perform(level, box, options): fill_box(level, box.origin, box.size, options[\u0026#34;Material\u0026#34;]) Box Outline In this case we want to take the user’s selection and draw blocks along the edges, an example can be seen in figure four. The complexity for this problem is creating a function that will properly draw lines. Specifically, it is necessary to make sure it can draw diagonal lines for the sake of completeness.\nFigure 4: Example of drawing the edges for a user\u0026#39;s selection ","permalink":"http://localhost:1313/posts/second/","summary":"\u003ch1 id=\"generative-design-in-minecraft-gdmc\"\u003eGenerative Design in Minecraft (GDMC)\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eGDMC\u003c/a\u003e is a competition to generate settlements within a selection of a minecraft map. The \u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eproject\u0026rsquo;s website\u003c/a\u003e provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\u003c/p\u003e","title":"Generative Design in Mineraft: MCEdit Basics"},{"content":"This is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, Swig’s website for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on Swig\u0026rsquo;s website and a StackOverflow question for Python 3. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\n1. Install # python-dev sudo apt-get install python-dev # python2.x sudo apt-get install python3-dev # python3.x # swig sudo apt-get install swig 2. Source c++ Fibonacci implementation, filename: fib.cpp\n#include \u0026#34;fib.h\u0026#34; int fibonacci(int n) { if(n \u0026lt;= 1) return n; return fibonacci(n-1) + fibonacci(n-2); } c++ fibonacci header file, filename: fib.h. I\u0026rsquo;m going to explain why this file exists in a moment.\nint fibonacci(int n); The next file is the interface file for swig, fib.i. This is telling swig what bindings it will need to create and is why we implemented fib.h.\n%module Fibonacci %{ #include \u0026#34;fib.h\u0026#34; %} %include \u0026#34;fib.h\u0026#34; The alternative to creating the fib.h file is directly below. For this we define each function individually for swig to then bind.\n%module Fibonacci %{ int fibonacci(int n); %} int fibonacci(int n); 3. Build setup.py, this file is taken directly from Swig\u0026rsquo;s documentation and modified slightly.\n#!/usr/bin/env python from distutils.core import setup, Extension fib_module = Extension( \u0026#39;_Fibonacci\u0026#39;, sources=[\u0026#39;fib_wrap.cxx\u0026#39;, \u0026#39;fib.cpp\u0026#39;], # fib_wrap.cxx is going to be generated by swig ) setup ( name = \u0026#39;Fibonacci\u0026#39;, version = \u0026#39;0.0\u0026#39;, author = \u0026#34;YOUR_NAME\u0026#34;, description = \u0026#34;Fibonacci swig\u0026#34;, ext_modules = [fib_module], py_modules = [\u0026#34;Fibonacci\u0026#34;], # name of module that we\u0026#39;re going import ) build.sh or whatever you fancy.\n#!/bin/bash swig -c++ -python fib.i python setup.py build_ext --inplace 4. Run Assign permissions (e.g. chmod 755 build.sh) and run ./build.sh. From there you can go into the python console and test by running the following:\n$ python \u0026gt;\u0026gt;\u0026gt; import Fibonacci \u0026gt;\u0026gt;\u0026gt; Fibonacci.fibonacci(10) 55 5. Conclusion Please let me know if anything here can be improved so I can update this for future readers. Regardless, I hope this helped some of you with your projects/work and saved you some time.\n","permalink":"http://localhost:1313/posts/first/","summary":"\u003cp\u003eThis is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig’s website\u003c/a\u003e for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig\u0026rsquo;s website\u003c/a\u003e and a \u003ca href=\"https://stackoverflow.com/questions/32667888/building-extension-for-python-3-with-swig-and-distutils\"\u003eStackOverflow question for Python 3\u003c/a\u003e. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\u003c/p\u003e","title":"C++ to Python Bindings with Swig"},{"content":"Biemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). Paper\nBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). Paper\nBiemer, C., \u0026amp; Cooper, S. (2022, October). Level Assembly as a Markov Decision Process. In 2022 Proceedings of the Experimental AI in Games Workshop. Paper, Talk, Code\nBiemer, C., \u0026amp; Cooper, S. (2022, August). On Linking Level Segments. In 2022 IEEE Conference on Games (CoG) (pp. 199-205). ★ Best Paper Nominee Paper, Talk, Code\nBiemer, C., Hervella, A., \u0026amp; Cooper, S. (2021, August). Gram-Elites: N-Gram Based Quality-Diversity Search. In The 16th International Conference on the Foundations of Digital Games (FDG) 2021 (pp. 1-6). Paper, Talk, Code\nVillareale, J., Biemer, C., Seif El-Nasr, M., \u0026amp; Zhu, J. (2020, September). Reflection in Game-Based Learning: A Survey of Programming Games. In International Conference on the Foundations of Digital Games (pp. 1-9). Paper\n","permalink":"http://localhost:1313/publications/","summary":"\u003cp\u003eBiemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). \u003cbr\u003e\n\u003ca href=\"/pdf/2024_solution_path_heuristics.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). \u003cbr\u003e\n\u003ca href=\"/pdf/2023_ddaviaplgviamdp.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e","title":"Publications"},{"content":"Introduction Hello, world! I\u0026rsquo;m here again :D\n","permalink":"http://localhost:1313/games/second/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eHello, world! I\u0026rsquo;m here again :D\u003c/p\u003e","title":"Second"},{"content":"Generative Design in Minecraft (GDMC) GDMC is a competition to generate settlements within a selection of a minecraft map. The project\u0026rsquo;s website provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\nMCEdit To generate settlements, the competition has gone the route of using MCEdit to allow competitors to view, generate, and modify minecraft maps. GDMC provides a wiki with easy to use instructions for installing and general set up. The wiki also provides an example cellular automata script for generating structures seen in figure one. As you can see, the output isn’t great, but it provides a nice starting point. It, also, shows how to work with the MCEdit filters which is how we can interact with the maps.\nFigure 1: Example cellular automata output from CASG_Example.py Filters A filter is how we are able to modify maps. To activate a filter, a user makes a selection on the map via a left click and dragging your mouse. From there, on the bottom of the screen, there is a potion looking icon that when pressed will open the filter menu. This provides a drop down menu of available filters. Each of these filters provides a set of options and the ability to perform their respective actions. When activated they will make modifications to the map given the users selection area. Each of the filters are Python 2.7 scripts located in the stock-filters directory.\nFilter Basics The wiki provides some helpful commentary in getting started with filters, but the script is a bit too complicated for a starting point. There are, however, two things that every filter has in common: the perform function and inputs tuple.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def perform(level, box, options): pass When a filter is activated, the engine will call the perform function and pass the level data (this data structure will be explored further in the next post), the bounding box, and the set of options a user has defined. The bounding box defines the origin of the box the user created and the size. The options is a dictionary based on the inputs defined in the above script. Therefore, to access the materials you could use options[“Material”] to be able to see what the user set.\nBox in all Eight Corners of Selection Now that we understand the basics, we can start with a simple filter. The goal of this filter is to place a user defined material in all eight corners of the user’s selection. The end result can be seen in figure two. The first step here is to define the inputs for the user. In this case, the above inputs code is exactly what we need.\nFigure 2: Example of placing blocks at all eight corners of user\u0026#39;s selection space Now we need to know how to draw a block and this can be found in the utility functions provided by NYU. I haven’t figured out the point of the function setBlockDataAt yet, but in the second post I intend to investigate more to figure it out. In the meantime, I wrote a simpler function because the data was always set to 0 in the examples I could find.\ndef draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) With that complete, the only problem now is figuring out how to use the bounding box to find the eight corners. As noted above, the way the bounding box works is by providing an origin and size vector. All variations of adding these two together will provide eight values which are, coincidentally, the corners of the cube. The full filter can be seen below.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) def perform(level, box, options): material = options[\u0026#34;Material\u0026#34;] draw_block(level, box.origin.x, box.origin.y, box.origin.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y, box.origin.z, material) draw_block(level, box.origin.x, box.origin.y + box.size.y, box.origin.z, material) draw_block(level, box.origin.x, box.origin.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x, box.origin.y + box.size.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z + box.size.z, material) Fill Selection In comparison to the eight boxes, this is a lot easier conceptually. All we want to do is fill the entire users selection with a material. The end result can be seen in figure three.\nFigure 3: Two examples of filling in users selection with a different materials The setup is exactly the same as last time where you can use the inputs to define the material. We can even use the draw_block function. At this point, it is probably best to create a script that contains common functions that could be useful in the future. From there, we need to create a function fill_box which takes in the level, origin, size, and material. To fill the box, it is as simple as three for loops that go through all possible x, y, and z values. It is important that you loop from the minimum to the maximum of these, else there is a chance you will not completely fill in the box.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace All\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) def fill_box(level, origin, size, material): final_x = origin.x + size.x final_y = origin.y + size.y final_z = origin.z + size.z for x in range(min(origin.x, final_x), max(origin.x, final_x)): for y in range(min(origin.y, final_y), max(origin.y, final_y)): for z in range(min(origin.z, final_z), max(origin.z, final_z)): draw_block(level, x, y, z, material) def perform(level, box, options): fill_box(level, box.origin, box.size, options[\u0026#34;Material\u0026#34;]) Box Outline In this case we want to take the user’s selection and draw blocks along the edges, an example can be seen in figure four. The complexity for this problem is creating a function that will properly draw lines. Specifically, it is necessary to make sure it can draw diagonal lines for the sake of completeness.\nFigure 4: Example of drawing the edges for a user\u0026#39;s selection The main difficulty in this problem is making sure every direction a line can move is accounted for. The list is quite long but mainly requires some attentiveness on our our part when defining all the possibilities.\ndirections = [(1,0,0),(-1,0,0),(0,1,0),(0,-1,0),(0,0,1),(0,0,-1),\\ (1,1,0),(-1,1,0),(1,-1,0),(-1,-1,0),(0,1,1),(0,-1,1),\\ (0,1,-1),(0,-1,-1),(1,0,1),(-1,0,1),(1,0,-1),(-1,0,-1),\\ (1,1,1),(-1,1,1),(1,-1,1),(1,1,-1),(-1,-1,1),(-1,1,-1),\\ (1,-1,-1),(-1,-1,-1)] ","permalink":"http://localhost:1313/posts/second/","summary":"\u003ch1 id=\"generative-design-in-minecraft-gdmc\"\u003eGenerative Design in Minecraft (GDMC)\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eGDMC\u003c/a\u003e is a competition to generate settlements within a selection of a minecraft map. The \u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eproject\u0026rsquo;s website\u003c/a\u003e provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\u003c/p\u003e","title":"Generative Design in Mineraft: MCEdit Basics"},{"content":"This is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, Swig’s website for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on Swig\u0026rsquo;s website and a StackOverflow question for Python 3. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\n1. Install # python-dev sudo apt-get install python-dev # python2.x sudo apt-get install python3-dev # python3.x # swig sudo apt-get install swig 2. Source c++ Fibonacci implementation, filename: fib.cpp\n#include \u0026#34;fib.h\u0026#34; int fibonacci(int n) { if(n \u0026lt;= 1) return n; return fibonacci(n-1) + fibonacci(n-2); } c++ fibonacci header file, filename: fib.h. I\u0026rsquo;m going to explain why this file exists in a moment.\nint fibonacci(int n); The next file is the interface file for swig, fib.i. This is telling swig what bindings it will need to create and is why we implemented fib.h.\n%module Fibonacci %{ #include \u0026#34;fib.h\u0026#34; %} %include \u0026#34;fib.h\u0026#34; The alternative to creating the fib.h file is directly below. For this we define each function individually for swig to then bind.\n%module Fibonacci %{ int fibonacci(int n); %} int fibonacci(int n); 3. Build setup.py, this file is taken directly from Swig\u0026rsquo;s documentation and modified slightly.\n#!/usr/bin/env python from distutils.core import setup, Extension fib_module = Extension( \u0026#39;_Fibonacci\u0026#39;, sources=[\u0026#39;fib_wrap.cxx\u0026#39;, \u0026#39;fib.cpp\u0026#39;], # fib_wrap.cxx is going to be generated by swig ) setup ( name = \u0026#39;Fibonacci\u0026#39;, version = \u0026#39;0.0\u0026#39;, author = \u0026#34;YOUR_NAME\u0026#34;, description = \u0026#34;Fibonacci swig\u0026#34;, ext_modules = [fib_module], py_modules = [\u0026#34;Fibonacci\u0026#34;], # name of module that we\u0026#39;re going import ) build.sh or whatever you fancy.\n#!/bin/bash swig -c++ -python fib.i python setup.py build_ext --inplace 4. Run Assign permissions (e.g. chmod 755 build.sh) and run ./build.sh. From there you can go into the python console and test by running the following:\n$ python \u0026gt;\u0026gt;\u0026gt; import Fibonacci \u0026gt;\u0026gt;\u0026gt; Fibonacci.fibonacci(10) 55 5. Conclusion Please let me know if anything here can be improved so I can update this for future readers. Regardless, I hope this helped some of you with your projects/work and saved you some time.\n","permalink":"http://localhost:1313/posts/first/","summary":"\u003cp\u003eThis is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig’s website\u003c/a\u003e for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig\u0026rsquo;s website\u003c/a\u003e and a \u003ca href=\"https://stackoverflow.com/questions/32667888/building-extension-for-python-3-with-swig-and-distutils\"\u003eStackOverflow question for Python 3\u003c/a\u003e. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\u003c/p\u003e","title":"C++ to Python Bindings with Swig"},{"content":"Biemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). Paper\nBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). Paper\nBiemer, C., \u0026amp; Cooper, S. (2022, October). Level Assembly as a Markov Decision Process. In 2022 Proceedings of the Experimental AI in Games Workshop. Paper, Talk, Code\nBiemer, C., \u0026amp; Cooper, S. (2022, August). On Linking Level Segments. In 2022 IEEE Conference on Games (CoG) (pp. 199-205). ★ Best Paper Nominee Paper, Talk, Code\nBiemer, C., Hervella, A., \u0026amp; Cooper, S. (2021, August). Gram-Elites: N-Gram Based Quality-Diversity Search. In The 16th International Conference on the Foundations of Digital Games (FDG) 2021 (pp. 1-6). Paper, Talk, Code\nVillareale, J., Biemer, C., Seif El-Nasr, M., \u0026amp; Zhu, J. (2020, September). Reflection in Game-Based Learning: A Survey of Programming Games. In International Conference on the Foundations of Digital Games (pp. 1-9). Paper\n","permalink":"http://localhost:1313/publications/","summary":"\u003cp\u003eBiemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). \u003cbr\u003e\n\u003ca href=\"/pdf/2024_solution_path_heuristics.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). \u003cbr\u003e\n\u003ca href=\"/pdf/2023_ddaviaplgviamdp.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e","title":"Publications"},{"content":"Introduction Hello, world! I\u0026rsquo;m here again :D\n","permalink":"http://localhost:1313/games/second/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eHello, world! I\u0026rsquo;m here again :D\u003c/p\u003e","title":"Second"},{"content":"Generative Design in Minecraft (GDMC) GDMC is a competition to generate settlements within a selection of a minecraft map. The project\u0026rsquo;s website provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\nMCEdit To generate settlements, the competition has gone the route of using MCEdit to allow competitors to view, generate, and modify minecraft maps. GDMC provides a wiki with easy to use instructions for installing and general set up. The wiki also provides an example cellular automata script for generating structures seen in figure one. As you can see, the output isn’t great, but it provides a nice starting point. It, also, shows how to work with the MCEdit filters which is how we can interact with the maps.\nFigure 1: Example cellular automata output from CASG_Example.py Filters A filter is how we are able to modify maps. To activate a filter, a user makes a selection on the map via a left click and dragging your mouse. From there, on the bottom of the screen, there is a potion looking icon that when pressed will open the filter menu. This provides a drop down menu of available filters. Each of these filters provides a set of options and the ability to perform their respective actions. When activated they will make modifications to the map given the users selection area. Each of the filters are Python 2.7 scripts located in the stock-filters directory.\nFilter Basics The wiki provides some helpful commentary in getting started with filters, but the script is a bit too complicated for a starting point. There are, however, two things that every filter has in common: the perform function and inputs tuple.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def perform(level, box, options): pass When a filter is activated, the engine will call the perform function and pass the level data (this data structure will be explored further in the next post), the bounding box, and the set of options a user has defined. The bounding box defines the origin of the box the user created and the size. The options is a dictionary based on the inputs defined in the above script. Therefore, to access the materials you could use options[“Material”] to be able to see what the user set.\nBox in all Eight Corners of Selection Now that we understand the basics, we can start with a simple filter. The goal of this filter is to place a user defined material in all eight corners of the user’s selection. The end result can be seen in figure two. The first step here is to define the inputs for the user. In this case, the above inputs code is exactly what we need.\nFigure 2: Example of placing blocks at all eight corners of user\u0026#39;s selection space Now we need to know how to draw a block and this can be found in the utility functions provided by NYU. I haven’t figured out the point of the function setBlockDataAt yet, but in the second post I intend to investigate more to figure it out. In the meantime, I wrote a simpler function because the data was always set to 0 in the examples I could find.\ndef draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) With that complete, the only problem now is figuring out how to use the bounding box to find the eight corners. As noted above, the way the bounding box works is by providing an origin and size vector. All variations of adding these two together will provide eight values which are, coincidentally, the corners of the cube. The full filter can be seen below.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) def perform(level, box, options): material = options[\u0026#34;Material\u0026#34;] draw_block(level, box.origin.x, box.origin.y, box.origin.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y, box.origin.z, material) draw_block(level, box.origin.x, box.origin.y + box.size.y, box.origin.z, material) draw_block(level, box.origin.x, box.origin.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x, box.origin.y + box.size.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z + box.size.z, material) Fill Selection In comparison to the eight boxes, this is a lot easier conceptually. All we want to do is fill the entire users selection with a material. The end result can be seen in figure three.\nFigure 3: Two examples of filling in users selection with a different materials The setup is exactly the same as last time where you can use the inputs to define the material. We can even use the draw_block function. At this point, it is probably best to create a script that contains common functions that could be useful in the future. From there, we need to create a function fill_box which takes in the level, origin, size, and material. To fill the box, it is as simple as three for loops that go through all possible x, y, and z values. It is important that you loop from the minimum to the maximum of these, else there is a chance you will not completely fill in the box.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace All\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) def fill_box(level, origin, size, material): final_x = origin.x + size.x final_y = origin.y + size.y final_z = origin.z + size.z for x in range(min(origin.x, final_x), max(origin.x, final_x)): for y in range(min(origin.y, final_y), max(origin.y, final_y)): for z in range(min(origin.z, final_z), max(origin.z, final_z)): draw_block(level, x, y, z, material) def perform(level, box, options): fill_box(level, box.origin, box.size, options[\u0026#34;Material\u0026#34;]) Box Outline In this case we want to take the user’s selection and draw blocks along the edges, an example can be seen in figure four. The complexity for this problem is creating a function that will properly draw lines. Specifically, it is necessary to make sure it can draw diagonal lines for the sake of completeness.\nFigure 4: Example of drawing the edges for a user\u0026#39;s selection The main difficulty in this problem is making sure every direction a line can move is accounted for. The list is quite long but mainly requires some attentiveness on our our part when defining all the possibilities.\ndirections = [ (1,0,0),(-1,0,0),(0,1,0),(0,-1,0),(0,0,1),(0,0,-1),\\ (1,1,0),(-1,1,0),(1,-1,0),(-1,-1,0),(0,1,1),(0,-1,1),\\ (0,1,-1),(0,-1,-1),(1,0,1),(-1,0,1),(1,0,-1),(-1,0,-1),\\ (1,1,1),(-1,1,1),(1,-1,1),(1,1,-1),(-1,-1,1),(-1,1,-1),\\ (1,-1,-1),(-1,-1,-1)] ","permalink":"http://localhost:1313/posts/second/","summary":"\u003ch1 id=\"generative-design-in-minecraft-gdmc\"\u003eGenerative Design in Minecraft (GDMC)\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eGDMC\u003c/a\u003e is a competition to generate settlements within a selection of a minecraft map. The \u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eproject\u0026rsquo;s website\u003c/a\u003e provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\u003c/p\u003e","title":"Generative Design in Mineraft: MCEdit Basics"},{"content":"This is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, Swig’s website for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on Swig\u0026rsquo;s website and a StackOverflow question for Python 3. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\n1. Install # python-dev sudo apt-get install python-dev # python2.x sudo apt-get install python3-dev # python3.x # swig sudo apt-get install swig 2. Source c++ Fibonacci implementation, filename: fib.cpp\n#include \u0026#34;fib.h\u0026#34; int fibonacci(int n) { if(n \u0026lt;= 1) return n; return fibonacci(n-1) + fibonacci(n-2); } c++ fibonacci header file, filename: fib.h. I\u0026rsquo;m going to explain why this file exists in a moment.\nint fibonacci(int n); The next file is the interface file for swig, fib.i. This is telling swig what bindings it will need to create and is why we implemented fib.h.\n%module Fibonacci %{ #include \u0026#34;fib.h\u0026#34; %} %include \u0026#34;fib.h\u0026#34; The alternative to creating the fib.h file is directly below. For this we define each function individually for swig to then bind.\n%module Fibonacci %{ int fibonacci(int n); %} int fibonacci(int n); 3. Build setup.py, this file is taken directly from Swig\u0026rsquo;s documentation and modified slightly.\n#!/usr/bin/env python from distutils.core import setup, Extension fib_module = Extension( \u0026#39;_Fibonacci\u0026#39;, sources=[\u0026#39;fib_wrap.cxx\u0026#39;, \u0026#39;fib.cpp\u0026#39;], # fib_wrap.cxx is going to be generated by swig ) setup ( name = \u0026#39;Fibonacci\u0026#39;, version = \u0026#39;0.0\u0026#39;, author = \u0026#34;YOUR_NAME\u0026#34;, description = \u0026#34;Fibonacci swig\u0026#34;, ext_modules = [fib_module], py_modules = [\u0026#34;Fibonacci\u0026#34;], # name of module that we\u0026#39;re going import ) build.sh or whatever you fancy.\n#!/bin/bash swig -c++ -python fib.i python setup.py build_ext --inplace 4. Run Assign permissions (e.g. chmod 755 build.sh) and run ./build.sh. From there you can go into the python console and test by running the following:\n$ python \u0026gt;\u0026gt;\u0026gt; import Fibonacci \u0026gt;\u0026gt;\u0026gt; Fibonacci.fibonacci(10) 55 5. Conclusion Please let me know if anything here can be improved so I can update this for future readers. Regardless, I hope this helped some of you with your projects/work and saved you some time.\n","permalink":"http://localhost:1313/posts/first/","summary":"\u003cp\u003eThis is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig’s website\u003c/a\u003e for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig\u0026rsquo;s website\u003c/a\u003e and a \u003ca href=\"https://stackoverflow.com/questions/32667888/building-extension-for-python-3-with-swig-and-distutils\"\u003eStackOverflow question for Python 3\u003c/a\u003e. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\u003c/p\u003e","title":"C++ to Python Bindings with Swig"},{"content":"Biemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). Paper\nBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). Paper\nBiemer, C., \u0026amp; Cooper, S. (2022, October). Level Assembly as a Markov Decision Process. In 2022 Proceedings of the Experimental AI in Games Workshop. Paper, Talk, Code\nBiemer, C., \u0026amp; Cooper, S. (2022, August). On Linking Level Segments. In 2022 IEEE Conference on Games (CoG) (pp. 199-205). ★ Best Paper Nominee Paper, Talk, Code\nBiemer, C., Hervella, A., \u0026amp; Cooper, S. (2021, August). Gram-Elites: N-Gram Based Quality-Diversity Search. In The 16th International Conference on the Foundations of Digital Games (FDG) 2021 (pp. 1-6). Paper, Talk, Code\nVillareale, J., Biemer, C., Seif El-Nasr, M., \u0026amp; Zhu, J. (2020, September). Reflection in Game-Based Learning: A Survey of Programming Games. In International Conference on the Foundations of Digital Games (pp. 1-9). Paper\n","permalink":"http://localhost:1313/publications/","summary":"\u003cp\u003eBiemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). \u003cbr\u003e\n\u003ca href=\"/pdf/2024_solution_path_heuristics.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). \u003cbr\u003e\n\u003ca href=\"/pdf/2023_ddaviaplgviamdp.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e","title":"Publications"},{"content":"Introduction Hello, world! I\u0026rsquo;m here again :D\n","permalink":"http://localhost:1313/games/second/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eHello, world! I\u0026rsquo;m here again :D\u003c/p\u003e","title":"Second"},{"content":"Generative Design in Minecraft (GDMC) GDMC is a competition to generate settlements within a selection of a minecraft map. The project\u0026rsquo;s website provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\nMCEdit To generate settlements, the competition has gone the route of using MCEdit to allow competitors to view, generate, and modify minecraft maps. GDMC provides a wiki with easy to use instructions for installing and general set up. The wiki also provides an example cellular automata script for generating structures seen in figure one. As you can see, the output isn’t great, but it provides a nice starting point. It, also, shows how to work with the MCEdit filters which is how we can interact with the maps.\nFigure 1: Example cellular automata output from CASG_Example.py Filters A filter is how we are able to modify maps. To activate a filter, a user makes a selection on the map via a left click and dragging your mouse. From there, on the bottom of the screen, there is a potion looking icon that when pressed will open the filter menu. This provides a drop down menu of available filters. Each of these filters provides a set of options and the ability to perform their respective actions. When activated they will make modifications to the map given the users selection area. Each of the filters are Python 2.7 scripts located in the stock-filters directory.\nFilter Basics The wiki provides some helpful commentary in getting started with filters, but the script is a bit too complicated for a starting point. There are, however, two things that every filter has in common: the perform function and inputs tuple.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def perform(level, box, options): pass When a filter is activated, the engine will call the perform function and pass the level data (this data structure will be explored further in the next post), the bounding box, and the set of options a user has defined. The bounding box defines the origin of the box the user created and the size. The options is a dictionary based on the inputs defined in the above script. Therefore, to access the materials you could use options[“Material”] to be able to see what the user set.\nBox in all Eight Corners of Selection Now that we understand the basics, we can start with a simple filter. The goal of this filter is to place a user defined material in all eight corners of the user’s selection. The end result can be seen in figure two. The first step here is to define the inputs for the user. In this case, the above inputs code is exactly what we need.\nFigure 2: Example of placing blocks at all eight corners of user\u0026#39;s selection space Now we need to know how to draw a block and this can be found in the utility functions provided by NYU. I haven’t figured out the point of the function setBlockDataAt yet, but in the second post I intend to investigate more to figure it out. In the meantime, I wrote a simpler function because the data was always set to 0 in the examples I could find.\ndef draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) With that complete, the only problem now is figuring out how to use the bounding box to find the eight corners. As noted above, the way the bounding box works is by providing an origin and size vector. All variations of adding these two together will provide eight values which are, coincidentally, the corners of the cube. The full filter can be seen below.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) def perform(level, box, options): material = options[\u0026#34;Material\u0026#34;] draw_block(level, box.origin.x, box.origin.y, box.origin.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y, box.origin.z, material) draw_block(level, box.origin.x, box.origin.y + box.size.y, box.origin.z, material) draw_block(level, box.origin.x, box.origin.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x, box.origin.y + box.size.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z + box.size.z, material) Fill Selection In comparison to the eight boxes, this is a lot easier conceptually. All we want to do is fill the entire users selection with a material. The end result can be seen in figure three.\nFigure 3: Two examples of filling in users selection with a different materials The setup is exactly the same as last time where you can use the inputs to define the material. We can even use the draw_block function. At this point, it is probably best to create a script that contains common functions that could be useful in the future. From there, we need to create a function fill_box which takes in the level, origin, size, and material. To fill the box, it is as simple as three for loops that go through all possible x, y, and z values. It is important that you loop from the minimum to the maximum of these, else there is a chance you will not completely fill in the box.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace All\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) def fill_box(level, origin, size, material): final_x = origin.x + size.x final_y = origin.y + size.y final_z = origin.z + size.z for x in range(min(origin.x, final_x), max(origin.x, final_x)): for y in range(min(origin.y, final_y), max(origin.y, final_y)): for z in range(min(origin.z, final_z), max(origin.z, final_z)): draw_block(level, x, y, z, material) def perform(level, box, options): fill_box(level, box.origin, box.size, options[\u0026#34;Material\u0026#34;]) Box Outline In this case we want to take the user’s selection and draw blocks along the edges, an example can be seen in figure four. The complexity for this problem is creating a function that will properly draw lines. Specifically, it is necessary to make sure it can draw diagonal lines for the sake of completeness.\nFigure 4: Example of drawing the edges for a user\u0026#39;s selection The main difficulty in this problem is making sure every direction a line can move is accounted for. The list is quite long but mainly requires some attentiveness on our our part when defining all the possibilities.\ndirections = [ (1,0,0),(-1,0,0),(0,1,0),(0,-1,0),(0,0,1),(0,0,-1),\\ (1,1,0),(-1,1,0),(1,-1,0),(-1,-1,0),(0,1,1),(0,-1,1),\\ (0,1,-1),(0,-1,-1),(1,0,1),(-1,0,1),(1,0,-1),(-1,0,-1),\\ (1,1,1),(-1,1,1),(1,-1,1),(1,1,-1),(-1,-1,1),(-1,1,-1),\\ (1,-1,-1),(-1,-1,-1)] ","permalink":"http://localhost:1313/posts/second/","summary":"\u003ch1 id=\"generative-design-in-minecraft-gdmc\"\u003eGenerative Design in Minecraft (GDMC)\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eGDMC\u003c/a\u003e is a competition to generate settlements within a selection of a minecraft map. The \u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eproject\u0026rsquo;s website\u003c/a\u003e provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\u003c/p\u003e","title":"Generative Design in Mineraft: MCEdit Basics"},{"content":"This is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, Swig’s website for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on Swig\u0026rsquo;s website and a StackOverflow question for Python 3. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\n1. Install # python-dev sudo apt-get install python-dev # python2.x sudo apt-get install python3-dev # python3.x # swig sudo apt-get install swig 2. Source c++ Fibonacci implementation, filename: fib.cpp\n#include \u0026#34;fib.h\u0026#34; int fibonacci(int n) { if(n \u0026lt;= 1) return n; return fibonacci(n-1) + fibonacci(n-2); } c++ fibonacci header file, filename: fib.h. I\u0026rsquo;m going to explain why this file exists in a moment.\nint fibonacci(int n); The next file is the interface file for swig, fib.i. This is telling swig what bindings it will need to create and is why we implemented fib.h.\n%module Fibonacci %{ #include \u0026#34;fib.h\u0026#34; %} %include \u0026#34;fib.h\u0026#34; The alternative to creating the fib.h file is directly below. For this we define each function individually for swig to then bind.\n%module Fibonacci %{ int fibonacci(int n); %} int fibonacci(int n); 3. Build setup.py, this file is taken directly from Swig\u0026rsquo;s documentation and modified slightly.\n#!/usr/bin/env python from distutils.core import setup, Extension fib_module = Extension( \u0026#39;_Fibonacci\u0026#39;, sources=[\u0026#39;fib_wrap.cxx\u0026#39;, \u0026#39;fib.cpp\u0026#39;], # fib_wrap.cxx is going to be generated by swig ) setup ( name = \u0026#39;Fibonacci\u0026#39;, version = \u0026#39;0.0\u0026#39;, author = \u0026#34;YOUR_NAME\u0026#34;, description = \u0026#34;Fibonacci swig\u0026#34;, ext_modules = [fib_module], py_modules = [\u0026#34;Fibonacci\u0026#34;], # name of module that we\u0026#39;re going import ) build.sh or whatever you fancy.\n#!/bin/bash swig -c++ -python fib.i python setup.py build_ext --inplace 4. Run Assign permissions (e.g. chmod 755 build.sh) and run ./build.sh. From there you can go into the python console and test by running the following:\n$ python \u0026gt;\u0026gt;\u0026gt; import Fibonacci \u0026gt;\u0026gt;\u0026gt; Fibonacci.fibonacci(10) 55 5. Conclusion Please let me know if anything here can be improved so I can update this for future readers. Regardless, I hope this helped some of you with your projects/work and saved you some time.\n","permalink":"http://localhost:1313/posts/first/","summary":"\u003cp\u003eThis is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig’s website\u003c/a\u003e for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig\u0026rsquo;s website\u003c/a\u003e and a \u003ca href=\"https://stackoverflow.com/questions/32667888/building-extension-for-python-3-with-swig-and-distutils\"\u003eStackOverflow question for Python 3\u003c/a\u003e. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\u003c/p\u003e","title":"C++ to Python Bindings with Swig"},{"content":"Biemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). Paper\nBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). Paper\nBiemer, C., \u0026amp; Cooper, S. (2022, October). Level Assembly as a Markov Decision Process. In 2022 Proceedings of the Experimental AI in Games Workshop. Paper, Talk, Code\nBiemer, C., \u0026amp; Cooper, S. (2022, August). On Linking Level Segments. In 2022 IEEE Conference on Games (CoG) (pp. 199-205). ★ Best Paper Nominee Paper, Talk, Code\nBiemer, C., Hervella, A., \u0026amp; Cooper, S. (2021, August). Gram-Elites: N-Gram Based Quality-Diversity Search. In The 16th International Conference on the Foundations of Digital Games (FDG) 2021 (pp. 1-6). Paper, Talk, Code\nVillareale, J., Biemer, C., Seif El-Nasr, M., \u0026amp; Zhu, J. (2020, September). Reflection in Game-Based Learning: A Survey of Programming Games. In International Conference on the Foundations of Digital Games (pp. 1-9). Paper\n","permalink":"http://localhost:1313/publications/","summary":"\u003cp\u003eBiemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). \u003cbr\u003e\n\u003ca href=\"/pdf/2024_solution_path_heuristics.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). \u003cbr\u003e\n\u003ca href=\"/pdf/2023_ddaviaplgviamdp.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e","title":"Publications"},{"content":"Introduction Hello, world! I\u0026rsquo;m here again :D\n","permalink":"http://localhost:1313/games/second/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eHello, world! I\u0026rsquo;m here again :D\u003c/p\u003e","title":"Second"},{"content":"Generative Design in Minecraft (GDMC) GDMC is a competition to generate settlements within a selection of a minecraft map. The project\u0026rsquo;s website provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\nMCEdit To generate settlements, the competition has gone the route of using MCEdit to allow competitors to view, generate, and modify minecraft maps. GDMC provides a wiki with easy to use instructions for installing and general set up. The wiki also provides an example cellular automata script for generating structures seen in figure one. As you can see, the output isn’t great, but it provides a nice starting point. It, also, shows how to work with the MCEdit filters which is how we can interact with the maps.\nFigure 1: Example cellular automata output from CASG_Example.py Filters A filter is how we are able to modify maps. To activate a filter, a user makes a selection on the map via a left click and dragging your mouse. From there, on the bottom of the screen, there is a potion looking icon that when pressed will open the filter menu. This provides a drop down menu of available filters. Each of these filters provides a set of options and the ability to perform their respective actions. When activated they will make modifications to the map given the users selection area. Each of the filters are Python 2.7 scripts located in the stock-filters directory.\nFilter Basics The wiki provides some helpful commentary in getting started with filters, but the script is a bit too complicated for a starting point. There are, however, two things that every filter has in common: the perform function and inputs tuple.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def perform(level, box, options): pass When a filter is activated, the engine will call the perform function and pass the level data (this data structure will be explored further in the next post), the bounding box, and the set of options a user has defined. The bounding box defines the origin of the box the user created and the size. The options is a dictionary based on the inputs defined in the above script. Therefore, to access the materials you could use options[“Material”] to be able to see what the user set.\nBox in all Eight Corners of Selection Now that we understand the basics, we can start with a simple filter. The goal of this filter is to place a user defined material in all eight corners of the user’s selection. The end result can be seen in figure two. The first step here is to define the inputs for the user. In this case, the above inputs code is exactly what we need.\nFigure 2: Example of placing blocks at all eight corners of user\u0026#39;s selection space Now we need to know how to draw a block and this can be found in the utility functions provided by NYU. I haven’t figured out the point of the function setBlockDataAt yet, but in the second post I intend to investigate more to figure it out. In the meantime, I wrote a simpler function because the data was always set to 0 in the examples I could find.\ndef draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) With that complete, the only problem now is figuring out how to use the bounding box to find the eight corners. As noted above, the way the bounding box works is by providing an origin and size vector. All variations of adding these two together will provide eight values which are, coincidentally, the corners of the cube. The full filter can be seen below.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) def perform(level, box, options): material = options[\u0026#34;Material\u0026#34;] draw_block(level, box.origin.x, box.origin.y, box.origin.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y, box.origin.z, material) draw_block(level, box.origin.x, box.origin.y + box.size.y, box.origin.z, material) draw_block(level, box.origin.x, box.origin.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x, box.origin.y + box.size.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z + box.size.z, material) Fill Selection In comparison to the eight boxes, this is a lot easier conceptually. All we want to do is fill the entire users selection with a material. The end result can be seen in figure three.\nFigure 3: Two examples of filling in users selection with a different materials The setup is exactly the same as last time where you can use the inputs to define the material. We can even use the draw_block function. At this point, it is probably best to create a script that contains common functions that could be useful in the future. From there, we need to create a function fill_box which takes in the level, origin, size, and material. To fill the box, it is as simple as three for loops that go through all possible x, y, and z values. It is important that you loop from the minimum to the maximum of these, else there is a chance you will not completely fill in the box.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace All\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) def fill_box(level, origin, size, material): final_x = origin.x + size.x final_y = origin.y + size.y final_z = origin.z + size.z for x in range(min(origin.x, final_x), max(origin.x, final_x)): for y in range(min(origin.y, final_y), max(origin.y, final_y)): for z in range(min(origin.z, final_z), max(origin.z, final_z)): draw_block(level, x, y, z, material) def perform(level, box, options): fill_box(level, box.origin, box.size, options[\u0026#34;Material\u0026#34;]) Box Outline In this case we want to take the user’s selection and draw blocks along the edges, an example can be seen in figure four. The complexity for this problem is creating a function that will properly draw lines. Specifically, it is necessary to make sure it can draw diagonal lines for the sake of completeness.\nFigure 4: Example of drawing the edges for a user\u0026#39;s selection The main difficulty in this problem is making sure every direction a line can move is accounted for. The list is quite long but mainly requires some attentiveness on our our part when defining all the possibilities.\ndirections = [ (1,0,0),(-1,0,0),(0,1,0),(0,-1,0),(0,0,1),(0,0,-1),\\ (1,1,0),(-1,1,0),(1,-1,0),(-1,-1,0),(0,1,1),(0,-1,1),\\ (0,1,-1),(0,-1,-1),(1,0,1),(-1,0,1),(1,0,-1),(-1,0,-1),\\ (1,1,1),(-1,1,1),(1,-1,1),(1,1,-1),(-1,-1,1),(-1,1,-1),\\ (1,-1,-1),(-1,-1,-1) ] ","permalink":"http://localhost:1313/posts/second/","summary":"\u003ch1 id=\"generative-design-in-minecraft-gdmc\"\u003eGenerative Design in Minecraft (GDMC)\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eGDMC\u003c/a\u003e is a competition to generate settlements within a selection of a minecraft map. The \u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eproject\u0026rsquo;s website\u003c/a\u003e provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\u003c/p\u003e","title":"Generative Design in Mineraft: MCEdit Basics"},{"content":"This is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, Swig’s website for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on Swig\u0026rsquo;s website and a StackOverflow question for Python 3. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\n1. Install # python-dev sudo apt-get install python-dev # python2.x sudo apt-get install python3-dev # python3.x # swig sudo apt-get install swig 2. Source c++ Fibonacci implementation, filename: fib.cpp\n#include \u0026#34;fib.h\u0026#34; int fibonacci(int n) { if(n \u0026lt;= 1) return n; return fibonacci(n-1) + fibonacci(n-2); } c++ fibonacci header file, filename: fib.h. I\u0026rsquo;m going to explain why this file exists in a moment.\nint fibonacci(int n); The next file is the interface file for swig, fib.i. This is telling swig what bindings it will need to create and is why we implemented fib.h.\n%module Fibonacci %{ #include \u0026#34;fib.h\u0026#34; %} %include \u0026#34;fib.h\u0026#34; The alternative to creating the fib.h file is directly below. For this we define each function individually for swig to then bind.\n%module Fibonacci %{ int fibonacci(int n); %} int fibonacci(int n); 3. Build setup.py, this file is taken directly from Swig\u0026rsquo;s documentation and modified slightly.\n#!/usr/bin/env python from distutils.core import setup, Extension fib_module = Extension( \u0026#39;_Fibonacci\u0026#39;, sources=[\u0026#39;fib_wrap.cxx\u0026#39;, \u0026#39;fib.cpp\u0026#39;], # fib_wrap.cxx is going to be generated by swig ) setup ( name = \u0026#39;Fibonacci\u0026#39;, version = \u0026#39;0.0\u0026#39;, author = \u0026#34;YOUR_NAME\u0026#34;, description = \u0026#34;Fibonacci swig\u0026#34;, ext_modules = [fib_module], py_modules = [\u0026#34;Fibonacci\u0026#34;], # name of module that we\u0026#39;re going import ) build.sh or whatever you fancy.\n#!/bin/bash swig -c++ -python fib.i python setup.py build_ext --inplace 4. Run Assign permissions (e.g. chmod 755 build.sh) and run ./build.sh. From there you can go into the python console and test by running the following:\n$ python \u0026gt;\u0026gt;\u0026gt; import Fibonacci \u0026gt;\u0026gt;\u0026gt; Fibonacci.fibonacci(10) 55 5. Conclusion Please let me know if anything here can be improved so I can update this for future readers. Regardless, I hope this helped some of you with your projects/work and saved you some time.\n","permalink":"http://localhost:1313/posts/first/","summary":"\u003cp\u003eThis is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig’s website\u003c/a\u003e for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig\u0026rsquo;s website\u003c/a\u003e and a \u003ca href=\"https://stackoverflow.com/questions/32667888/building-extension-for-python-3-with-swig-and-distutils\"\u003eStackOverflow question for Python 3\u003c/a\u003e. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\u003c/p\u003e","title":"C++ to Python Bindings with Swig"},{"content":"Biemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). Paper\nBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). Paper\nBiemer, C., \u0026amp; Cooper, S. (2022, October). Level Assembly as a Markov Decision Process. In 2022 Proceedings of the Experimental AI in Games Workshop. Paper, Talk, Code\nBiemer, C., \u0026amp; Cooper, S. (2022, August). On Linking Level Segments. In 2022 IEEE Conference on Games (CoG) (pp. 199-205). ★ Best Paper Nominee Paper, Talk, Code\nBiemer, C., Hervella, A., \u0026amp; Cooper, S. (2021, August). Gram-Elites: N-Gram Based Quality-Diversity Search. In The 16th International Conference on the Foundations of Digital Games (FDG) 2021 (pp. 1-6). Paper, Talk, Code\nVillareale, J., Biemer, C., Seif El-Nasr, M., \u0026amp; Zhu, J. (2020, September). Reflection in Game-Based Learning: A Survey of Programming Games. In International Conference on the Foundations of Digital Games (pp. 1-9). Paper\n","permalink":"http://localhost:1313/publications/","summary":"\u003cp\u003eBiemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). \u003cbr\u003e\n\u003ca href=\"/pdf/2024_solution_path_heuristics.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). \u003cbr\u003e\n\u003ca href=\"/pdf/2023_ddaviaplgviamdp.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e","title":"Publications"},{"content":"Introduction Hello, world! I\u0026rsquo;m here again :D\n","permalink":"http://localhost:1313/games/second/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eHello, world! I\u0026rsquo;m here again :D\u003c/p\u003e","title":"Second"},{"content":"Generative Design in Minecraft (GDMC) GDMC is a competition to generate settlements within a selection of a minecraft map. The project\u0026rsquo;s website provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\nMCEdit To generate settlements, the competition has gone the route of using MCEdit to allow competitors to view, generate, and modify minecraft maps. GDMC provides a wiki with easy to use instructions for installing and general set up. The wiki also provides an example cellular automata script for generating structures seen in figure one. As you can see, the output isn’t great, but it provides a nice starting point. It, also, shows how to work with the MCEdit filters which is how we can interact with the maps.\nFigure 1: Example cellular automata output from CASG_Example.py Filters A filter is how we are able to modify maps. To activate a filter, a user makes a selection on the map via a left click and dragging your mouse. From there, on the bottom of the screen, there is a potion looking icon that when pressed will open the filter menu. This provides a drop down menu of available filters. Each of these filters provides a set of options and the ability to perform their respective actions. When activated they will make modifications to the map given the users selection area. Each of the filters are Python 2.7 scripts located in the stock-filters directory.\nFilter Basics The wiki provides some helpful commentary in getting started with filters, but the script is a bit too complicated for a starting point. There are, however, two things that every filter has in common: the perform function and inputs tuple.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def perform(level, box, options): pass When a filter is activated, the engine will call the perform function and pass the level data (this data structure will be explored further in the next post), the bounding box, and the set of options a user has defined. The bounding box defines the origin of the box the user created and the size. The options is a dictionary based on the inputs defined in the above script. Therefore, to access the materials you could use options[“Material”] to be able to see what the user set.\nBox in all Eight Corners of Selection Now that we understand the basics, we can start with a simple filter. The goal of this filter is to place a user defined material in all eight corners of the user’s selection. The end result can be seen in figure two. The first step here is to define the inputs for the user. In this case, the above inputs code is exactly what we need.\nFigure 2: Example of placing blocks at all eight corners of user\u0026#39;s selection space Now we need to know how to draw a block and this can be found in the utility functions provided by NYU. I haven’t figured out the point of the function setBlockDataAt yet, but in the second post I intend to investigate more to figure it out. In the meantime, I wrote a simpler function because the data was always set to 0 in the examples I could find.\ndef draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) With that complete, the only problem now is figuring out how to use the bounding box to find the eight corners. As noted above, the way the bounding box works is by providing an origin and size vector. All variations of adding these two together will provide eight values which are, coincidentally, the corners of the cube. The full filter can be seen below.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) def perform(level, box, options): material = options[\u0026#34;Material\u0026#34;] draw_block(level, box.origin.x, box.origin.y, box.origin.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y, box.origin.z, material) draw_block(level, box.origin.x, box.origin.y + box.size.y, box.origin.z, material) draw_block(level, box.origin.x, box.origin.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x, box.origin.y + box.size.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z + box.size.z, material) Fill Selection In comparison to the eight boxes, this is a lot easier conceptually. All we want to do is fill the entire users selection with a material. The end result can be seen in figure three.\nFigure 3: Two examples of filling in users selection with a different materials The setup is exactly the same as last time where you can use the inputs to define the material. We can even use the draw_block function. At this point, it is probably best to create a script that contains common functions that could be useful in the future. From there, we need to create a function fill_box which takes in the level, origin, size, and material. To fill the box, it is as simple as three for loops that go through all possible x, y, and z values. It is important that you loop from the minimum to the maximum of these, else there is a chance you will not completely fill in the box.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace All\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) def fill_box(level, origin, size, material): final_x = origin.x + size.x final_y = origin.y + size.y final_z = origin.z + size.z for x in range(min(origin.x, final_x), max(origin.x, final_x)): for y in range(min(origin.y, final_y), max(origin.y, final_y)): for z in range(min(origin.z, final_z), max(origin.z, final_z)): draw_block(level, x, y, z, material) def perform(level, box, options): fill_box(level, box.origin, box.size, options[\u0026#34;Material\u0026#34;]) Box Outline In this case we want to take the user’s selection and draw blocks along the edges, an example can be seen in figure four. The complexity for this problem is creating a function that will properly draw lines. Specifically, it is necessary to make sure it can draw diagonal lines for the sake of completeness.\nFigure 4: Example of drawing the edges for a user\u0026#39;s selection The main difficulty in this problem is making sure every direction a line can move is accounted for. The list is quite long but mainly requires some attentiveness on our our part when defining all the possibilities.\ndirections = [ (1,0,0),(-1,0,0),(0,1,0),(0,-1,0),(0,0,1),(0,0,-1),\\ (1,1,0),(-1,1,0),(1,-1,0),(-1,-1,0),(0,1,1),(0,-1,1),\\ (0,1,-1),(0,-1,-1),(1,0,1),(-1,0,1),(1,0,-1),(-1,0,-1),\\ (1,1,1),(-1,1,1),(1,-1,1),(1,1,-1),(-1,-1,1),(-1,1,-1),\\ (1,-1,-1),(-1,-1,-1) ] We now have the task of using the directions array to draw the line along the shortest path from the starting point to the end point. I first wrote this with a recursive method, where it would find the point closest, with the manhattan distance, and then draw a block. It would recursively call itself again, drawing a block at the next closest point, until it had reached the end point. Please note that I did not put in object avoidance into this method as it was beyond the scope of the problem. With the recursive method complete, it became clear a while loop would be just as clear with minimal code changes and be more performant since tail recursion is not supported by Python.\n","permalink":"http://localhost:1313/posts/second/","summary":"\u003ch1 id=\"generative-design-in-minecraft-gdmc\"\u003eGenerative Design in Minecraft (GDMC)\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eGDMC\u003c/a\u003e is a competition to generate settlements within a selection of a minecraft map. The \u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eproject\u0026rsquo;s website\u003c/a\u003e provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\u003c/p\u003e","title":"Generative Design in Mineraft: MCEdit Basics"},{"content":"This is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, Swig’s website for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on Swig\u0026rsquo;s website and a StackOverflow question for Python 3. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\n1. Install # python-dev sudo apt-get install python-dev # python2.x sudo apt-get install python3-dev # python3.x # swig sudo apt-get install swig 2. Source c++ Fibonacci implementation, filename: fib.cpp\n#include \u0026#34;fib.h\u0026#34; int fibonacci(int n) { if(n \u0026lt;= 1) return n; return fibonacci(n-1) + fibonacci(n-2); } c++ fibonacci header file, filename: fib.h. I\u0026rsquo;m going to explain why this file exists in a moment.\nint fibonacci(int n); The next file is the interface file for swig, fib.i. This is telling swig what bindings it will need to create and is why we implemented fib.h.\n%module Fibonacci %{ #include \u0026#34;fib.h\u0026#34; %} %include \u0026#34;fib.h\u0026#34; The alternative to creating the fib.h file is directly below. For this we define each function individually for swig to then bind.\n%module Fibonacci %{ int fibonacci(int n); %} int fibonacci(int n); 3. Build setup.py, this file is taken directly from Swig\u0026rsquo;s documentation and modified slightly.\n#!/usr/bin/env python from distutils.core import setup, Extension fib_module = Extension( \u0026#39;_Fibonacci\u0026#39;, sources=[\u0026#39;fib_wrap.cxx\u0026#39;, \u0026#39;fib.cpp\u0026#39;], # fib_wrap.cxx is going to be generated by swig ) setup ( name = \u0026#39;Fibonacci\u0026#39;, version = \u0026#39;0.0\u0026#39;, author = \u0026#34;YOUR_NAME\u0026#34;, description = \u0026#34;Fibonacci swig\u0026#34;, ext_modules = [fib_module], py_modules = [\u0026#34;Fibonacci\u0026#34;], # name of module that we\u0026#39;re going import ) build.sh or whatever you fancy.\n#!/bin/bash swig -c++ -python fib.i python setup.py build_ext --inplace 4. Run Assign permissions (e.g. chmod 755 build.sh) and run ./build.sh. From there you can go into the python console and test by running the following:\n$ python \u0026gt;\u0026gt;\u0026gt; import Fibonacci \u0026gt;\u0026gt;\u0026gt; Fibonacci.fibonacci(10) 55 5. Conclusion Please let me know if anything here can be improved so I can update this for future readers. Regardless, I hope this helped some of you with your projects/work and saved you some time.\n","permalink":"http://localhost:1313/posts/first/","summary":"\u003cp\u003eThis is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig’s website\u003c/a\u003e for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig\u0026rsquo;s website\u003c/a\u003e and a \u003ca href=\"https://stackoverflow.com/questions/32667888/building-extension-for-python-3-with-swig-and-distutils\"\u003eStackOverflow question for Python 3\u003c/a\u003e. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\u003c/p\u003e","title":"C++ to Python Bindings with Swig"},{"content":"Biemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). Paper\nBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). Paper\nBiemer, C., \u0026amp; Cooper, S. (2022, October). Level Assembly as a Markov Decision Process. In 2022 Proceedings of the Experimental AI in Games Workshop. Paper, Talk, Code\nBiemer, C., \u0026amp; Cooper, S. (2022, August). On Linking Level Segments. In 2022 IEEE Conference on Games (CoG) (pp. 199-205). ★ Best Paper Nominee Paper, Talk, Code\nBiemer, C., Hervella, A., \u0026amp; Cooper, S. (2021, August). Gram-Elites: N-Gram Based Quality-Diversity Search. In The 16th International Conference on the Foundations of Digital Games (FDG) 2021 (pp. 1-6). Paper, Talk, Code\nVillareale, J., Biemer, C., Seif El-Nasr, M., \u0026amp; Zhu, J. (2020, September). Reflection in Game-Based Learning: A Survey of Programming Games. In International Conference on the Foundations of Digital Games (pp. 1-9). Paper\n","permalink":"http://localhost:1313/publications/","summary":"\u003cp\u003eBiemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). \u003cbr\u003e\n\u003ca href=\"/pdf/2024_solution_path_heuristics.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). \u003cbr\u003e\n\u003ca href=\"/pdf/2023_ddaviaplgviamdp.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e","title":"Publications"},{"content":"Introduction Hello, world! I\u0026rsquo;m here again :D\n","permalink":"http://localhost:1313/games/second/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eHello, world! I\u0026rsquo;m here again :D\u003c/p\u003e","title":"Second"},{"content":"Generative Design in Minecraft (GDMC) GDMC is a competition to generate settlements within a selection of a minecraft map. The project\u0026rsquo;s website provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\nMCEdit To generate settlements, the competition has gone the route of using MCEdit to allow competitors to view, generate, and modify minecraft maps. GDMC provides a wiki with easy to use instructions for installing and general set up. The wiki also provides an example cellular automata script for generating structures seen in figure one. As you can see, the output isn’t great, but it provides a nice starting point. It, also, shows how to work with the MCEdit filters which is how we can interact with the maps.\nFigure 1: Example cellular automata output from CASG_Example.py Filters A filter is how we are able to modify maps. To activate a filter, a user makes a selection on the map via a left click and dragging your mouse. From there, on the bottom of the screen, there is a potion looking icon that when pressed will open the filter menu. This provides a drop down menu of available filters. Each of these filters provides a set of options and the ability to perform their respective actions. When activated they will make modifications to the map given the users selection area. Each of the filters are Python 2.7 scripts located in the stock-filters directory.\nFilter Basics The wiki provides some helpful commentary in getting started with filters, but the script is a bit too complicated for a starting point. There are, however, two things that every filter has in common: the perform function and inputs tuple.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def perform(level, box, options): pass When a filter is activated, the engine will call the perform function and pass the level data (this data structure will be explored further in the next post), the bounding box, and the set of options a user has defined. The bounding box defines the origin of the box the user created and the size. The options is a dictionary based on the inputs defined in the above script. Therefore, to access the materials you could use options[“Material”] to be able to see what the user set.\nBox in all Eight Corners of Selection Now that we understand the basics, we can start with a simple filter. The goal of this filter is to place a user defined material in all eight corners of the user’s selection. The end result can be seen in figure two. The first step here is to define the inputs for the user. In this case, the above inputs code is exactly what we need.\nFigure 2: Example of placing blocks at all eight corners of user\u0026#39;s selection space Now we need to know how to draw a block and this can be found in the utility functions provided by NYU. I haven’t figured out the point of the function setBlockDataAt yet, but in the second post I intend to investigate more to figure it out. In the meantime, I wrote a simpler function because the data was always set to 0 in the examples I could find.\ndef draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) With that complete, the only problem now is figuring out how to use the bounding box to find the eight corners. As noted above, the way the bounding box works is by providing an origin and size vector. All variations of adding these two together will provide eight values which are, coincidentally, the corners of the cube. The full filter can be seen below.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) def perform(level, box, options): material = options[\u0026#34;Material\u0026#34;] draw_block(level, box.origin.x, box.origin.y, box.origin.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y, box.origin.z, material) draw_block(level, box.origin.x, box.origin.y + box.size.y, box.origin.z, material) draw_block(level, box.origin.x, box.origin.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x, box.origin.y + box.size.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z + box.size.z, material) Fill Selection In comparison to the eight boxes, this is a lot easier conceptually. All we want to do is fill the entire users selection with a material. The end result can be seen in figure three.\nFigure 3: Two examples of filling in users selection with a different materials The setup is exactly the same as last time where you can use the inputs to define the material. We can even use the draw_block function. At this point, it is probably best to create a script that contains common functions that could be useful in the future. From there, we need to create a function fill_box which takes in the level, origin, size, and material. To fill the box, it is as simple as three for loops that go through all possible x, y, and z values. It is important that you loop from the minimum to the maximum of these, else there is a chance you will not completely fill in the box.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace All\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) def fill_box(level, origin, size, material): final_x = origin.x + size.x final_y = origin.y + size.y final_z = origin.z + size.z for x in range(min(origin.x, final_x), max(origin.x, final_x)): for y in range(min(origin.y, final_y), max(origin.y, final_y)): for z in range(min(origin.z, final_z), max(origin.z, final_z)): draw_block(level, x, y, z, material) def perform(level, box, options): fill_box(level, box.origin, box.size, options[\u0026#34;Material\u0026#34;]) Box Outline In this case we want to take the user’s selection and draw blocks along the edges, an example can be seen in figure four. The complexity for this problem is creating a function that will properly draw lines. Specifically, it is necessary to make sure it can draw diagonal lines for the sake of completeness.\nFigure 4: Example of drawing the edges for a user\u0026#39;s selection The main difficulty in this problem is making sure every direction a line can move is accounted for. The list is quite long but mainly requires some attentiveness on our our part when defining all the possibilities.\ndirections = [ (1,0,0),(-1,0,0),(0,1,0),(0,-1,0),(0,0,1),(0,0,-1),\\ (1,1,0),(-1,1,0),(1,-1,0),(-1,-1,0),(0,1,1),(0,-1,1),\\ (0,1,-1),(0,-1,-1),(1,0,1),(-1,0,1),(1,0,-1),(-1,0,-1),\\ (1,1,1),(-1,1,1),(1,-1,1),(1,1,-1),(-1,-1,1),(-1,1,-1),\\ (1,-1,-1),(-1,-1,-1) ] We now have the task of using the directions array to draw the line along the shortest path from the starting point to the end point. I first wrote this with a recursive method, where it would find the point closest, with the manhattan distance, and then draw a block. It would recursively call itself again, drawing a block at the next closest point, until it had reached the end point. Please note that I did not put in object avoidance into this method as it was beyond the scope of the problem. With the recursive method complete, it became clear a while loop would be just as clear with minimal code changes and be more performant since tail recursion is not supported by Python.\nOnce drawing a line was completed, the last step was to use the vertices I defined in the section dedicated to drawing materials in all eight corners to draw the edges as well. The code for the filter is below.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from pymclevel.box import Vector from mcplatform import * inputs = ( (\u0026#34;Replace All\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def vector_equals(v1, v2): return v1.x == v2.x and v1.y == v2.y and v1.z == v2.z def manhattan_distance(start, end): return abs(end.x - start.x) + abs(end.y - start.y) + abs(end.z - start.z) def draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) def draw_block(level, point, material): level.setBlockAt(point.x, point.y, point.z, material.ID) level.setBlockDataAt(point.x, point.y, point.z, 0) def fill_box(level, origin, size, material): final_x = origin.x + size.x final_y = origin.y + size.y final_z = origin.z + size.z for x in range(min(origin.x, final_x), max(origin.x, final_x)): for y in range(min(origin.y, final_y), max(origin.y, final_y)): for z in range(min(origin.z, final_z), max(origin.z, final_z)): draw_block(level, x, y, z, material) def draw_line(level, start, end, material): directions = [(1,0,0),(-1,0,0),(0,1,0),(0,-1,0),(0,0,1),(0,0,-1),\\ (1,1,0),(-1,1,0),(1,-1,0),(-1,-1,0),(0,1,1),(0,-1,1),\\ (0,1,-1),(0,-1,-1),(1,0,1),(-1,0,1),(1,0,-1),(-1,0,-1),\\ (1,1,1),(-1,1,1),(1,-1,1),(1,1,-1),(-1,-1,1),(-1,1,-1),\\ (1,-1,-1),(-1,-1,-1)] draw_block(level, start, material) while not vector_equals(start, end): new_s = start + directions[0] dist = manhattan_distance(start, end) for i in range(1, len(directions)): s = start + directions[i] d = manhattan_distance(s, end) if d \u0026lt; dist: new_s = s dist = d start = new_s draw_block(level, start, material) def draw_box_outline(level, box, material): point_1 = box.origin point_2 = Vector(box.origin.x + box.size.x, box.origin.y, box.origin.z) point_3 = Vector(box.origin.x, box.origin.y + box.size.y, box.origin.z) point_4 = Vector(box.origin.x, box.origin.y, box.origin.z + box.size.z) point_5 = Vector(box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z) point_6 = Vector(box.origin.x + box.size.x, box.origin.y, box.origin.z + box.size.z) point_7 = Vector(box.origin.x, box.origin.y + box.size.y, box.origin.z + box.size.z,) point_8 = Vector(box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z + box.size.z) draw_line(level, point_1, point_2, material) draw_line(level, point_1, point_3, material) draw_line(level, point_1, point_4, material) draw_line(level, point_2, point_6, material) draw_line(level, point_4, point_6, material) draw_line(level, point_3, point_7, material) draw_line(level, point_4, point_7, material) draw_line(level, point_7, point_8, material) draw_line(level, point_6, point_8, material) draw_line(level, point_8, point_5, material) draw_line(level, point_5, point_2, material) draw_line(level, point_5, point_3, material) def perform(level, box, options): draw_box_outline(level, box, options[\u0026#34;Material\u0026#34;]) ","permalink":"http://localhost:1313/posts/second/","summary":"\u003ch1 id=\"generative-design-in-minecraft-gdmc\"\u003eGenerative Design in Minecraft (GDMC)\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eGDMC\u003c/a\u003e is a competition to generate settlements within a selection of a minecraft map. The \u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eproject\u0026rsquo;s website\u003c/a\u003e provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\u003c/p\u003e","title":"Generative Design in Mineraft: MCEdit Basics"},{"content":"This is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, Swig’s website for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on Swig\u0026rsquo;s website and a StackOverflow question for Python 3. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\n1. Install # python-dev sudo apt-get install python-dev # python2.x sudo apt-get install python3-dev # python3.x # swig sudo apt-get install swig 2. Source c++ Fibonacci implementation, filename: fib.cpp\n#include \u0026#34;fib.h\u0026#34; int fibonacci(int n) { if(n \u0026lt;= 1) return n; return fibonacci(n-1) + fibonacci(n-2); } c++ fibonacci header file, filename: fib.h. I\u0026rsquo;m going to explain why this file exists in a moment.\nint fibonacci(int n); The next file is the interface file for swig, fib.i. This is telling swig what bindings it will need to create and is why we implemented fib.h.\n%module Fibonacci %{ #include \u0026#34;fib.h\u0026#34; %} %include \u0026#34;fib.h\u0026#34; The alternative to creating the fib.h file is directly below. For this we define each function individually for swig to then bind.\n%module Fibonacci %{ int fibonacci(int n); %} int fibonacci(int n); 3. Build setup.py, this file is taken directly from Swig\u0026rsquo;s documentation and modified slightly.\n#!/usr/bin/env python from distutils.core import setup, Extension fib_module = Extension( \u0026#39;_Fibonacci\u0026#39;, sources=[\u0026#39;fib_wrap.cxx\u0026#39;, \u0026#39;fib.cpp\u0026#39;], # fib_wrap.cxx is going to be generated by swig ) setup ( name = \u0026#39;Fibonacci\u0026#39;, version = \u0026#39;0.0\u0026#39;, author = \u0026#34;YOUR_NAME\u0026#34;, description = \u0026#34;Fibonacci swig\u0026#34;, ext_modules = [fib_module], py_modules = [\u0026#34;Fibonacci\u0026#34;], # name of module that we\u0026#39;re going import ) build.sh or whatever you fancy.\n#!/bin/bash swig -c++ -python fib.i python setup.py build_ext --inplace 4. Run Assign permissions (e.g. chmod 755 build.sh) and run ./build.sh. From there you can go into the python console and test by running the following:\n$ python \u0026gt;\u0026gt;\u0026gt; import Fibonacci \u0026gt;\u0026gt;\u0026gt; Fibonacci.fibonacci(10) 55 5. Conclusion Please let me know if anything here can be improved so I can update this for future readers. Regardless, I hope this helped some of you with your projects/work and saved you some time.\n","permalink":"http://localhost:1313/posts/first/","summary":"\u003cp\u003eThis is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig’s website\u003c/a\u003e for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig\u0026rsquo;s website\u003c/a\u003e and a \u003ca href=\"https://stackoverflow.com/questions/32667888/building-extension-for-python-3-with-swig-and-distutils\"\u003eStackOverflow question for Python 3\u003c/a\u003e. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\u003c/p\u003e","title":"C++ to Python Bindings with Swig"},{"content":"Biemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). Paper\nBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). Paper\nBiemer, C., \u0026amp; Cooper, S. (2022, October). Level Assembly as a Markov Decision Process. In 2022 Proceedings of the Experimental AI in Games Workshop. Paper, Talk, Code\nBiemer, C., \u0026amp; Cooper, S. (2022, August). On Linking Level Segments. In 2022 IEEE Conference on Games (CoG) (pp. 199-205). ★ Best Paper Nominee Paper, Talk, Code\nBiemer, C., Hervella, A., \u0026amp; Cooper, S. (2021, August). Gram-Elites: N-Gram Based Quality-Diversity Search. In The 16th International Conference on the Foundations of Digital Games (FDG) 2021 (pp. 1-6). Paper, Talk, Code\nVillareale, J., Biemer, C., Seif El-Nasr, M., \u0026amp; Zhu, J. (2020, September). Reflection in Game-Based Learning: A Survey of Programming Games. In International Conference on the Foundations of Digital Games (pp. 1-9). Paper\n","permalink":"http://localhost:1313/publications/","summary":"\u003cp\u003eBiemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). \u003cbr\u003e\n\u003ca href=\"/pdf/2024_solution_path_heuristics.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). \u003cbr\u003e\n\u003ca href=\"/pdf/2023_ddaviaplgviamdp.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e","title":"Publications"},{"content":"Introduction Hello, world! I\u0026rsquo;m here again :D\n","permalink":"http://localhost:1313/games/second/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eHello, world! I\u0026rsquo;m here again :D\u003c/p\u003e","title":"Second"},{"content":"Generative Design in Minecraft (GDMC) GDMC is a competition to generate settlements within a selection of a minecraft map. The project\u0026rsquo;s website provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\nMCEdit To generate settlements, the competition has gone the route of using MCEdit to allow competitors to view, generate, and modify minecraft maps. GDMC provides a wiki with easy to use instructions for installing and general set up. The wiki also provides an example cellular automata script for generating structures seen in figure one. As you can see, the output isn’t great, but it provides a nice starting point. It, also, shows how to work with the MCEdit filters which is how we can interact with the maps.\nFigure 1: Example cellular automata output from CASG_Example.py Filters A filter is how we are able to modify maps. To activate a filter, a user makes a selection on the map via a left click and dragging your mouse. From there, on the bottom of the screen, there is a potion looking icon that when pressed will open the filter menu. This provides a drop down menu of available filters. Each of these filters provides a set of options and the ability to perform their respective actions. When activated they will make modifications to the map given the users selection area. Each of the filters are Python 2.7 scripts located in the stock-filters directory.\nFilter Basics The wiki provides some helpful commentary in getting started with filters, but the script is a bit too complicated for a starting point. There are, however, two things that every filter has in common: the perform function and inputs tuple.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def perform(level, box, options): pass When a filter is activated, the engine will call the perform function and pass the level data (this data structure will be explored further in the next post), the bounding box, and the set of options a user has defined. The bounding box defines the origin of the box the user created and the size. The options is a dictionary based on the inputs defined in the above script. Therefore, to access the materials you could use options[“Material”] to be able to see what the user set.\nBox in all Eight Corners of Selection Now that we understand the basics, we can start with a simple filter. The goal of this filter is to place a user defined material in all eight corners of the user’s selection. The end result can be seen in figure two. The first step here is to define the inputs for the user. In this case, the above inputs code is exactly what we need.\nFigure 2: Example of placing blocks at all eight corners of user\u0026#39;s selection space Now we need to know how to draw a block and this can be found in the utility functions provided by NYU. I haven’t figured out the point of the function setBlockDataAt yet, but in the second post I intend to investigate more to figure it out. In the meantime, I wrote a simpler function because the data was always set to 0 in the examples I could find.\ndef draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) With that complete, the only problem now is figuring out how to use the bounding box to find the eight corners. As noted above, the way the bounding box works is by providing an origin and size vector. All variations of adding these two together will provide eight values which are, coincidentally, the corners of the cube. The full filter can be seen below.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) def perform(level, box, options): material = options[\u0026#34;Material\u0026#34;] draw_block(level, box.origin.x, box.origin.y, box.origin.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y, box.origin.z, material) draw_block(level, box.origin.x, box.origin.y + box.size.y, box.origin.z, material) draw_block(level, box.origin.x, box.origin.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x, box.origin.y + box.size.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z + box.size.z, material) Fill Selection In comparison to the eight boxes, this is a lot easier conceptually. All we want to do is fill the entire users selection with a material. The end result can be seen in figure three.\nFigure 3: Two examples of filling in users selection with a different materials The setup is exactly the same as last time where you can use the inputs to define the material. We can even use the draw_block function. At this point, it is probably best to create a script that contains common functions that could be useful in the future. From there, we need to create a function fill_box which takes in the level, origin, size, and material. To fill the box, it is as simple as three for loops that go through all possible x, y, and z values. It is important that you loop from the minimum to the maximum of these, else there is a chance you will not completely fill in the box.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace All\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) def fill_box(level, origin, size, material): final_x = origin.x + size.x final_y = origin.y + size.y final_z = origin.z + size.z for x in range(min(origin.x, final_x), max(origin.x, final_x)): for y in range(min(origin.y, final_y), max(origin.y, final_y)): for z in range(min(origin.z, final_z), max(origin.z, final_z)): draw_block(level, x, y, z, material) def perform(level, box, options): fill_box(level, box.origin, box.size, options[\u0026#34;Material\u0026#34;]) Box Outline In this case we want to take the user’s selection and draw blocks along the edges, an example can be seen in figure four. The complexity for this problem is creating a function that will properly draw lines. Specifically, it is necessary to make sure it can draw diagonal lines for the sake of completeness.\nFigure 4: Example of drawing the edges for a user\u0026#39;s selection The main difficulty in this problem is making sure every direction a line can move is accounted for. The list is quite long but mainly requires some attentiveness on our our part when defining all the possibilities.\ndirections = [ (1,0,0),(-1,0,0),(0,1,0),(0,-1,0),(0,0,1),(0,0,-1),\\ (1,1,0),(-1,1,0),(1,-1,0),(-1,-1,0),(0,1,1),(0,-1,1),\\ (0,1,-1),(0,-1,-1),(1,0,1),(-1,0,1),(1,0,-1),(-1,0,-1),\\ (1,1,1),(-1,1,1),(1,-1,1),(1,1,-1),(-1,-1,1),(-1,1,-1),\\ (1,-1,-1),(-1,-1,-1) ] We now have the task of using the directions array to draw the line along the shortest path from the starting point to the end point. I first wrote this with a recursive method, where it would find the point closest, with the manhattan distance, and then draw a block. It would recursively call itself again, drawing a block at the next closest point, until it had reached the end point. Please note that I did not put in object avoidance into this method as it was beyond the scope of the problem. With the recursive method complete, it became clear a while loop would be just as clear with minimal code changes and be more performant since tail recursion is not supported by Python.\nOnce drawing a line was completed, the last step was to use the vertices I defined in the section dedicated to drawing materials in all eight corners to draw the edges as well. The code for the filter is below.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from pymclevel.box import Vector from mcplatform import * inputs = ( (\u0026#34;Replace All\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def vector_equals(v1, v2): return v1.x == v2.x and v1.y == v2.y and v1.z == v2.z def manhattan_distance(start, end): return abs(end.x - start.x) + abs(end.y - start.y) + abs(end.z - start.z) def draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) def draw_block(level, point, material): level.setBlockAt(point.x, point.y, point.z, material.ID) level.setBlockDataAt(point.x, point.y, point.z, 0) def fill_box(level, origin, size, material): final_x = origin.x + size.x final_y = origin.y + size.y final_z = origin.z + size.z for x in range(min(origin.x, final_x), max(origin.x, final_x)): for y in range(min(origin.y, final_y), max(origin.y, final_y)): for z in range(min(origin.z, final_z), max(origin.z, final_z)): draw_block(level, x, y, z, material) def draw_line(level, start, end, material): directions = [(1,0,0),(-1,0,0),(0,1,0),(0,-1,0),(0,0,1),(0,0,-1),\\ (1,1,0),(-1,1,0),(1,-1,0),(-1,-1,0),(0,1,1),(0,-1,1),\\ (0,1,-1),(0,-1,-1),(1,0,1),(-1,0,1),(1,0,-1),(-1,0,-1),\\ (1,1,1),(-1,1,1),(1,-1,1),(1,1,-1),(-1,-1,1),(-1,1,-1),\\ (1,-1,-1),(-1,-1,-1)] draw_block(level, start, material) while not vector_equals(start, end): new_s = start + directions[0] dist = manhattan_distance(start, end) for i in range(1, len(directions)): s = start + directions[i] d = manhattan_distance(s, end) if d \u0026lt; dist: new_s = s dist = d start = new_s draw_block(level, start, material) def draw_box_outline(level, box, material): point_1 = box.origin point_2 = Vector(box.origin.x + box.size.x, box.origin.y, box.origin.z) point_3 = Vector(box.origin.x, box.origin.y + box.size.y, box.origin.z) point_4 = Vector(box.origin.x, box.origin.y, box.origin.z + box.size.z) point_5 = Vector(box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z) point_6 = Vector(box.origin.x + box.size.x, box.origin.y, box.origin.z + box.size.z) point_7 = Vector(box.origin.x, box.origin.y + box.size.y, box.origin.z + box.size.z,) point_8 = Vector(box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z + box.size.z) draw_line(level, point_1, point_2, material) draw_line(level, point_1, point_3, material) draw_line(level, point_1, point_4, material) draw_line(level, point_2, point_6, material) draw_line(level, point_4, point_6, material) draw_line(level, point_3, point_7, material) draw_line(level, point_4, point_7, material) draw_line(level, point_7, point_8, material) draw_line(level, point_6, point_8, material) draw_line(level, point_8, point_5, material) draw_line(level, point_5, point_2, material) draw_line(level, point_5, point_3, material) def perform(level, box, options): draw_box_outline(level, box, options[\u0026#34;Material\u0026#34;]) ","permalink":"http://localhost:1313/posts/second/","summary":"\u003ch1 id=\"generative-design-in-minecraft-gdmc\"\u003eGenerative Design in Minecraft (GDMC)\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eGDMC\u003c/a\u003e is a competition to generate settlements within a selection of a minecraft map. The \u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eproject\u0026rsquo;s website\u003c/a\u003e provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\u003c/p\u003e","title":"Generative Design in Mineraft: MCEdit Basics"},{"content":"This is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, Swig’s website for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on Swig\u0026rsquo;s website and a StackOverflow question for Python 3. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\n1. Install # python-dev sudo apt-get install python-dev # python2.x sudo apt-get install python3-dev # python3.x # swig sudo apt-get install swig 2. Source c++ Fibonacci implementation, filename: fib.cpp\n#include \u0026#34;fib.h\u0026#34; int fibonacci(int n) { if(n \u0026lt;= 1) return n; return fibonacci(n-1) + fibonacci(n-2); } c++ fibonacci header file, filename: fib.h. I\u0026rsquo;m going to explain why this file exists in a moment.\nint fibonacci(int n); The next file is the interface file for swig, fib.i. This is telling swig what bindings it will need to create and is why we implemented fib.h.\n%module Fibonacci %{ #include \u0026#34;fib.h\u0026#34; %} %include \u0026#34;fib.h\u0026#34; The alternative to creating the fib.h file is directly below. For this we define each function individually for swig to then bind.\n%module Fibonacci %{ int fibonacci(int n); %} int fibonacci(int n); 3. Build setup.py, this file is taken directly from Swig\u0026rsquo;s documentation and modified slightly.\n#!/usr/bin/env python from distutils.core import setup, Extension fib_module = Extension( \u0026#39;_Fibonacci\u0026#39;, sources=[\u0026#39;fib_wrap.cxx\u0026#39;, \u0026#39;fib.cpp\u0026#39;], # fib_wrap.cxx is going to be generated by swig ) setup ( name = \u0026#39;Fibonacci\u0026#39;, version = \u0026#39;0.0\u0026#39;, author = \u0026#34;YOUR_NAME\u0026#34;, description = \u0026#34;Fibonacci swig\u0026#34;, ext_modules = [fib_module], py_modules = [\u0026#34;Fibonacci\u0026#34;], # name of module that we\u0026#39;re going import ) build.sh or whatever you fancy.\n#!/bin/bash swig -c++ -python fib.i python setup.py build_ext --inplace 4. Run Assign permissions (e.g. chmod 755 build.sh) and run ./build.sh. From there you can go into the python console and test by running the following:\n$ python \u0026gt;\u0026gt;\u0026gt; import Fibonacci \u0026gt;\u0026gt;\u0026gt; Fibonacci.fibonacci(10) 55 5. Conclusion Please let me know if anything here can be improved so I can update this for future readers. Regardless, I hope this helped some of you with your projects/work and saved you some time.\n","permalink":"http://localhost:1313/posts/first/","summary":"\u003cp\u003eThis is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig’s website\u003c/a\u003e for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig\u0026rsquo;s website\u003c/a\u003e and a \u003ca href=\"https://stackoverflow.com/questions/32667888/building-extension-for-python-3-with-swig-and-distutils\"\u003eStackOverflow question for Python 3\u003c/a\u003e. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\u003c/p\u003e","title":"C++ to Python Bindings with Swig"},{"content":"Biemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). Paper\nBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). Paper\nBiemer, C., \u0026amp; Cooper, S. (2022, October). Level Assembly as a Markov Decision Process. In 2022 Proceedings of the Experimental AI in Games Workshop. Paper, Talk, Code\nBiemer, C., \u0026amp; Cooper, S. (2022, August). On Linking Level Segments. In 2022 IEEE Conference on Games (CoG) (pp. 199-205). ★ Best Paper Nominee Paper, Talk, Code\nBiemer, C., Hervella, A., \u0026amp; Cooper, S. (2021, August). Gram-Elites: N-Gram Based Quality-Diversity Search. In The 16th International Conference on the Foundations of Digital Games (FDG) 2021 (pp. 1-6). Paper, Talk, Code\nVillareale, J., Biemer, C., Seif El-Nasr, M., \u0026amp; Zhu, J. (2020, September). Reflection in Game-Based Learning: A Survey of Programming Games. In International Conference on the Foundations of Digital Games (pp. 1-9). Paper\n","permalink":"http://localhost:1313/publications/","summary":"\u003cp\u003eBiemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). \u003cbr\u003e\n\u003ca href=\"/pdf/2024_solution_path_heuristics.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). \u003cbr\u003e\n\u003ca href=\"/pdf/2023_ddaviaplgviamdp.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e","title":"Publications"},{"content":"Introduction Hello, world! I\u0026rsquo;m here again :D\n","permalink":"http://localhost:1313/games/second/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eHello, world! I\u0026rsquo;m here again :D\u003c/p\u003e","title":"Second"},{"content":"Generative Design in Minecraft (GDMC) GDMC is a competition to generate settlements within a selection of a minecraft map. The project\u0026rsquo;s website provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\nMCEdit To generate settlements, the competition has gone the route of using MCEdit to allow competitors to view, generate, and modify minecraft maps. GDMC provides a wiki with easy to use instructions for installing and general set up. The wiki also provides an example cellular automata script for generating structures seen in figure one. As you can see, the output isn’t great, but it provides a nice starting point. It, also, shows how to work with the MCEdit filters which is how we can interact with the maps.\nFigure 1: Example cellular automata output from CASG_Example.py Filters A filter is how we are able to modify maps. To activate a filter, a user makes a selection on the map via a left click and dragging your mouse. From there, on the bottom of the screen, there is a potion looking icon that when pressed will open the filter menu. This provides a drop down menu of available filters. Each of these filters provides a set of options and the ability to perform their respective actions. When activated they will make modifications to the map given the users selection area. Each of the filters are Python 2.7 scripts located in the stock-filters directory.\nFilter Basics The wiki provides some helpful commentary in getting started with filters, but the script is a bit too complicated for a starting point. There are, however, two things that every filter has in common: the perform function and inputs tuple.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def perform(level, box, options): pass When a filter is activated, the engine will call the perform function and pass the level data (this data structure will be explored further in the next post), the bounding box, and the set of options a user has defined. The bounding box defines the origin of the box the user created and the size. The options is a dictionary based on the inputs defined in the above script. Therefore, to access the materials you could use options[“Material”] to be able to see what the user set.\nBox in all Eight Corners of Selection Now that we understand the basics, we can start with a simple filter. The goal of this filter is to place a user defined material in all eight corners of the user’s selection. The end result can be seen in figure two. The first step here is to define the inputs for the user. In this case, the above inputs code is exactly what we need.\nFigure 2: Example of placing blocks at all eight corners of user\u0026#39;s selection space Now we need to know how to draw a block and this can be found in the utility functions provided by NYU. I haven’t figured out the point of the function setBlockDataAt yet, but in the second post I intend to investigate more to figure it out. In the meantime, I wrote a simpler function because the data was always set to 0 in the examples I could find.\ndef draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) With that complete, the only problem now is figuring out how to use the bounding box to find the eight corners. As noted above, the way the bounding box works is by providing an origin and size vector. All variations of adding these two together will provide eight values which are, coincidentally, the corners of the cube. The full filter can be seen below.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) def perform(level, box, options): material = options[\u0026#34;Material\u0026#34;] draw_block(level, box.origin.x, box.origin.y, box.origin.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y, box.origin.z, material) draw_block(level, box.origin.x, box.origin.y + box.size.y, box.origin.z, material) draw_block(level, box.origin.x, box.origin.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x, box.origin.y + box.size.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z + box.size.z, material) Fill Selection In comparison to the eight boxes, this is a lot easier conceptually. All we want to do is fill the entire users selection with a material. The end result can be seen in figure three.\nFigure 3: Two examples of filling in users selection with a different materials The setup is exactly the same as last time where you can use the inputs to define the material. We can even use the draw_block function. At this point, it is probably best to create a script that contains common functions that could be useful in the future. From there, we need to create a function fill_box which takes in the level, origin, size, and material. To fill the box, it is as simple as three for loops that go through all possible x, y, and z values. It is important that you loop from the minimum to the maximum of these, else there is a chance you will not completely fill in the box.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace All\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) def fill_box(level, origin, size, material): final_x = origin.x + size.x final_y = origin.y + size.y final_z = origin.z + size.z for x in range(min(origin.x, final_x), max(origin.x, final_x)): for y in range(min(origin.y, final_y), max(origin.y, final_y)): for z in range(min(origin.z, final_z), max(origin.z, final_z)): draw_block(level, x, y, z, material) def perform(level, box, options): fill_box(level, box.origin, box.size, options[\u0026#34;Material\u0026#34;]) Box Outline In this case we want to take the user’s selection and draw blocks along the edges, an example can be seen in figure four. The complexity for this problem is creating a function that will properly draw lines. Specifically, it is necessary to make sure it can draw diagonal lines for the sake of completeness.\nFigure 4: Example of drawing the edges for a user\u0026#39;s selection The main difficulty in this problem is making sure every direction a line can move is accounted for. The list is quite long but mainly requires some attentiveness on our our part when defining all the possibilities.\ndirections = [ (1,0,0),(-1,0,0),(0,1,0),(0,-1,0),(0,0,1),(0,0,-1),\\ (1,1,0),(-1,1,0),(1,-1,0),(-1,-1,0),(0,1,1),(0,-1,1),\\ (0,1,-1),(0,-1,-1),(1,0,1),(-1,0,1),(1,0,-1),(-1,0,-1),\\ (1,1,1),(-1,1,1),(1,-1,1),(1,1,-1),(-1,-1,1),(-1,1,-1),\\ (1,-1,-1),(-1,-1,-1) ] We now have the task of using the directions array to draw the line along the shortest path from the starting point to the end point. I first wrote this with a recursive method, where it would find the point closest, with the manhattan distance, and then draw a block. It would recursively call itself again, drawing a block at the next closest point, until it had reached the end point. Please note that I did not put in object avoidance into this method as it was beyond the scope of the problem. With the recursive method complete, it became clear a while loop would be just as clear with minimal code changes and be more performant since tail recursion is not supported by Python.\nOnce drawing a line was completed, the last step was to use the vertices I defined in the section dedicated to drawing materials in all eight corners to draw the edges as well. The code for the filter is below.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from pymclevel.box import Vector from mcplatform import * inputs = ( (\u0026#34;Replace All\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def vector_equals(v1, v2): return v1.x == v2.x and v1.y == v2.y and v1.z == v2.z def manhattan_distance(start, end): return abs(end.x - start.x) + abs(end.y - start.y) + abs(end.z - start.z) def draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) def draw_block(level, point, material): level.setBlockAt(point.x, point.y, point.z, material.ID) level.setBlockDataAt(point.x, point.y, point.z, 0) def fill_box(level, origin, size, material): final_x = origin.x + size.x final_y = origin.y + size.y final_z = origin.z + size.z for x in range(min(origin.x, final_x), max(origin.x, final_x)): for y in range(min(origin.y, final_y), max(origin.y, final_y)): for z in range(min(origin.z, final_z), max(origin.z, final_z)): draw_block(level, x, y, z, material) def draw_line(level, start, end, material): directions = [(1,0,0),(-1,0,0),(0,1,0),(0,-1,0),(0,0,1),(0,0,-1),\\ (1,1,0),(-1,1,0),(1,-1,0),(-1,-1,0),(0,1,1),(0,-1,1),\\ (0,1,-1),(0,-1,-1),(1,0,1),(-1,0,1),(1,0,-1),(-1,0,-1),\\ (1,1,1),(-1,1,1),(1,-1,1),(1,1,-1),(-1,-1,1),(-1,1,-1),\\ (1,-1,-1),(-1,-1,-1)] draw_block(level, start, material) while not vector_equals(start, end): new_s = start + directions[0] dist = manhattan_distance(start, end) for i in range(1, len(directions)): s = start + directions[i] d = manhattan_distance(s, end) if d \u0026lt; dist: new_s = s dist = d start = new_s draw_block(level, start, material) def draw_box_outline(level, box, material): point_1 = box.origin point_2 = Vector(box.origin.x + box.size.x, box.origin.y, box.origin.z) point_3 = Vector(box.origin.x, box.origin.y + box.size.y, box.origin.z) point_4 = Vector(box.origin.x, box.origin.y, box.origin.z + box.size.z) point_5 = Vector(box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z) point_6 = Vector(box.origin.x + box.size.x, box.origin.y, box.origin.z + box.size.z) point_7 = Vector(box.origin.x, box.origin.y + box.size.y, box.origin.z + box.size.z,) point_8 = Vector(box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z + box.size.z) draw_line(level, point_1, point_2, material) draw_line(level, point_1, point_3, material) draw_line(level, point_1, point_4, material) draw_line(level, point_2, point_6, material) draw_line(level, point_4, point_6, material) draw_line(level, point_3, point_7, material) draw_line(level, point_4, point_7, material) draw_line(level, point_7, point_8, material) draw_line(level, point_6, point_8, material) draw_line(level, point_8, point_5, material) draw_line(level, point_5, point_2, material) draw_line(level, point_5, point_3, material) def perform(level, box, options): draw_box_outline(level, box, options[\u0026#34;Material\u0026#34;]) ","permalink":"http://localhost:1313/posts/second/","summary":"\u003ch1 id=\"generative-design-in-minecraft-gdmc\"\u003eGenerative Design in Minecraft (GDMC)\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eGDMC\u003c/a\u003e is a competition to generate settlements within a selection of a minecraft map. The \u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eproject\u0026rsquo;s website\u003c/a\u003e provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\u003c/p\u003e","title":"Generative Design in Mineraft: MCEdit Basics"},{"content":"This is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, Swig’s website for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on Swig\u0026rsquo;s website and a StackOverflow question for Python 3. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\n1. Install # python-dev sudo apt-get install python-dev # python2.x sudo apt-get install python3-dev # python3.x # swig sudo apt-get install swig 2. Source c++ Fibonacci implementation, filename: fib.cpp\n#include \u0026#34;fib.h\u0026#34; int fibonacci(int n) { if(n \u0026lt;= 1) return n; return fibonacci(n-1) + fibonacci(n-2); } c++ fibonacci header file, filename: fib.h. I\u0026rsquo;m going to explain why this file exists in a moment.\nint fibonacci(int n); The next file is the interface file for swig, fib.i. This is telling swig what bindings it will need to create and is why we implemented fib.h.\n%module Fibonacci %{ #include \u0026#34;fib.h\u0026#34; %} %include \u0026#34;fib.h\u0026#34; The alternative to creating the fib.h file is directly below. For this we define each function individually for swig to then bind.\n%module Fibonacci %{ int fibonacci(int n); %} int fibonacci(int n); 3. Build setup.py, this file is taken directly from Swig\u0026rsquo;s documentation and modified slightly.\n#!/usr/bin/env python from distutils.core import setup, Extension fib_module = Extension( \u0026#39;_Fibonacci\u0026#39;, sources=[\u0026#39;fib_wrap.cxx\u0026#39;, \u0026#39;fib.cpp\u0026#39;], # fib_wrap.cxx is going to be generated by swig ) setup ( name = \u0026#39;Fibonacci\u0026#39;, version = \u0026#39;0.0\u0026#39;, author = \u0026#34;YOUR_NAME\u0026#34;, description = \u0026#34;Fibonacci swig\u0026#34;, ext_modules = [fib_module], py_modules = [\u0026#34;Fibonacci\u0026#34;], # name of module that we\u0026#39;re going import ) build.sh or whatever you fancy.\n#!/bin/bash swig -c++ -python fib.i python setup.py build_ext --inplace 4. Run Assign permissions (e.g. chmod 755 build.sh) and run ./build.sh. From there you can go into the python console and test by running the following:\n$ python \u0026gt;\u0026gt;\u0026gt; import Fibonacci \u0026gt;\u0026gt;\u0026gt; Fibonacci.fibonacci(10) 55 5. Conclusion Please let me know if anything here can be improved so I can update this for future readers. Regardless, I hope this helped some of you with your projects/work and saved you some time.\n","permalink":"http://localhost:1313/posts/first/","summary":"\u003cp\u003eThis is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig’s website\u003c/a\u003e for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig\u0026rsquo;s website\u003c/a\u003e and a \u003ca href=\"https://stackoverflow.com/questions/32667888/building-extension-for-python-3-with-swig-and-distutils\"\u003eStackOverflow question for Python 3\u003c/a\u003e. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\u003c/p\u003e","title":"C++ to Python Bindings with Swig"},{"content":"Biemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). Paper\nBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). Paper\nBiemer, C., \u0026amp; Cooper, S. (2022, October). Level Assembly as a Markov Decision Process. In 2022 Proceedings of the Experimental AI in Games Workshop. Paper, Talk, Code\nBiemer, C., \u0026amp; Cooper, S. (2022, August). On Linking Level Segments. In 2022 IEEE Conference on Games (CoG) (pp. 199-205). ★ Best Paper Nominee Paper, Talk, Code\nBiemer, C., Hervella, A., \u0026amp; Cooper, S. (2021, August). Gram-Elites: N-Gram Based Quality-Diversity Search. In The 16th International Conference on the Foundations of Digital Games (FDG) 2021 (pp. 1-6). Paper, Talk, Code\nVillareale, J., Biemer, C., Seif El-Nasr, M., \u0026amp; Zhu, J. (2020, September). Reflection in Game-Based Learning: A Survey of Programming Games. In International Conference on the Foundations of Digital Games (pp. 1-9). Paper\n","permalink":"http://localhost:1313/publications/","summary":"\u003cp\u003eBiemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). \u003cbr\u003e\n\u003ca href=\"/pdf/2024_solution_path_heuristics.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). \u003cbr\u003e\n\u003ca href=\"/pdf/2023_ddaviaplgviamdp.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e","title":"Publications"},{"content":"Introduction Hello, world! I\u0026rsquo;m here again :D\n","permalink":"http://localhost:1313/games/second/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eHello, world! I\u0026rsquo;m here again :D\u003c/p\u003e","title":"Second"},{"content":"Generative Design in Minecraft (GDMC) GDMC is a competition to generate settlements within a selection of a minecraft map. The project\u0026rsquo;s website provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\nMCEdit To generate settlements, the competition has gone the route of using MCEdit to allow competitors to view, generate, and modify minecraft maps. GDMC provides a wiki with easy to use instructions for installing and general set up. The wiki also provides an example cellular automata script for generating structures seen in figure one. As you can see, the output isn’t great, but it provides a nice starting point. It, also, shows how to work with the MCEdit filters which is how we can interact with the maps.\nFigure 1: Example cellular automata output from CASG_Example.py Filters A filter is how we are able to modify maps. To activate a filter, a user makes a selection on the map via a left click and dragging your mouse. From there, on the bottom of the screen, there is a potion looking icon that when pressed will open the filter menu. This provides a drop down menu of available filters. Each of these filters provides a set of options and the ability to perform their respective actions. When activated they will make modifications to the map given the users selection area. Each of the filters are Python 2.7 scripts located in the stock-filters directory.\nFilter Basics The wiki provides some helpful commentary in getting started with filters, but the script is a bit too complicated for a starting point. There are, however, two things that every filter has in common: the perform function and inputs tuple.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def perform(level, box, options): pass When a filter is activated, the engine will call the perform function and pass the level data (this data structure will be explored further in the next post), the bounding box, and the set of options a user has defined. The bounding box defines the origin of the box the user created and the size. The options is a dictionary based on the inputs defined in the above script. Therefore, to access the materials you could use options[“Material”] to be able to see what the user set.\nBox in all Eight Corners of Selection Now that we understand the basics, we can start with a simple filter. The goal of this filter is to place a user defined material in all eight corners of the user’s selection. The end result can be seen in figure two. The first step here is to define the inputs for the user. In this case, the above inputs code is exactly what we need.\nFigure 2: Example of placing blocks at all eight corners of user\u0026#39;s selection space Now we need to know how to draw a block and this can be found in the utility functions provided by NYU. I haven’t figured out the point of the function setBlockDataAt yet, but in the second post I intend to investigate more to figure it out. In the meantime, I wrote a simpler function because the data was always set to 0 in the examples I could find.\ndef draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) With that complete, the only problem now is figuring out how to use the bounding box to find the eight corners. As noted above, the way the bounding box works is by providing an origin and size vector. All variations of adding these two together will provide eight values which are, coincidentally, the corners of the cube. The full filter can be seen below.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) def perform(level, box, options): material = options[\u0026#34;Material\u0026#34;] draw_block(level, box.origin.x, box.origin.y, box.origin.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y, box.origin.z, material) draw_block(level, box.origin.x, box.origin.y + box.size.y, box.origin.z, material) draw_block(level, box.origin.x, box.origin.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x, box.origin.y + box.size.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z + box.size.z, material) Fill Selection In comparison to the eight boxes, this is a lot easier conceptually. All we want to do is fill the entire users selection with a material. The end result can be seen in figure three.\nFigure 3: Two examples of filling in users selection with a different materials The setup is exactly the same as last time where you can use the inputs to define the material. We can even use the draw_block function. At this point, it is probably best to create a script that contains common functions that could be useful in the future. From there, we need to create a function fill_box which takes in the level, origin, size, and material. To fill the box, it is as simple as three for loops that go through all possible x, y, and z values. It is important that you loop from the minimum to the maximum of these, else there is a chance you will not completely fill in the box.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace All\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) def fill_box(level, origin, size, material): final_x = origin.x + size.x final_y = origin.y + size.y final_z = origin.z + size.z for x in range(min(origin.x, final_x), max(origin.x, final_x)): for y in range(min(origin.y, final_y), max(origin.y, final_y)): for z in range(min(origin.z, final_z), max(origin.z, final_z)): draw_block(level, x, y, z, material) def perform(level, box, options): fill_box(level, box.origin, box.size, options[\u0026#34;Material\u0026#34;]) Box Outline In this case we want to take the user’s selection and draw blocks along the edges, an example can be seen in figure four. The complexity for this problem is creating a function that will properly draw lines. Specifically, it is necessary to make sure it can draw diagonal lines for the sake of completeness.\nFigure 4: Example of drawing the edges for a user\u0026#39;s selection The main difficulty in this problem is making sure every direction a line can move is accounted for. The list is quite long but mainly requires some attentiveness on our our part when defining all the possibilities.\ndirections = [ (1,0,0),(-1,0,0),(0,1,0),(0,-1,0),(0,0,1),(0,0,-1),\\ (1,1,0),(-1,1,0),(1,-1,0),(-1,-1,0),(0,1,1),(0,-1,1),\\ (0,1,-1),(0,-1,-1),(1,0,1),(-1,0,1),(1,0,-1),(-1,0,-1),\\ (1,1,1),(-1,1,1),(1,-1,1),(1,1,-1),(-1,-1,1),(-1,1,-1),\\ (1,-1,-1),(-1,-1,-1) ] We now have the task of using the directions array to draw the line along the shortest path from the starting point to the end point. I first wrote this with a recursive method, where it would find the point closest, with the manhattan distance, and then draw a block. It would recursively call itself again, drawing a block at the next closest point, until it had reached the end point. Please note that I did not put in object avoidance into this method as it was beyond the scope of the problem. With the recursive method complete, it became clear a while loop would be just as clear with minimal code changes and be more performant since tail recursion is not supported by Python.\nOnce drawing a line was completed, the last step was to use the vertices I defined in the section dedicated to drawing materials in all eight corners to draw the edges as well. The code for the filter is below.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from pymclevel.box import Vector from mcplatform import * inputs = ( (\u0026#34;Replace All\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def vector_equals(v1, v2): return v1.x == v2.x and v1.y == v2.y and v1.z == v2.z def manhattan_distance(start, end): return abs(end.x - start.x) + abs(end.y - start.y) + abs(end.z - start.z) def draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) def draw_block(level, point, material): level.setBlockAt(point.x, point.y, point.z, material.ID) level.setBlockDataAt(point.x, point.y, point.z, 0) def fill_box(level, origin, size, material): final_x = origin.x + size.x final_y = origin.y + size.y final_z = origin.z + size.z for x in range(min(origin.x, final_x), max(origin.x, final_x)): for y in range(min(origin.y, final_y), max(origin.y, final_y)): for z in range(min(origin.z, final_z), max(origin.z, final_z)): draw_block(level, x, y, z, material) def draw_line(level, start, end, material): directions = [(1,0,0),(-1,0,0),(0,1,0),(0,-1,0),(0,0,1),(0,0,-1),\\ (1,1,0),(-1,1,0),(1,-1,0),(-1,-1,0),(0,1,1),(0,-1,1),\\ (0,1,-1),(0,-1,-1),(1,0,1),(-1,0,1),(1,0,-1),(-1,0,-1),\\ (1,1,1),(-1,1,1),(1,-1,1),(1,1,-1),(-1,-1,1),(-1,1,-1),\\ (1,-1,-1),(-1,-1,-1)] draw_block(level, start, material) while not vector_equals(start, end): new_s = start + directions[0] dist = manhattan_distance(start, end) for i in range(1, len(directions)): s = start + directions[i] d = manhattan_distance(s, end) if d \u0026lt; dist: new_s = s dist = d start = new_s draw_block(level, start, material) def draw_box_outline(level, box, material): point_1 = box.origin point_2 = Vector(box.origin.x + box.size.x, box.origin.y, box.origin.z) point_3 = Vector(box.origin.x, box.origin.y + box.size.y, box.origin.z) point_4 = Vector(box.origin.x, box.origin.y, box.origin.z + box.size.z) point_5 = Vector(box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z) point_6 = Vector(box.origin.x + box.size.x, box.origin.y, box.origin.z + box.size.z) point_7 = Vector(box.origin.x, box.origin.y + box.size.y, box.origin.z + box.size.z,) point_8 = Vector(box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z + box.size.z) draw_line(level, point_1, point_2, material) draw_line(level, point_1, point_3, material) draw_line(level, point_1, point_4, material) draw_line(level, point_2, point_6, material) draw_line(level, point_4, point_6, material) draw_line(level, point_3, point_7, material) draw_line(level, point_4, point_7, material) draw_line(level, point_7, point_8, material) draw_line(level, point_6, point_8, material) draw_line(level, point_8, point_5, material) draw_line(level, point_5, point_2, material) draw_line(level, point_5, point_3, material) def perform(level, box, options): draw_box_outline(level, box, options[\u0026#34;Material\u0026#34;]) ","permalink":"http://localhost:1313/posts/second/","summary":"\u003ch1 id=\"generative-design-in-minecraft-gdmc\"\u003eGenerative Design in Minecraft (GDMC)\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eGDMC\u003c/a\u003e is a competition to generate settlements within a selection of a minecraft map. The \u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eproject\u0026rsquo;s website\u003c/a\u003e provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\u003c/p\u003e","title":"Generative Design in Mineraft: MCEdit Basics"},{"content":"This is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, Swig’s website for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on Swig\u0026rsquo;s website and a StackOverflow question for Python 3. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\n1. Install # python-dev sudo apt-get install python-dev # python2.x sudo apt-get install python3-dev # python3.x # swig sudo apt-get install swig 2. Source c++ Fibonacci implementation, filename: fib.cpp\n#include \u0026#34;fib.h\u0026#34; int fibonacci(int n) { if(n \u0026lt;= 1) return n; return fibonacci(n-1) + fibonacci(n-2); } c++ fibonacci header file, filename: fib.h. I\u0026rsquo;m going to explain why this file exists in a moment.\nint fibonacci(int n); The next file is the interface file for swig, fib.i. This is telling swig what bindings it will need to create and is why we implemented fib.h.\n%module Fibonacci %{ #include \u0026#34;fib.h\u0026#34; %} %include \u0026#34;fib.h\u0026#34; The alternative to creating the fib.h file is directly below. For this we define each function individually for swig to then bind.\n%module Fibonacci %{ int fibonacci(int n); %} int fibonacci(int n); 3. Build setup.py, this file is taken directly from Swig\u0026rsquo;s documentation and modified slightly.\n#!/usr/bin/env python from distutils.core import setup, Extension fib_module = Extension( \u0026#39;_Fibonacci\u0026#39;, sources=[\u0026#39;fib_wrap.cxx\u0026#39;, \u0026#39;fib.cpp\u0026#39;], # fib_wrap.cxx is going to be generated by swig ) setup ( name = \u0026#39;Fibonacci\u0026#39;, version = \u0026#39;0.0\u0026#39;, author = \u0026#34;YOUR_NAME\u0026#34;, description = \u0026#34;Fibonacci swig\u0026#34;, ext_modules = [fib_module], py_modules = [\u0026#34;Fibonacci\u0026#34;], # name of module that we\u0026#39;re going import ) build.sh or whatever you fancy.\n#!/bin/bash swig -c++ -python fib.i python setup.py build_ext --inplace 4. Run Assign permissions (e.g. chmod 755 build.sh) and run ./build.sh. From there you can go into the python console and test by running the following:\n$ python \u0026gt;\u0026gt;\u0026gt; import Fibonacci \u0026gt;\u0026gt;\u0026gt; Fibonacci.fibonacci(10) 55 5. Conclusion Please let me know if anything here can be improved so I can update this for future readers. Regardless, I hope this helped some of you with your projects/work and saved you some time.\n","permalink":"http://localhost:1313/posts/first/","summary":"\u003cp\u003eThis is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig’s website\u003c/a\u003e for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig\u0026rsquo;s website\u003c/a\u003e and a \u003ca href=\"https://stackoverflow.com/questions/32667888/building-extension-for-python-3-with-swig-and-distutils\"\u003eStackOverflow question for Python 3\u003c/a\u003e. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\u003c/p\u003e","title":"C++ to Python Bindings with Swig"},{"content":"Biemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). Paper\nBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). Paper\nBiemer, C., \u0026amp; Cooper, S. (2022, October). Level Assembly as a Markov Decision Process. In 2022 Proceedings of the Experimental AI in Games Workshop. Paper, Talk, Code\nBiemer, C., \u0026amp; Cooper, S. (2022, August). On Linking Level Segments. In 2022 IEEE Conference on Games (CoG) (pp. 199-205). ★ Best Paper Nominee Paper, Talk, Code\nBiemer, C., Hervella, A., \u0026amp; Cooper, S. (2021, August). Gram-Elites: N-Gram Based Quality-Diversity Search. In The 16th International Conference on the Foundations of Digital Games (FDG) 2021 (pp. 1-6). Paper, Talk, Code\nVillareale, J., Biemer, C., Seif El-Nasr, M., \u0026amp; Zhu, J. (2020, September). Reflection in Game-Based Learning: A Survey of Programming Games. In International Conference on the Foundations of Digital Games (pp. 1-9). Paper\n","permalink":"http://localhost:1313/publications/","summary":"\u003cp\u003eBiemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). \u003cbr\u003e\n\u003ca href=\"/pdf/2024_solution_path_heuristics.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). \u003cbr\u003e\n\u003ca href=\"/pdf/2023_ddaviaplgviamdp.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e","title":"Publications"}]