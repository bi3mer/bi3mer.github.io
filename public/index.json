[{"content":"","permalink":"http://localhost:1313/posts/redacting-pdfs/","summary":"","title":"Redacting PDFs"},{"content":"Introduction Hello, world! I\u0026rsquo;m here again :D\n","permalink":"http://localhost:1313/games/second/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eHello, world! I\u0026rsquo;m here again :D\u003c/p\u003e","title":"Second"},{"content":"I came across a youtube video which showed a way to visualize fractal trees. I watched it while eating dinner and didn’t think much of it at the time. A week or two later, though, I had decided to a do a few more challenges for my challenges repository and this was at the top of the list. It is a fairly simple program that has a cool end result seen in figures one and four.\nFigure 1: Example tree visualization. Tools The aforementioned tutorial used p5.js and made it look pretty decent. However, using javascript isn’t something I would do for a personal project that is meant to be fun. As you may have guessed, I decided to use Python instead. The next step is to choose a tool to display the end result. My initial thought was to use matplotlib. However, the youtube tutorial also had animations. I wasn’t aware of animations being available in matplotlib at the time so I went in a different direction. Instead, I went with Pygame. I hadn’t used it before, but it I knew it was widely used in the Python community and I could find answers to any of my rudimentary questions online.\nOpening a Window Before we can start visualizing anything, we need a window that we can open and close without crashing. Luckily, there are a lot of sources that can be easily googled including Pygame’s documentation.\nimport pygame def main(): pygame.init() size = [800, 600] screen = pygame.display.set_mode(size) pygame.display.set_caption(\u0026#34;Fractal Tree\u0026#34;) done = False clock = pygame.time.Clock() while not done: clock.tick(10) for event in pygame.event.get(): if event.type == pygame.QUIT: done = True pygame.quit() if __name__ == \u0026#39;__main__\u0026#39;: main() The above code is the barebones necessary to get a black screen where nothing happens. It runs until the user closes the window. It works by calling the main function at the start. The main function initializes pygame on line 4 and then proceeds to define the size of the window. On line 9 we give the window a title. Line 12 is interesting because it\u0026rsquo;s purpose isn’t exactly clear on a first glance.\nLooking at the documentation, you’ll find, “By calling Clock.tick(40) once per frame, the program will never run at more than 40 frames per second.\u0026quot; This means we are telling pygame that it should run at most 10 frames per a second. Ten frames per a second is a very slow framerate for most games which aim for sixty, but for our black screen this is absolutely fine. After that we check for a pygame event where the user has quit and mark the boolean done as True. From there we tell pygame to quit and we have a black screen.\nCoordinate System and Drawing a Line It\u0026rsquo;s time to draw on the screen. To start we need to know how to draw a line. Luckily, pygame provides a very simple function pygame.draw.line which takes in the screen (line 6 of the code above), the color, the start position (x and y coordinates), the end position, and the width of the line. However, it’s very important to understand how the coordinate system works in the engine before going forward.\nFigure 2: Pygame coordinate system. A graph of how the coordinate system works can be seen in figure two and the source code can be found here. As you can see the top left of the screen corresponds to 0,0. The bottom right corresponds to the windows width and height.\nDrawing the Root of the Tree Now that we have an understanding of the coordinate system in Pygame we can move towards drawing a tree. First we need to draw the root line or base of the tree. To do this we need the start and the end positions. The start position is being supplied to us by the caller but for the first call it will need to be the width divided by two and the height of the screen (line 54 in the section below). The end position will have to be based on the direction of the line and the length.\nThe direction of the line can be defined with an angle. In our case, pi over two is a natural fit because we want the line to be vertical at the start. The length of our line can be any number we want but it will have to be negative to fit in the coordinate system of Pygame. This could also be accomplished by using a negative angle instead. Drawing the line can be seen in the code below:\ndef draw_line(screen, start_pos, line_length, current_angle): end_position = [ start_pos[0] + (line_length * math.cos(current_angle)), start_pos[1] + (line_length * math.sin(current_angle))] color = (255, 255, 255) # white line_width = 1 pygame.draw.line(screen, color, start_pos, end_position, line_width) Line 3 defines the x position where we use the start position plus the length of the line multiplied by the cosine of the angle. This is pretty common geometry so I’m going to skip explaining it. Line 4 does the same except for the y coordinate and uses sine. From there we define the color and line width and call the draw line function.\nDrawing the Tree Now that we can draw the root, the rest of this problem flows pretty naturally if we implement this recursively. Think of it like we are defining a new base of the tree that branches off the current base. If we change the name of the function draw_line to draw_fractal_tree we now have a clearer name. In the function it should call itself twice, since this is a fractal tree, with different directions. Before doing this, though, we need to make sure the recursion stops.\nWe could accomplish this by taking a max iterations approach. We could pass an integer on each call where we subtract it by one every time on the next call. Once the value is less than or equal to zero the function stops calling itself. This is a fine approach, but I believe the next approach, that is about to be described, is more natural fit for the problem.\nA more natural approach is to stop recursion based on the length of the line. Since drawing every branch of the tree with the same length would give a pretty weird looking result, we know the length of each branch should decrease on successive recursive calls. In addition, the tutorial also reduced the line length with every recursive call. To draw the tree we need to define how long the line segment on each call should be. Therefore, if we set a minimum line length we can know when the recursion should stop; this value is on line 14. Line 10 defines the maximum line length. In both cases, you’ll notice that the values are negative. As you’ll recall from the coordinates in figure two, the bottom of the screen is the height value, 600. Since we want to draw from the bottom of the screen to the top, we need to move towards 0 rather than away. Rather than creating a coordinate system on top of the existing one with conversions, I decided making the numbers negative would be simpler.\nLine 25 multiplies the current line length by a constant which should be between 0 and 1. This makes it so the value will approach 0 over time. Line 27 then checks to see if the line length is too small to continue. If not the function ends without an recursive calls. Else we call the function twice. You’ll notice that lines 28 and 29 are exactly the same except for a plus and a minus symbol. These are both using the delta_angle variable which is passed into the function.\nFigure 3: Example fractal tree where `delta_angle` is set to pi over two. The delta_angle variable is what defines how far direction changes for the next branch. If it was set to 0, then you would see only a straight line. If it was set to pi over two, ninety degrees, then you get two perpendicular lines seen in figure three.\nWith the tree implemented, all we have to do is make a few changes to our main function to see the results. The first change is in the for loop between lines 45 and 47 where the escape key now quits the window. First a check for a keydown is done and if that is true then a check for the escape key is done. Lastly, below the for loop, the screen is set to black and the tree is drawn. The flip call will update the entire display.\nfrom math import pi import pygame import math BLACK = ( 0, 0, 0) WHITE = (255, 255, 255) MIN_ANGLE = 0 MAX_ANGLE = pi LINE_LENGTH = -160 LINE_LENGTH_DIVISOR = 2.2/3.0 LINE_WIDTH = 1 MIN_LINE_LENGTH = -2 def draw_fractal_tree(screen, start_pos, line_length, delta_angle, current_angle): end_position = [ start_pos[0] + (line_length * math.cos(current_angle)), start_pos[1] + (line_length * math.sin(current_angle))] pygame.draw.line(screen, WHITE, start_pos, end_position, LINE_WIDTH) line_length *= LINE_LENGTH_DIVISOR if line_length \u0026lt; MIN_LINE_LENGTH: draw_fractal_tree(screen, end_position, line_length, delta_angle, current_angle + delta_angle) draw_fractal_tree(screen, end_position, line_length, delta_angle, current_angle - delta_angle)\tdef main(): pygame.init() size = [800, 600] screen = pygame.display.set_mode(size) pygame.display.set_caption(\u0026#34;Fractal Tree\u0026#34;) done = False clock = pygame.time.Clock() while not done: clock.tick(10) for event in pygame.event.get(): if event.type == pygame.QUIT: done = True if event.type == pygame.KEYDOWN: if event.key == pygame.K_ESCAPE: done = True # Clear the screen and set the screen background screen.fill(BLACK) # draw fractal tree at bottom middle of the screen with the first line # draw straight up at a 90 degree angle draw_fractal_tree(screen, [size[0]/2.0, size[1]], LINE_LENGTH, pi/5.0, pi/2.0) # Go ahead and update the screen with what we\u0026#39;ve drawn. # This MUST happen after all the other drawing commands. pygame.display.flip() pygame.quit() if __name__ == \u0026#39;__main__\u0026#39;: main() Animating the Tree What we have is pretty cool but with a few simple changes we can have the more impressive result seen in figure four. To accomplish this, we have to update the delta_angle every frame. In addition, we need to add something to handle when delta_angle has gone too far in one direction and start moving it back the other way.\nFigure 4: animated fractal tree. To update the delta_angle we can can use a simple lerp seen below. This will find the value between the minimum and maximum based on the percent. Therefore if the percent is 0 it will return the minimum. If the percent is 1 it will return maximum.\ndef lerp(minimum, maximum, percent): return minimum + percent * (maximum - minimum) The other piece needed is a similarly simple function. The variable current_step is the percentage between 0 and 1 that is used in the lerp function. increment is how much the step should increase every call and can be configured. direction is either -1 or 1 and makes it so the increment is either positive or negative depending on which way the tree is moving. The rest just makes it so percent stays between 0 and 1 and moves between the two over time.\ndef update_step(current_step, increment, direction): new_step = current_step + (increment * direction) if new_step \u0026lt;= 0: direction = 1 new_step = 0 elif new_step \u0026gt;= 1: direction = -1 new_step = 1 return new_step, direction With that added we can update the main function to have two variables current_step and direction. The lerp function is used for the delta_angle in the draw_fractal_tree call. After drawing, we call the update_step which updates the step and direction for the next frame.\nThe source code of the project can be found here. You’ll notice I separated everything out a bit and added a config file to make it easier to modify behavior.\ndef main(): # Initialize the game engine pygame.init() # Set the height and width of the screen size = [800, 600] screen = pygame.display.set_mode(size) pygame.display.set_caption(\u0026#34;Fractal Tree\u0026#34;) #Loop until the user clicks the close button. done = False clock = pygame.time.Clock() current_step = 0 direction = 1 while not done: # This limits the while loop to a max of 10 times per second. # Leave this out and we will use all CPU we can. clock.tick(10) for event in pygame.event.get(): if event.type == pygame.QUIT: done = True if event.type == pygame.KEYDOWN: if event.key == pygame.K_ESCAPE: done = True # Clear the screen and set the screen background screen.fill(Config.BLACK) # draw fractal tree at bottom middle of the screen with the first line # draw straight up at a 90 degree angle delta_angle = lerp(Config.MIN_ANGLE, Config.MAX_ANGLE, current_step) draw_fractal_tree(pygame, screen, [size[0]/2.0, size[1]], Config.LINE_LENGTH, delta_angle, pi/2.0) # Go ahead and update the screen with what we\u0026#39;ve drawn. # This MUST happen after all the other drawing commands. pygame.display.flip() current_step, direction = update_step(current_step, Config.STEP, direction) ","permalink":"http://localhost:1313/posts/fractal-tree/","summary":"\u003cp\u003eI came across a \u003ca href=\"https://www.youtube.com/watch?v=0jjeOYMjmDU\"\u003eyoutube video\u003c/a\u003e which showed a way to visualize fractal trees. I watched it while eating dinner and didn’t think much of it at the time. A week or two later, though, I had decided to a do a few more challenges for my \u003ca href=\"https://github.com/bi3mer/challenges\"\u003echallenges repository\u003c/a\u003e and this was at the top of the list. It is a fairly simple program that has a cool end result seen in figures one and four.\u003c/p\u003e","title":"Visualizing Fractal Trees"},{"content":"A Quick Note I ended up getting pretty sick and I was out of commission for about two months. The good news is that I’m now in perfectly good health. The bad news is that it kind of destroyed my hopes of building a decent submission for GDMC. The competition ends in about thirteen days which is not enough time to come up with a submission I would be proud of. In addition, my 40+ hours at the Brain Game Center, where I work, every week is the very large nail in the coffin. Regardless, I plan on continuing to work on this problem until I have something cool I can show off.\nCounting Materials In a Selection The last post featured basic drawing methods to be able to write changes to the map. In this post, I’m attempting to get a better understanding of the level data structure we are given. WIth that in mind, the first thing I want to do is go over how to inspect a block in MCEdit.\nMy initial attempt at this was a failure because I assumed getting a block would follow a similar naming convention to the setBlockAt function. Much to my surprise, this was not the case. Searching through the the code showed that the correct function is actually blockAt. With that unfortunate mistake behind, it was super easy to modify my fill selection code from the last post.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Selection Material Counter\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def perform(level, box, options): final_x = box.origin.x + box.size.x final_y = box.origin.y + box.size.y final_z = box.origin.z + box.size.z materials = {} for x in range(min(box.origin.x, final_x), max(box.origin.x, final_x)): for y in range(min(box.origin.y, final_y), max(box.origin.y, final_y)): for z in range(min(box.origin.z, final_z), max(box.origin.z, final_z)): material = level.blockAt(x,y,z) if material not in materials: materials[material] = 0 materials[material] += 1 print \u0026#34;Material Counts\u0026#34; for key in materials: print \u0026#34;\\t\u0026#34; + str(key) + \u0026#34;: \u0026#34; + str(materials[key]) I used a dictionary with a key to the material and a value of the count. Each material checks to see if it exists in the dictionary and if not it adds itself with a value of 0. After this check, the dictionary value for the key is incremented. After looping through the selection, a loop is used to print out all the values. The output after running on a random selection I made can be seen below.\nMaterial Counts 0: 2361 1: 80 2: 728 3: 917 37: 7 12: 12 17: 93 18: 726 31: 44 Rewriting Every Block Except Empty From the last post we already know how to fill in a space with a material and even make it modifiable from the the UI. We can take the exact same code and add an if statement at the end of the three for loops to check if the block in question is empty and does not have an ID of 0. If it doesn\u0026rsquo;t we can overwrite it, else we can continue onwards.\nFigure 1: Sample where all non-empty blocks are turned into coal. As a note, in mcedit there is a file minecraft.json which defines every block and it’s data. Unfortunately, there isn’t one for empty space. However, looking at the the code in materials.py there is a hardcoded value for air that can be used.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace All Except Air\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) def fill_box(level, origin, size, material): final_x = origin.x + size.x final_y = origin.y + size.y final_z = origin.z + size.z for x in range(min(origin.x, final_x), max(origin.x, final_x)): for y in range(min(origin.y, final_y), max(origin.y, final_y)): for z in range(min(origin.z, final_z), max(origin.z, final_z)): if level.blockAt(x,y,z) != 0: draw_block(level, x, y, z, material) def perform(level, box, options): fill_box(level, box.origin, box.size, options[\u0026#34;Material\u0026#34;]) Nuke Now we can focus on recreating what was done by Christoph Salge in his tweet also seen in figure two. It replaces the top layer of the world with obsidian and tree blocks with coal. In addition, I’ve decided to replace water with lava. All of this is pretty easy except for replacing the top layer of the world. So we are going to break this problem down into two parts. First, we are going to replace the top layer of the world with any material. After that, we are going to combine the result of the first part with the extra replacements to recreate the entire filter.\nFigure 2: Christoph Salge’s filter in action from his tweet. Replacing the Top Layer Up until now every for loop that we have used has been looping through every x, then every y, and then every z to look through the map. This works pretty well but now we have to change it. Mcedit uses a coordinate system where the y coordinate is representative of the height. Therefore, we are going to change our loop to go x, z, and then y. In addition, instead of going from the smallest y to the largest y, we are now going to do the opposite. This means that for every x and z coordinate we will loop from the top of the users selection to the bottom.\nFigure 3: Replacing the to layer with coal. From there, we can loop through the y coordinates and stop once we find a material that isn’t air. The effect can be seen in figure three and the code is directly below.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Top Layer\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) def fill_box(level, origin, size, material): final_x = origin.x + size.x final_y = origin.y + size.y final_z = origin.z + size.z for x in range(min(origin.x, final_x), max(origin.x, final_x)): for z in range(min(origin.z, final_z), max(origin.z, final_z)): # loop from the top until we reach a material that is not empty for y in reversed(range(min(origin.y, final_y), max(origin.y, final_y))): if level.blockAt(x,y,z) != alphaMaterials.Air.ID: draw_block(level, x, y, z, material) break def perform(level, box, options): fill_box(level, box.origin, box.size, options[\u0026#34;Material\u0026#34;]) Replacing the Top Layer and All Other Materials We can break this problem into 3 parts to get the effect seen in figure four:\nReplace the top layer with obsidian Replace all water with lava Replace all trees with coal and remove the leaves Figure 4: Nuke effect in action. The first effect is now easy, we use the code from the section above and give it the material of Obsidian. The second effect is also easy, we use our replace all function and change it to only change the value to lava if the given block is water. The only thing to note is that we have to use the materials ID instead of just the material. Lastly, we do the same thing as the second part but also check for leaves. With wood we replace it with coal and with leaves we replace it with air. It is important to note that the the replace top layer function must be called last or you will end up with obsidian blocks where leaves used to be. The code below directly represents this line of thought but you’ll probably notice it is fairly inefficient.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from pymclevel.box import Vector from mcplatform import * inputs = ( (\u0026#34;Nuke\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) # We do this last, so we can assume leaves have been destroyed and # wood has been changed to coal def fill_top_layer_with_obsidian(level, origin, size): for x in range(min(origin.x, size.x), max(origin.x, size.x)): for z in range(min(origin.z, size.z), max(origin.z, size.z)): # loop from the top until we reach a material that is not empty for y in reversed(range(min(origin.y, size.y), max(origin.y, size.y))): block = level.blockAt(x,y,z) if block != alphaMaterials.Air.ID and \\ block != alphaMaterials.CoalBlock.ID and \\ block != alphaMaterials.Lava.ID: draw_block(level, x, y, z, alphaMaterials.Obsidian) break def replace_all_water_with_lava(level, origin, size): for x in range(min(origin.x, size.x), max(origin.x, size.x)): for y in range(min(origin.y, size.y), max(origin.y, size.y)): for z in range(min(origin.z, size.z), max(origin.z, size.z)): block = level.blockAt(x,y,z) if block == alphaMaterials.Water.ID or block == alphaMaterials.WaterActive.ID: draw_block(level, x, y, z, alphaMaterials.Lava) def replace_all_trees_with_coal(level, origin, size): for x in range(min(origin.x, size.x), max(origin.x, size.x)): for y in range(min(origin.y, size.y), max(origin.y, size.y)): for z in range(min(origin.z, size.z), max(origin.z, size.z)): block = level.blockAt(x,y,z) if block == alphaMaterials.Wood.ID: draw_block(level, x, y, z, alphaMaterials.CoalBlock) elif block == alphaMaterials.Leaves.ID: draw_block(level, x, y, z, alphaMaterials.Air) def perform(level, box, options): size = Vector(box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z + box.size.z) replace_all_water_with_lava(level, box.origin, size) replace_all_trees_with_coal(level, box.origin, size) fill_top_layer_with_obsidian(level, box.origin, size) The above code is inefficient because it does the same three loops three times in three different functions. It was convenient to write the program this way the first time because it was clear and helped organize our thoughts. However, now that we have a working version it is worthwhile to go back and figure out a way to combine all three loops.\nThis means copying the inner loops and pasting them into one for loop, however there is some conflict with the replace top layer loop. A first step could be to to write two for loops for the y coordinate at the end: one for the water and trees and the other for the top layer.\ndef nuke(level, origin, size): for x in range(min(origin.x, size.x), max(origin.x, size.x)): for z in range(min(origin.z, size.z), max(origin.z, size.z)): for y in range(min(origin.y, size.y), max(origin.y, size.y)): block = level.blockAt(x,y,z) if block == alphaMaterials.Water.ID or block == alphaMaterials.WaterActive.ID: draw_block(level, x, y, z, alphaMaterials.Lava) elif block == alphaMaterials.Wood.ID: draw_block(level, x, y, z, alphaMaterials.CoalBlock) elif block == alphaMaterials.Leaves.ID: draw_block(level, x, y, z, alphaMaterials.Air) # loop from the top until we reach a material that is not empty for y in reversed(range(min(origin.y, size.y), max(origin.y, size.y))): block = level.blockAt(x,y,z) if block != alphaMaterials.Air.ID and \\ block != alphaMaterials.CoalBlock.ID and \\ block != alphaMaterials.Lava.ID: draw_block(level, x, y, z, alphaMaterials.Obsidian) break This is a good first step, however, we can improve it by making it work in one loop rather than two. The only step is to create a set of if, else if statements where the top layer statement is last. You may have concerns about the break ruining the filter, however, this break actually makes it so we do less work and still get the same effect. I’m leaving it as a thought experiment for anyone who wants to figure out how this works.\ndef nuke(level, origin, size): for x in range(min(origin.x, size.x), max(origin.x, size.x)): for z in range(min(origin.z, size.z), max(origin.z, size.z)): # loop from the top until we reach a material that is not empty for y in reversed(range(min(origin.y, size.y), max(origin.y, size.y))): block = level.blockAt(x,y,z) if block == alphaMaterials.Water.ID or block == alphaMaterials.WaterActive.ID: draw_block(level, x, y, z, alphaMaterials.Lava) elif block == alphaMaterials.Wood.ID: draw_block(level, x, y, z, alphaMaterials.CoalBlock) elif block == alphaMaterials.Leaves.ID: draw_block(level, x, y, z, alphaMaterials.Air) elif block != alphaMaterials.Air.ID and \\ block != alphaMaterials.CoalBlock.ID and \\ block != alphaMaterials.Lava.ID: draw_block(level, x, y, z, alphaMaterials.Obsidian) break ","permalink":"http://localhost:1313/posts/gdmc2/","summary":"\u003ch1 id=\"a-quick-note\"\u003eA Quick Note\u003c/h1\u003e\n\u003cp\u003eI ended up getting pretty sick and I was out of commission for about two months. The good news is that I’m now in perfectly good health. The bad news is that it kind of destroyed my hopes of building a decent submission for GDMC. The competition ends in about thirteen days which is not enough time to come up with a submission I would be proud of. In addition, my 40+ hours at the \u003ca href=\"https://braingamecenter.ucr.edu/\"\u003eBrain Game Center\u003c/a\u003e, where I work, every week is the very large nail in the coffin. Regardless, I plan on continuing to work on this problem until I have something cool I can show off.\u003c/p\u003e","title":"Generative Design in Mineraft: Nuking the Ground"},{"content":"If you’ve read my previous posts, then you know I love python. Regardless, it has been a goal of mine to be proficient in c++. I’m not exactly sure why I’m fascinated with this language that I have no uses cases for, but I think it stems from my love of video games. C++ is used extensively by my favorite company, Blizzard Entertainment, and sees a wide range of use across the industry. In addition, it also is apart of a field that is of particular interest for me, AI. For example, tensorflow is implemented in c++.\nWith my interest in c++ in mind, I decided to write a few sorting algorithms as a way to practice using the language without doing anything too extensive. What resulted was a series of dull challenges which really tells you nothing about me as a programmer and if I can do anything. However, I recalled watching these youtube videos from when I was freshman first learning the algorithms and decided visualizing my implementations may be a way to add some spice to what was otherwise a very dull set of implementations.\nQuick Sort Implemented in c++ int partition(int* a, int low, int high) { int lowIndex = low - 1; int pivot = a[high]; for(int i = low; i \u0026lt; high; ++i) { if(a[i] \u0026lt;= pivot) { ++lowIndex; std::swap(a[lowIndex], a[i]); } } ++lowIndex; std::swap(a[lowIndex], a[high]); return lowIndex; } void quickSortImplemented(int* a, int low, int high) { if(low \u0026lt; high) { int pi = partition(a, low, high); quickSort(a, low, pi - 1); quickSort(a, pi + 1, high); } } void quickSort(int* a, int length) { quickSortImplemented(a, 0, length - 1); } Installing Glut on Ubuntu Glut is a way for c++ to be able to talk to OpenGL and draw things. For installing glut I found a helpful article which gave me the installation commands I needed to run:\nsudo apt-get install mesa-common-dev sudo apt-get install freeglut3-dev They also provide a sample program that will draw a white square on a black background.\n#include \u0026#34;GL/freeglut.h\u0026#34; #include \u0026#34;GL/gl.h\u0026#34; /* display function - code from: http://fly.cc.fer.hr/~unreal/theredbook/chapter01.html This is the actual usage of the OpenGL library. The following code is the same for any platform */ void renderFunction() { glClearColor(0.0, 0.0, 0.0, 0.0); glClear(GL_COLOR_BUFFER_BIT); glColor3f(1.0, 1.0, 1.0); glOrtho(-1.0, 1.0, -1.0, 1.0, -1.0, 1.0); glBegin(GL_POLYGON); glVertex2f(-0.5, -0.5); glVertex2f(-0.5, 0.5); glVertex2f(0.5, 0.5); glVertex2f(0.5, -0.5); glEnd(); glFlush(); } /* Main method - main entry point of application the freeglut library does the window creation work for us, regardless of the platform. */ int main(int argc, char** argv) { glutInit(\u0026amp;argc, argv); glutInitDisplayMode(GLUT_SINGLE); glutInitWindowSize(500,500); glutInitWindowPosition(100,100); glutCreateWindow(\u0026#34;OpenGL - First window demo\u0026#34;); glutDisplayFunc(renderFunction); glutMainLoop(); return 0; } With our packages and program we can now test to see if it will run. To test, input the following in your terminal. Please note, I assume you’ve named this file main.cpp in the commands below.\ng++ main.cpp -lGL -lGLU -lglut ./a.out Drawing in OpenGL with Glut Now that we can draw things, we need to understand how exactly we are drawing. The first thing to notice in the sample program above, is how it draws the square where every vertex has either -0.5 or 0.5 for the x and y axis.\nRepresentation of square generated in sample code for OpenGL As you can see in figure one, source code here, the blue square is the square we see when running our c++ code. The black lines represent the axis and ultimately show us how we are expected to draw with this framework. -1 to 1 are the boundaries on both the x and y axis. So the vertex (-1,-1) would be the bottom left of the screen and (1,1) would be the top right.\nDrawing a Frame A frame for us is a visual representation of the array we are sorting and the progress. Therefore, before we can starting writing code we have to define the array we want to visualize. Luckily, this is fairly simple because our goal isn’t to write something super generic. Our one and only goal is to write something that visualizes the sort. WIth that in mind let’s assume an array is a set of integers ordered from 0 to n, where n is some arbitrary length greater than 0.\nint* arr = (int*) malloc(sizeof(int) * length); for(int i = 0; i \u0026lt; length; ++i) { arr[i] = i; } Please note, I’m aware that the malloc isn’t necessary but it will come into play later so please just bear with me. With our array now defined, we need a render function that will be able to draw rectangles for each and every element of the array inside of our window. These rectangles need to scale based on the size of the array.\nvoid renderFunction() { glClearColor(0.0, 0.0, 0.0, 0.0); glClear(GL_COLOR_BUFFER_BIT); glColor3f(1.0, 1.0, 1.0); glOrtho(-1.0, 1.0, -1.0, 1.0, -1.0, 1.0); float l = (float) length; float widthAdder = 1/l; for(int i = 0; i \u0026lt; length; ++i) { glBegin(GL_POLYGON); // + 1 so value of 0 has height of 1 float arrayIndexHeightRatio = 2*(arr[i] + 1)/l; float widthIndexAdder = 2*i/l; float leftX = -1 + widthIndexAdder; float rightX = leftX + widthAdder; float bottomY = -1; float topY = bottomY + arrayIndexHeightRatio; // bottom left glColor4f(1,0,0,0); glVertex2f(leftX, bottomY); // bottom right glColor4f(0,1,0,0); glVertex2f(rightX, bottomY); // top right glColor4f(0,0,1,0); glVertex2f(rightX, topY); // top left glColor4f(0,0,0,1); glVertex2f(leftX, topY); glEnd(); } glFlush(); } Now there is a decent bit going on here, so let’s break it down. The most important thing to notice is that I’m using variables arr and length without ever having declared them or passed them into the function. The unfortunate reality here is that there is no way, that I could find, to pass a variable into the render function. Now I imagine a class would resolve this, but I used a global because I knew this code would only be used once. If I thought, for even a second, that I would use it again then I would have attempted the class approach or anything to avoid having these horrible globals.\nThe first set of commands is clearing the screen so we can draw on it without drawing over anything else. After that we convert the length to a float so we can divide by it without worrying about integer rounding. We then create this variable called widthAdder which is how long, widthwise, a rectangle will be. Also, please note, you could do 2/l instead which would cause the rectangles to touch as seen in figure two.\n1/l 2/l We now begin looping over every element of the array to draw the rectangle that represents the given element. We use the element’s index to determine where it is located along the x axis and the actual value to determine the height. To start we call a function glBegin with an enumeration to a polygon. With every glBegin call there will always be a glEnd call that you see at the end of the loop. After the begin call we create a variable which represents the height of the index. We calculate this by taking the value and adding one, this ensures the zero value will be shown, and multiplying the result by two. This multiplication allows us to use the entire screen of negative one to one. We then divide by the length of the array to properly scale the result. You’ll notice that the +1 we used for making 0 show on the screen also set the scaling to a proper factor. The other way to resolve this would have been to divide by the length subtracted by 1.\nThe next variable allows us to find the starting x coordinate before subtracting by one. We take the index of the element and divide by the length. From there we multiply it by two. Once we subtract by one we will have the starting left x coordinate.\nWith this math completed, all we have to do is finish up our variable definitions for the four corners of the rectangle and draw out the vertices. You’ll notice that I added colors to the vertices as well so the resulting graphs would be prettier. The results of this can be seen in Figure 2 after randomizing the array for an array of size 500.\nFigure 2: Sample graph generated for a randomized array Visualizing the Sort Now we want to redraw the entire screen after every single swap (an optimization for this would be to only redraw the areas of the screen for the two rectangles that are swapped). The easiest way to do this is to write our own version of swap that will still use the std::swap function, but also call the render function.\nvoid swap(int index1, int index2) { std::swap(arr[index1], arr[index2]); renderFunction(); usleep(delay); } You’ll notice that I take advantage of the horrible global and actually don’t pass it in. In addition, I’ve added an extra line usleep(delay) which pauses the execution for however many milliseconds. This makes it so we can actually see the sort happening. This function call isn’t necessarily ideal for all operating systems and using boost instead would be optimal. In addition, you’ll notice that delay is also undefined and must therefore be a global. This is the third and second to last global (length is the second).\nWith swapping implemented, we now need a generic way of passing our sorting algorithm to the visualizer. Luckily, c++ gives us an easy way to pass functions.\nint setUpGlutAndArray(int argc, char** argv, void (*sortingAlgorithm)(int*, int)) { sort = sortingAlgorithm; arr = (int*) malloc(sizeof(int) * length); for(int i = 0; i \u0026lt; length; ++i) { arr[i] = i; } randomizeArray(arr, length); glutInit(\u0026amp;argc, argv); glutInitDisplayMode(GLUT_SINGLE); glutInitWindowSize(length,length); glutInitWindowPosition(100,100); glutCreateWindow(\u0026#34;Sort Visualization\u0026#34;); glutDisplayFunc(renderFunction); glutKeyboardFunc(keyboardEvent); glutMainLoop(); } This function sets our fourth and final global, the swapping algorithm. After that, it does the exact same things from the original main function we have above, except, there is now a keyboard function and a randomize array function.\nThe keyboard function is called on keyboard events and takes in a few arguments. In our case we use this event to handle the escape key, 27, and s key, 115. When the escape key is pressed we quit out. When the s key is pressed, we start the sort.\nvoid keyboardEvent(unsigned char c, int x, int y) { if(c == 27) { // exit on escape key pressed exit(0); free(arr); } else if(c == 115) { // start on `s` key pressed sort(arr, length); } } What we now have is a complete program and all we have to do is set up our main function. Say we wanted to see how quicksort looked. Then we could create a main function underneath our quicksort code from above; please note that the sorting algorithm will have to use the new swap function. Sample source code can be found here.\nint main(int argc, char* argv[]) { srand(time(NULL)); delay = 1500; length = 500; setUpGlutAndArray(argc, argv, quicksort); free(arr); return 0; } And when running and after pressing s, we would get the gif seen in Figure 3.\nFigure 3: Example gif produced from running quicksort. Conclusion If I wanted to spend more time on this then the first thing I would do is remove all four of those horrible globals. However, besides that one element I’m pretty happy with the result. I think the visualization came out looking pretty good and it was shocking to see just how much faster quicksort really is then something like bubble sort. In addition, it was also just good experience to work in OpenGL and familiarize myself with tools that are a little outside of my comfort zone.\n","permalink":"http://localhost:1313/posts/visualizing-sorting-algorithms-with-opengl/","summary":"\u003cp\u003eIf you’ve read my previous posts, then you know I love python. Regardless, it has been a goal of mine to be proficient in c++. I’m not exactly sure why I’m fascinated with this language that I have no uses cases for, but I think it stems from my love of video games. C++ is used extensively by my favorite company, Blizzard Entertainment, and sees a wide range of use across the industry. In addition, it also is apart of a field that is of particular interest for me, AI. For example, \u003ca href=\"https://github.com/tensorflow/tensorflow\"\u003etensorflow\u003c/a\u003e is implemented in c++.\u003c/p\u003e","title":"Visualizing Sorting Algorithms with OpenGL"},{"content":"Source Control and GitHub GitHub is an awesome website that allows you to have unlimited repositories, for free, that are backed up with git on a remote server. In addition, it provides you with helpful tools like issues that allow you to keep track of bugs, features, and anything else you want. It is not the end all be all of source control and has pros and cons that should be considered before being used.\nFor our use case, github is the perfect option because it is a free service that allows anyone to see our code easily. Other services, are either going to cost money or make it difficult to distribute the code. With that said, we are using version control for more than just visibility. For every project, working with version control is mandatory. If you plan on working with a group, then it provides a single workspace where you don’t have to manage a set of files and combining them. It allows you to revert back if you’ve made a huge mistake. It allows you to experiment on separate branches while not breaking the main branch.\nThe list that I provided is drastically shorter than the whole, but feel free to search google for more examples of why you should use source control. Regardless, please do not make the mistake of thinking that version control is only for group projects. It is for all projects.\nAdding Python as the `.gitignore` file With that said we can now create our repository. To create a github account, go to their create an account page and sign up (it’s free). From there, follow their instructions on creating a repository and make sure to set the dropdown menu “Add .gitignore” to “Python” as seen in figure one. I named my repository UnBlockMeSolver, but any name that is descriptive and follows these guidelines is fine (make sure to avoid special characters like #, %, :, etc.).\nMatrix Board Formats For me, defining a program that is configurable is of the utmost importance. I personally believe it leads to better design and creates more robust programs. When making games, I want to make it so designers can easily change behavior without having to come to me to get the changes in. Usually this means exposing some kind of file that they can modify. The first step in our game’s configurability is to create a file format for defining a board.\nLooking at the requirements we defined in the last post, we know that every piece on the board has a unique identifier. This means '1', 'abc', and 'b' are technically viable piece names. However, I personally would like to exclude the id ‘abc’ if possible. If we restrict an id to having at most one character than we lose some flexibility but have an easier implementation. The flexibility we lose is an, almost, unlimited number of unique identifiers. Instead we will only have approximately 36 ids (26 letters in the alphabet plus 10 numbers of zero to nine). With that said, we technically have more with symbols and special characters but it would be an inconvenience for designers to type out. We can have even more if we include capitals and lower case characters.\nOnly having around 36 items on a board really isn’t going to hinder us. Our initial goal is to work with boards that are 6x6 which is the standard for both Rush Hour and Unblock Me. It is impossible, therefore, for us to have greater than 18 pieces on the board (18 2x1 pieces would perfectly fill the board). Since we know 36 unique identifiers will not hinder us, we now have to ask whether we can see cases in the future where this will change. I personally can see a case where I may want to test on a bigger board, however, I see that future as very unlikely. So, instead I’m going to update the first requirement to be, “The board will be represented by a two dimensional matrix that contains unique character identifiers for each block.\u0026quot;\nWith that update completed, we now to handle the second and third requirements:\nThe board will have a unique identifier which represents the goal. The board will have a unique identifier which represents the red block or main block. We need to define constants for the goal and the the main block. But that is actually incomplete. We also need to define a constant for empty space. In addition, I’ve decided to add some extra complexity to our version by allowing there to be walls. These walls will be unable to move and take up one or more spots.\nwall = \u0026#34;|\u0026#34; goal = \u0026#34;$\u0026#34; empty = \u0026#34;0\u0026#34; playerPiece = \u0026#34;*\u0026#34; These constants could be random characters, but since they will be exposed to designers it is important to make them as easy to understand as possible.\nSample Unblock Me board The last step is to produce a sample map that we can use when testing our parser. To do so, we can copy the map seen in figure two into our format:\n010000 010020 **3020$ 003000 400555 400000 What you probably notice is that our goal is sticking out. This complicates are implementation because we will have unequal dimensions. This now puts us in a situation where can either modify a requirement, again, or update the definition of the matrix to hide this issue.\nUpdating the requirement would likely mean removing the goal from the matrix. Instead we would create a required field where we defined the x and y coordinates of the goal.\n(6,2) 010000 010020 **3020 003000 400555 400000 I personally don’t like this option because it complicates our parsing and sets up weird edge cases where we aren’t technically worried about going out of bounds of the matrix to find the solution for the game.\nAlternatively, we could simply surround the whole matrix with walls. This makes it so we can still define a goal wherever we want and now have a full matrix where special cases are not needed to be handled. With that update we would now have the following matrix in a file:\n|||||||| |010000| |010020| |**3020$ |003000| |400555| |400000| |||||||| Technically, the walls on top can be avoided but I’m imagining cases in the future where we use these walls to help the GUI properly render the board. It may not come into fruition, but it won’t hurt.\nUpdate (2024/11/21) Part of the process of updating my website has been converting converting all my old posts to new ones. Coming across this one was odd because I know I worked a lot on the codebase. If you look at the repository, you\u0026rsquo;ll see that I implemented the game, a server with Heroku working with documentation, and a solver. I was working on puzzle generation, and I had some work going on improving the solver with heuristics. In short, I had a lot of stuff to write about. However, I didn\u0026rsquo;t and I don\u0026rsquo;t remember why. So, for anyone who enjoyed these two posts, apologies that I didn\u0026rsquo;t continue.\n","permalink":"http://localhost:1313/posts/making-rush-hour-2/","summary":"\u003ch1 id=\"source-control-and-github\"\u003eSource Control and GitHub\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/\"\u003eGitHub\u003c/a\u003e is an awesome website that allows you to have unlimited repositories, for free, that are backed up with \u003ca href=\"https://git-scm.com/\"\u003egit\u003c/a\u003e on a remote server. In addition, it provides you with helpful tools like \u003ca href=\"https://docs.github.com/en/issues/tracking-your-work-with-issues/about-issues\"\u003eissues\u003c/a\u003e that allow you to keep track of bugs, features, and anything else you want. It is not the end all be all of \u003ca href=\"https://aws.amazon.com/devops/source-control/\"\u003esource control\u003c/a\u003e and has \u003ca href=\"https://www.timedoctor.com/blog/git-mecurial-and-cvs-comparison-of-svn-software/\"\u003epros and cons that should be considered\u003c/a\u003e before being used.\u003c/p\u003e","title":"Making Rush Hour: Github and Matrix Formats"},{"content":"This is the first in a series of posts where I discuss implementing a version of Unblock Me and Rush Hour; sample screen shots can be seen in figure one. For the implementation, I’ve decided to use Python 2.7, however, you should be able to follow along with any language. My hope is that each of these posts will be more than just a copy and paste tutorial. To facilitate this, I will be taking deep dives into design decisions, test-driven design, common game AI architecture, general software structure, requirements gathering, servers, and more.\nWhy Python? Choosing a language for a project is one of the most important decisions that you’ll have to make. It will define how you approach problems, what problems you feel comfortable solving, and even how fast your code will execute. For these reasons, and more, it is imperative to choose a language for a better reason than, “It’s my favorite programming language.”\nIronically, one of the main reasons I decided to use python for this project is that it is favorite language. My original goal was to show prospective employers an example project that goes beyond the usual, “I stopped once I got it working.” I wanted to create something that I would feel comfortable showing off not only for the functionality but also the code quality. WIth that in mind, I decided to use python because it would allow me to completely focus on the design and code quality thanks to my level of familiarity with the language.\nIn addition, I knew python would be the best bet in the long run because after implementing the game I intend to look into procedural generation of valid boards and machine learning techniques to generate a valid heuristic for A* pathfinding. Both of these goals are well suited for python and the bonus isomorphism makes a life a tad bit easier in the future.\nRequirements It may seem like common sense, but the most important part in programming is knowing exactly what the end goal is for the project. If you know the end goal, you can quickly program to those exact specifications without worry that something will change midway through. Unfortunately, the reality of software development is that things will change and the program will have to change with them. Therefore, it is necessary to develop fully knowing that code you’ve written yesterday will change to accomodate a new feature or idea. The best way to handle these changes is to design with flexibility in mind. Usually this means expecting the changes before they have been requested.\nThis can lead some to make the program so flexible that becomes unreasonable and out of scope. One particular moment of mine that stands as is when I decided to make a simple chess game. At the start I was programming with the obvious constraint of the board being in two dimensions. But I had a thought that it may be cool to make the game configurable so someone could play in two dimensions or higher. What resulted was a series of headaches and unnecessary pain for a feature that would never be used. Knowing the right kind of flexibility to add when developing software is key and something that comes with time.\nIn our case, we won’t have to worry about a project manager changing requirements midway through the project but we still have to worry about getting a bright idea that can change everything. Therefore, before even writing our first line of code we need to develop a set of requirements that will be true throughout the project. These requirements will define the core of the game.\nThe board will be represented by a two dimensional matrix that contains unique identifiers for each block. The board will have a unique identifier which represents the goal. The board will have a unique identifier which represents the red block or main block. A block that is longer lengthwise than heightwise can only be moved horizontally one space or more. A block that is longer heightwise than lengthwise can only be moved vertically one space or more. A block that is equal in length and height cannot exist. A block can not be moved through another block. Only the main block can take the spot of the goal on the board. The game will end when the player has managed to slide the main block into the goal. This is not a complete set of requirements, for more on this topic you can view BelitSoft\u0026rsquo;s standard, but it does serve as a baseline for future development. Nothing we develop will go against these requirements. More rigorous requirements building in a professional environment is essential because they force everyone to be on the same page for what is going to be built.\nStructuring the Project With our requirements complete, we can now work on defining how we want everything to be structured. The first decision is to figure out a proper file structure knowing we will have one main project with multiple, dependent, side projects. Therefore, a simple flat structure of python files being in the root directory is far too simple for our use case. We want to make everything clear and streamlined so users can easily find what they want.\nThe two popular solutions for this problem are to create separate repositories with submodules to the required repositories or to use a a monolithic repository. The first solution isn’t ideal because it sets up cases where we can make changes to one repository that will force multiple dependent repositories to update. This issue becomes exacerbated when repositories are thrown of sync due to simply forgetting to update. Meaning, the main weakness of this approach is that we have to be hyper vigilant when making changes to any repository. The second option means we will have folders at the root for each part of the project we’ll want to build. This means linking them up may not be ideal. For example, one folder will contain the implementation of the game’s logic where another may be an implementation of the GUI. The GUI will be dependent on the games folder, just like with the submodule approach, and there will have to be a weird import set up to go to the root directory and grab the requirements. However, everything will always be in sync and thorough unit testing will make it clear when something has broken.\nNeither of the two approaches are necessarily better than the other, but I ultimately went with the monolithic approach. The inconvenience of getting imports to work seemed minor to the headaches that would ensue with the submodules approach.\nNext Time Next time, we’ll be starting off with setting up our github repository with our monolithic structure in mind. Once that is complete, we can get the basics of the game working by defining a format for a board that can be read from text files. Lastly, we’ll look into a structure for AI in games and how it will affect our design and implementation.\n","permalink":"http://localhost:1313/posts/making-rush-hour-1/","summary":"\u003cp\u003eThis is the first in a series of posts where I discuss implementing a version of \u003ca href=\"https://apps.apple.com/us/app/unblock-me/id315019111\"\u003eUnblock Me\u003c/a\u003e and \u003ca href=\"https://en.wikipedia.org/wiki/Rush_Hour_(puzzle)\"\u003eRush Hour\u003c/a\u003e; sample screen shots can be seen in figure one. For the implementation, I’ve decided to use Python 2.7, however, you should be able to follow along with any language. My hope is that each of these posts will be more than just a copy and paste tutorial. To facilitate this, I will be taking deep dives into design decisions, test-driven design, common game AI architecture, general software structure, requirements gathering, servers, and more.\u003c/p\u003e","title":"Making Rush Hour: Requirements and Basic Structuring"},{"content":"Generative Design in Minecraft (GDMC) GDMC is a competition to generate settlements within a selection of a minecraft map. The project\u0026rsquo;s website provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\nMCEdit To generate settlements, the competition has gone the route of using MCEdit to allow competitors to view, generate, and modify minecraft maps. GDMC provides a wiki with easy to use instructions for installing and general set up. The wiki also provides an example cellular automata script for generating structures seen in figure one. As you can see, the output isn’t great, but it provides a nice starting point. It, also, shows how to work with the MCEdit filters which is how we can interact with the maps.\nFigure 1: Example cellular automata output from CASG_Example.py Filters A filter is how we are able to modify maps. To activate a filter, a user makes a selection on the map via a left click and dragging your mouse. From there, on the bottom of the screen, there is a potion looking icon that when pressed will open the filter menu. This provides a drop down menu of available filters. Each of these filters provides a set of options and the ability to perform their respective actions. When activated they will make modifications to the map given the users selection area. Each of the filters are Python 2.7 scripts located in the stock-filters directory.\nFilter Basics The wiki provides some helpful commentary in getting started with filters, but the script is a bit too complicated for a starting point. There are, however, two things that every filter has in common: the perform function and inputs tuple.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def perform(level, box, options): pass When a filter is activated, the engine will call the perform function and pass the level data (this data structure will be explored further in the next post), the bounding box, and the set of options a user has defined. The bounding box defines the origin of the box the user created and the size. The options is a dictionary based on the inputs defined in the above script. Therefore, to access the materials you could use options[“Material”] to be able to see what the user set.\nBox in all Eight Corners of Selection Now that we understand the basics, we can start with a simple filter. The goal of this filter is to place a user defined material in all eight corners of the user’s selection. The end result can be seen in figure two. The first step here is to define the inputs for the user. In this case, the above inputs code is exactly what we need.\nFigure 2: Example of placing blocks at all eight corners of user\u0026#39;s selection space Now we need to know how to draw a block and this can be found in the utility functions provided by NYU. I haven’t figured out the point of the function setBlockDataAt yet, but in the second post I intend to investigate more to figure it out. In the meantime, I wrote a simpler function because the data was always set to 0 in the examples I could find.\ndef draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) With that complete, the only problem now is figuring out how to use the bounding box to find the eight corners. As noted above, the way the bounding box works is by providing an origin and size vector. All variations of adding these two together will provide eight values which are, coincidentally, the corners of the cube. The full filter can be seen below.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) def perform(level, box, options): material = options[\u0026#34;Material\u0026#34;] draw_block(level, box.origin.x, box.origin.y, box.origin.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y, box.origin.z, material) draw_block(level, box.origin.x, box.origin.y + box.size.y, box.origin.z, material) draw_block(level, box.origin.x, box.origin.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x, box.origin.y + box.size.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z + box.size.z, material) Fill Selection In comparison to the eight boxes, this is a lot easier conceptually. All we want to do is fill the entire users selection with a material. The end result can be seen in figure three.\nFigure 3: Two examples of filling in users selection with a different materials The setup is exactly the same as last time where you can use the inputs to define the material. We can even use the draw_block function. At this point, it is probably best to create a script that contains common functions that could be useful in the future. From there, we need to create a function fill_box which takes in the level, origin, size, and material. To fill the box, it is as simple as three for loops that go through all possible x, y, and z values. It is important that you loop from the minimum to the maximum of these, else there is a chance you will not completely fill in the box.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace All\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) def fill_box(level, origin, size, material): final_x = origin.x + size.x final_y = origin.y + size.y final_z = origin.z + size.z for x in range(min(origin.x, final_x), max(origin.x, final_x)): for y in range(min(origin.y, final_y), max(origin.y, final_y)): for z in range(min(origin.z, final_z), max(origin.z, final_z)): draw_block(level, x, y, z, material) def perform(level, box, options): fill_box(level, box.origin, box.size, options[\u0026#34;Material\u0026#34;]) Box Outline In this case we want to take the user’s selection and draw blocks along the edges, an example can be seen in figure four. The complexity for this problem is creating a function that will properly draw lines. Specifically, it is necessary to make sure it can draw diagonal lines for the sake of completeness.\nFigure 4: Example of drawing the edges for a user\u0026#39;s selection The main difficulty in this problem is making sure every direction a line can move is accounted for. The list is quite long but mainly requires some attentiveness on our our part when defining all the possibilities.\ndirections = [ (1,0,0),(-1,0,0),(0,1,0),(0,-1,0),(0,0,1),(0,0,-1),\\ (1,1,0),(-1,1,0),(1,-1,0),(-1,-1,0),(0,1,1),(0,-1,1),\\ (0,1,-1),(0,-1,-1),(1,0,1),(-1,0,1),(1,0,-1),(-1,0,-1),\\ (1,1,1),(-1,1,1),(1,-1,1),(1,1,-1),(-1,-1,1),(-1,1,-1),\\ (1,-1,-1),(-1,-1,-1) ] We now have the task of using the directions array to draw the line along the shortest path from the starting point to the end point. I first wrote this with a recursive method, where it would find the point closest, with the manhattan distance, and then draw a block. It would recursively call itself again, drawing a block at the next closest point, until it had reached the end point. Please note that I did not put in object avoidance into this method as it was beyond the scope of the problem. With the recursive method complete, it became clear a while loop would be just as clear with minimal code changes and be more performant since tail recursion is not supported by Python.\nOnce drawing a line was completed, the last step was to use the vertices I defined in the section dedicated to drawing materials in all eight corners to draw the edges as well. The code for the filter is below.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from pymclevel.box import Vector from mcplatform import * inputs = ( (\u0026#34;Replace All\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def vector_equals(v1, v2): return v1.x == v2.x and v1.y == v2.y and v1.z == v2.z def manhattan_distance(start, end): return abs(end.x - start.x) + abs(end.y - start.y) + abs(end.z - start.z) def draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) def draw_block(level, point, material): level.setBlockAt(point.x, point.y, point.z, material.ID) level.setBlockDataAt(point.x, point.y, point.z, 0) def fill_box(level, origin, size, material): final_x = origin.x + size.x final_y = origin.y + size.y final_z = origin.z + size.z for x in range(min(origin.x, final_x), max(origin.x, final_x)): for y in range(min(origin.y, final_y), max(origin.y, final_y)): for z in range(min(origin.z, final_z), max(origin.z, final_z)): draw_block(level, x, y, z, material) def draw_line(level, start, end, material): directions = [(1,0,0),(-1,0,0),(0,1,0),(0,-1,0),(0,0,1),(0,0,-1),\\ (1,1,0),(-1,1,0),(1,-1,0),(-1,-1,0),(0,1,1),(0,-1,1),\\ (0,1,-1),(0,-1,-1),(1,0,1),(-1,0,1),(1,0,-1),(-1,0,-1),\\ (1,1,1),(-1,1,1),(1,-1,1),(1,1,-1),(-1,-1,1),(-1,1,-1),\\ (1,-1,-1),(-1,-1,-1)] draw_block(level, start, material) while not vector_equals(start, end): new_s = start + directions[0] dist = manhattan_distance(start, end) for i in range(1, len(directions)): s = start + directions[i] d = manhattan_distance(s, end) if d \u0026lt; dist: new_s = s dist = d start = new_s draw_block(level, start, material) def draw_box_outline(level, box, material): point_1 = box.origin point_2 = Vector(box.origin.x + box.size.x, box.origin.y, box.origin.z) point_3 = Vector(box.origin.x, box.origin.y + box.size.y, box.origin.z) point_4 = Vector(box.origin.x, box.origin.y, box.origin.z + box.size.z) point_5 = Vector(box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z) point_6 = Vector(box.origin.x + box.size.x, box.origin.y, box.origin.z + box.size.z) point_7 = Vector(box.origin.x, box.origin.y + box.size.y, box.origin.z + box.size.z,) point_8 = Vector(box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z + box.size.z) draw_line(level, point_1, point_2, material) draw_line(level, point_1, point_3, material) draw_line(level, point_1, point_4, material) draw_line(level, point_2, point_6, material) draw_line(level, point_4, point_6, material) draw_line(level, point_3, point_7, material) draw_line(level, point_4, point_7, material) draw_line(level, point_7, point_8, material) draw_line(level, point_6, point_8, material) draw_line(level, point_8, point_5, material) draw_line(level, point_5, point_2, material) draw_line(level, point_5, point_3, material) def perform(level, box, options): draw_box_outline(level, box, options[\u0026#34;Material\u0026#34;]) ","permalink":"http://localhost:1313/posts/gdmc1/","summary":"\u003ch1 id=\"generative-design-in-minecraft-gdmc\"\u003eGenerative Design in Minecraft (GDMC)\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eGDMC\u003c/a\u003e is a competition to generate settlements within a selection of a minecraft map. The \u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eproject\u0026rsquo;s website\u003c/a\u003e provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\u003c/p\u003e","title":"Generative Design in Mineraft: MCEdit Basics"},{"content":"This is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, Swig’s website for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on Swig\u0026rsquo;s website and a StackOverflow question for Python 3. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\n1. Install # python-dev sudo apt-get install python-dev # python2.x sudo apt-get install python3-dev # python3.x # swig sudo apt-get install swig 2. Source c++ Fibonacci implementation, filename: fib.cpp\n#include \u0026#34;fib.h\u0026#34; int fibonacci(int n) { if(n \u0026lt;= 1) return n; return fibonacci(n-1) + fibonacci(n-2); } c++ fibonacci header file, filename: fib.h. I\u0026rsquo;m going to explain why this file exists in a moment.\nint fibonacci(int n); The next file is the interface file for swig, fib.i. This is telling swig what bindings it will need to create and is why we implemented fib.h.\n%module Fibonacci %{ #include \u0026#34;fib.h\u0026#34; %} %include \u0026#34;fib.h\u0026#34; The alternative to creating the fib.h file is directly below. For this we define each function individually for swig to then bind.\n%module Fibonacci %{ int fibonacci(int n); %} int fibonacci(int n); 3. Build setup.py, this file is taken directly from Swig\u0026rsquo;s documentation and modified slightly.\n#!/usr/bin/env python from distutils.core import setup, Extension fib_module = Extension( \u0026#39;_Fibonacci\u0026#39;, sources=[\u0026#39;fib_wrap.cxx\u0026#39;, \u0026#39;fib.cpp\u0026#39;], # fib_wrap.cxx is going to be generated by swig ) setup ( name = \u0026#39;Fibonacci\u0026#39;, version = \u0026#39;0.0\u0026#39;, author = \u0026#34;YOUR_NAME\u0026#34;, description = \u0026#34;Fibonacci swig\u0026#34;, ext_modules = [fib_module], py_modules = [\u0026#34;Fibonacci\u0026#34;], # name of module that we\u0026#39;re going import ) build.sh or whatever you fancy.\n#!/bin/bash swig -c++ -python fib.i python setup.py build_ext --inplace 4. Run Assign permissions (e.g. chmod 755 build.sh) and run ./build.sh. From there you can go into the python console and test by running the following:\n$ python \u0026gt;\u0026gt;\u0026gt; import Fibonacci \u0026gt;\u0026gt;\u0026gt; Fibonacci.fibonacci(10) 55 5. Conclusion Please let me know if anything here can be improved so I can update this for future readers. Regardless, I hope this helped some of you with your projects/work and saved you some time.\n","permalink":"http://localhost:1313/posts/first/","summary":"\u003cp\u003eThis is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig’s website\u003c/a\u003e for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig\u0026rsquo;s website\u003c/a\u003e and a \u003ca href=\"https://stackoverflow.com/questions/32667888/building-extension-for-python-3-with-swig-and-distutils\"\u003eStackOverflow question for Python 3\u003c/a\u003e. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\u003c/p\u003e","title":"C++ to Python Bindings with Swig"},{"content":"Biemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). Paper\nBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). Paper\nBiemer, C., \u0026amp; Cooper, S. (2022, October). Level Assembly as a Markov Decision Process. In 2022 Proceedings of the Experimental AI in Games Workshop. Paper, Talk, Code\nBiemer, C., \u0026amp; Cooper, S. (2022, August). On Linking Level Segments. In 2022 IEEE Conference on Games (CoG) (pp. 199-205). ★ Best Paper Nominee Paper, Talk, Code\nBiemer, C., Hervella, A., \u0026amp; Cooper, S. (2021, August). Gram-Elites: N-Gram Based Quality-Diversity Search. In The 16th International Conference on the Foundations of Digital Games (FDG) 2021 (pp. 1-6). Paper, Talk, Code\nVillareale, J., Biemer, C., Seif El-Nasr, M., \u0026amp; Zhu, J. (2020, September). Reflection in Game-Based Learning: A Survey of Programming Games. In International Conference on the Foundations of Digital Games (pp. 1-9). Paper\n","permalink":"http://localhost:1313/publications/","summary":"\u003cp\u003eBiemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). \u003cbr\u003e\n\u003ca href=\"/pdf/2024_solution_path_heuristics.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). \u003cbr\u003e\n\u003ca href=\"/pdf/2023_ddaviaplgviamdp.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e","title":"Publications"}]