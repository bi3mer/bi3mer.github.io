[{"content":"Source Control and GitHub GitHub is an awesome website that allows you to have unlimited repositories, for free, that are backed up with git on a remote server. In addition, it provides you with helpful tools like issues that allow you to keep track of bugs, features, and anything else you want. It is not the end all be all of source control and has pros and cons that should be considered before being used.\nFor our use case, github is the perfect option because it is a free service that allows anyone to see our code easily. Other services, are either going to cost money or make it difficult to distribute the code. With that said, we are using version control for more than just visibility. For every project, working with version control is mandatory. If you plan on working with a group, then it provides a single workspace where you don’t have to manage a set of files and combining them. It allows you to revert back if you’ve made a huge mistake. It allows you to experiment on separate branches while not breaking the main branch.\nThe list that I provided is drastically shorter than the whole, but feel free to search google for more examples of why you should use source control. Regardless, please do not make the mistake of thinking that version control is only for group projects. It is for all projects.\nAdding Python as the `.gitignore` file With that said we can now create our repository. To create a github account, go to their create an account page and sign up (it’s free). From there, follow their instructions on creating a repository and make sure to set the dropdown menu “Add .gitignore” to “Python” as seen in figure one. I named my repository UnBlockMeSolver, but any name that is descriptive and follows these guidelines is fine (make sure to avoid special characters like #, %, :, etc.).\nMatrix Board Formats For me, defining a program that is configurable is of the utmost importance. I personally believe it leads to better design and creates more robust programs. When making games, I want to make it so designers can easily change behavior without having to come to me to get the changes in. Usually this means exposing some kind of file that they can modify. The first step in our game’s configurability is to create a file format for defining a board.\nLooking at the requirements we defined in the last post, we know that every piece on the board has a unique identifier. This means '1', 'abc', and 'b' are technically viable piece names. However, I personally would like to exclude the id ‘abc’ if possible. If we restrict an id to having at most one character than we lose some flexibility but have an easier implementation. The flexibility we lose is an, almost, unlimited number of unique identifiers. Instead we will only have approximately 36 ids (26 letters in the alphabet plus 10 numbers of zero to nine). With that said, we technically have more with symbols and special characters but it would be an inconvenience for designers to type out. We can have even more if we include capitals and lower case characters.\nOnly having around 36 items on a board really isn’t going to hinder us. Our initial goal is to work with boards that are 6x6 which is the standard for both Rush Hour and Unblock Me. It is impossible, therefore, for us to have greater than 18 pieces on the board (18 2x1 pieces would perfectly fill the board). Since we know 36 unique identifiers will not hinder us, we now have to ask whether we can see cases in the future where this will change. I personally can see a case where I may want to test on a bigger board, however, I see that future as very unlikely. So, instead I’m going to update the first requirement to be, “The board will be represented by a two dimensional matrix that contains unique character identifiers for each block.\u0026quot;\nWith that update completed, we now to handle the second and third requirements:\nThe board will have a unique identifier which represents the goal. The board will have a unique identifier which represents the red block or main block. We need to define constants for the goal and the the main block. But that is actually incomplete. We also need to define a constant for empty space. In addition, I’ve decided to add some extra complexity to our version by allowing there to be walls. These walls will be unable to move and take up one or more spots.\nwall = \u0026#34;|\u0026#34; goal = \u0026#34;$\u0026#34; empty = \u0026#34;0\u0026#34; playerPiece = \u0026#34;*\u0026#34; These constants could be random characters, but since they will be exposed to designers it is important to make them as easy to understand as possible.\nSample Unblock Me board The last step is to produce a sample map that we can use when testing our parser. To do so, we can copy the map seen in figure two into our format:\n010000 010020 **3020$ 003000 400555 400000 What you probably notice is that our goal is sticking out. This complicates are implementation because we will have unequal dimensions. This now puts us in a situation where can either modify a requirement, again, or update the definition of the matrix to hide this issue.\nUpdating the requirement would likely mean removing the goal from the matrix. Instead we would create a required field where we defined the x and y coordinates of the goal.\n(6,2) 010000 010020 **3020 003000 400555 400000 I personally don’t like this option because it complicates our parsing and sets up weird edge cases where we aren’t technically worried about going out of bounds of the matrix to find the solution for the game.\nAlternatively, we could simply surround the whole matrix with walls. This makes it so we can still define a goal wherever we want and now have a full matrix where special cases are not needed to be handled. With that update we would now have the following matrix in a file:\n|||||||| |010000| |010020| |**3020$ |003000| |400555| |400000| |||||||| Technically, the walls on top can be avoided but I’m imagining cases in the future where we use these walls to help the GUI properly render the board. It may not come into fruition, but it won’t hurt.\nUpdate (2024/11/21) ","permalink":"http://localhost:1313/posts/making-rush-hour-2/","summary":"\u003ch1 id=\"source-control-and-github\"\u003eSource Control and GitHub\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/\"\u003eGitHub\u003c/a\u003e is an awesome website that allows you to have unlimited repositories, for free, that are backed up with \u003ca href=\"https://git-scm.com/\"\u003egit\u003c/a\u003e on a remote server. In addition, it provides you with helpful tools like \u003ca href=\"https://docs.github.com/en/issues/tracking-your-work-with-issues/about-issues\"\u003eissues\u003c/a\u003e that allow you to keep track of bugs, features, and anything else you want. It is not the end all be all of \u003ca href=\"https://aws.amazon.com/devops/source-control/\"\u003esource control\u003c/a\u003e and has \u003ca href=\"https://www.timedoctor.com/blog/git-mecurial-and-cvs-comparison-of-svn-software/\"\u003epros and cons that should be considered\u003c/a\u003e before being used.\u003c/p\u003e","title":"Making Rush Hour 2: Github and Matrix Formats"},{"content":"Introduction Hello, world! I\u0026rsquo;m here again :D\n","permalink":"http://localhost:1313/games/second/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eHello, world! I\u0026rsquo;m here again :D\u003c/p\u003e","title":"Second"},{"content":"This is the first in a series of posts where I discuss implementing a version of Unblock Me and Rush Hour; sample screen shots can be seen in figure one. For the implementation, I’ve decided to use Python 2.7, however, you should be able to follow along with any language. My hope is that each of these posts will be more than just a copy and paste tutorial. To facilitate this, I will be taking deep dives into design decisions, test-driven design, common game AI architecture, general software structure, requirements gathering, servers, and more.\nWhy Python? Choosing a language for a project is one of the most important decisions that you’ll have to make. It will define how you approach problems, what problems you feel comfortable solving, and even how fast your code will execute. For these reasons, and more, it is imperative to choose a language for a better reason than, “It’s my favorite programming language.”\nIronically, one of the main reasons I decided to use python for this project is that it is favorite language. My original goal was to show prospective employers an example project that goes beyond the usual, “I stopped once I got it working.” I wanted to create something that I would feel comfortable showing off not only for the functionality but also the code quality. WIth that in mind, I decided to use python because it would allow me to completely focus on the design and code quality thanks to my level of familiarity with the language.\nIn addition, I knew python would be the best bet in the long run because after implementing the game I intend to look into procedural generation of valid boards and machine learning techniques to generate a valid heuristic for A* pathfinding. Both of these goals are well suited for python and the bonus isomorphism makes a life a tad bit easier in the future.\nRequirements It may seem like common sense, but the most important part in programming is knowing exactly what the end goal is for the project. If you know the end goal, you can quickly program to those exact specifications without worry that something will change midway through. Unfortunately, the reality of software development is that things will change and the program will have to change with them. Therefore, it is necessary to develop fully knowing that code you’ve written yesterday will change to accomodate a new feature or idea. The best way to handle these changes is to design with flexibility in mind. Usually this means expecting the changes before they have been requested.\nThis can lead some to make the program so flexible that becomes unreasonable and out of scope. One particular moment of mine that stands as is when I decided to make a simple chess game. At the start I was programming with the obvious constraint of the board being in two dimensions. But I had a thought that it may be cool to make the game configurable so someone could play in two dimensions or higher. What resulted was a series of headaches and unnecessary pain for a feature that would never be used. Knowing the right kind of flexibility to add when developing software is key and something that comes with time.\nIn our case, we won’t have to worry about a project manager changing requirements midway through the project but we still have to worry about getting a bright idea that can change everything. Therefore, before even writing our first line of code we need to develop a set of requirements that will be true throughout the project. These requirements will define the core of the game.\nThe board will be represented by a two dimensional matrix that contains unique identifiers for each block. The board will have a unique identifier which represents the goal. The board will have a unique identifier which represents the red block or main block. A block that is longer lengthwise than heightwise can only be moved horizontally one space or more. A block that is longer heightwise than lengthwise can only be moved vertically one space or more. A block that is equal in length and height cannot exist. A block can not be moved through another block. Only the main block can take the spot of the goal on the board. The game will end when the player has managed to slide the main block into the goal. This is not a complete set of requirements, for more on this topic you can view BelitSoft\u0026rsquo;s standard, but it does serve as a baseline for future development. Nothing we develop will go against these requirements. More rigorous requirements building in a professional environment is essential because they force everyone to be on the same page for what is going to be built.\nStructuring the Project With our requirements complete, we can now work on defining how we want everything to be structured. The first decision is to figure out a proper file structure knowing we will have one main project with multiple, dependent, side projects. Therefore, a simple flat structure of python files being in the root directory is far too simple for our use case. We want to make everything clear and streamlined so users can easily find what they want.\nThe two popular solutions for this problem are to create separate repositories with submodules to the required repositories or to use a a monolithic repository. The first solution isn’t ideal because it sets up cases where we can make changes to one repository that will force multiple dependent repositories to update. This issue becomes exacerbated when repositories are thrown of sync due to simply forgetting to update. Meaning, the main weakness of this approach is that we have to be hyper vigilant when making changes to any repository. The second option means we will have folders at the root for each part of the project we’ll want to build. This means linking them up may not be ideal. For example, one folder will contain the implementation of the game’s logic where another may be an implementation of the GUI. The GUI will be dependent on the games folder, just like with the submodule approach, and there will have to be a weird import set up to go to the root directory and grab the requirements. However, everything will always be in sync and thorough unit testing will make it clear when something has broken.\nNeither of the two approaches are necessarily better than the other, but I ultimately went with the monolithic approach. The inconvenience of getting imports to work seemed minor to the headaches that would ensue with the submodules approach.\nNext Time Next time, we’ll be starting off with setting up our github repository with our monolithic structure in mind. Once that is complete, we can get the basics of the game working by defining a format for a board that can be read from text files. Lastly, we’ll look into a structure for AI in games and how it will affect our design and implementation.\n","permalink":"http://localhost:1313/posts/making-rush-hour-1/","summary":"\u003cp\u003eThis is the first in a series of posts where I discuss implementing a version of \u003ca href=\"https://apps.apple.com/us/app/unblock-me/id315019111\"\u003eUnblock Me\u003c/a\u003e and \u003ca href=\"https://en.wikipedia.org/wiki/Rush_Hour_(puzzle)\"\u003eRush Hour\u003c/a\u003e; sample screen shots can be seen in figure one. For the implementation, I’ve decided to use Python 2.7, however, you should be able to follow along with any language. My hope is that each of these posts will be more than just a copy and paste tutorial. To facilitate this, I will be taking deep dives into design decisions, test-driven design, common game AI architecture, general software structure, requirements gathering, servers, and more.\u003c/p\u003e","title":"Making Rush Hour 1: Requirements and Basic Structuring"},{"content":"Generative Design in Minecraft (GDMC) GDMC is a competition to generate settlements within a selection of a minecraft map. The project\u0026rsquo;s website provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\nMCEdit To generate settlements, the competition has gone the route of using MCEdit to allow competitors to view, generate, and modify minecraft maps. GDMC provides a wiki with easy to use instructions for installing and general set up. The wiki also provides an example cellular automata script for generating structures seen in figure one. As you can see, the output isn’t great, but it provides a nice starting point. It, also, shows how to work with the MCEdit filters which is how we can interact with the maps.\nFigure 1: Example cellular automata output from CASG_Example.py Filters A filter is how we are able to modify maps. To activate a filter, a user makes a selection on the map via a left click and dragging your mouse. From there, on the bottom of the screen, there is a potion looking icon that when pressed will open the filter menu. This provides a drop down menu of available filters. Each of these filters provides a set of options and the ability to perform their respective actions. When activated they will make modifications to the map given the users selection area. Each of the filters are Python 2.7 scripts located in the stock-filters directory.\nFilter Basics The wiki provides some helpful commentary in getting started with filters, but the script is a bit too complicated for a starting point. There are, however, two things that every filter has in common: the perform function and inputs tuple.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def perform(level, box, options): pass When a filter is activated, the engine will call the perform function and pass the level data (this data structure will be explored further in the next post), the bounding box, and the set of options a user has defined. The bounding box defines the origin of the box the user created and the size. The options is a dictionary based on the inputs defined in the above script. Therefore, to access the materials you could use options[“Material”] to be able to see what the user set.\nBox in all Eight Corners of Selection Now that we understand the basics, we can start with a simple filter. The goal of this filter is to place a user defined material in all eight corners of the user’s selection. The end result can be seen in figure two. The first step here is to define the inputs for the user. In this case, the above inputs code is exactly what we need.\nFigure 2: Example of placing blocks at all eight corners of user\u0026#39;s selection space Now we need to know how to draw a block and this can be found in the utility functions provided by NYU. I haven’t figured out the point of the function setBlockDataAt yet, but in the second post I intend to investigate more to figure it out. In the meantime, I wrote a simpler function because the data was always set to 0 in the examples I could find.\ndef draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) With that complete, the only problem now is figuring out how to use the bounding box to find the eight corners. As noted above, the way the bounding box works is by providing an origin and size vector. All variations of adding these two together will provide eight values which are, coincidentally, the corners of the cube. The full filter can be seen below.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace Eight Corners\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) def perform(level, box, options): material = options[\u0026#34;Material\u0026#34;] draw_block(level, box.origin.x, box.origin.y, box.origin.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y, box.origin.z, material) draw_block(level, box.origin.x, box.origin.y + box.size.y, box.origin.z, material) draw_block(level, box.origin.x, box.origin.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x, box.origin.y + box.size.y, box.origin.z + box.size.z, material) draw_block(level, box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z + box.size.z, material) Fill Selection In comparison to the eight boxes, this is a lot easier conceptually. All we want to do is fill the entire users selection with a material. The end result can be seen in figure three.\nFigure 3: Two examples of filling in users selection with a different materials The setup is exactly the same as last time where you can use the inputs to define the material. We can even use the draw_block function. At this point, it is probably best to create a script that contains common functions that could be useful in the future. From there, we need to create a function fill_box which takes in the level, origin, size, and material. To fill the box, it is as simple as three for loops that go through all possible x, y, and z values. It is important that you loop from the minimum to the maximum of these, else there is a chance you will not completely fill in the box.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from mcplatform import * inputs = ( (\u0026#34;Replace All\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) def fill_box(level, origin, size, material): final_x = origin.x + size.x final_y = origin.y + size.y final_z = origin.z + size.z for x in range(min(origin.x, final_x), max(origin.x, final_x)): for y in range(min(origin.y, final_y), max(origin.y, final_y)): for z in range(min(origin.z, final_z), max(origin.z, final_z)): draw_block(level, x, y, z, material) def perform(level, box, options): fill_box(level, box.origin, box.size, options[\u0026#34;Material\u0026#34;]) Box Outline In this case we want to take the user’s selection and draw blocks along the edges, an example can be seen in figure four. The complexity for this problem is creating a function that will properly draw lines. Specifically, it is necessary to make sure it can draw diagonal lines for the sake of completeness.\nFigure 4: Example of drawing the edges for a user\u0026#39;s selection The main difficulty in this problem is making sure every direction a line can move is accounted for. The list is quite long but mainly requires some attentiveness on our our part when defining all the possibilities.\ndirections = [ (1,0,0),(-1,0,0),(0,1,0),(0,-1,0),(0,0,1),(0,0,-1),\\ (1,1,0),(-1,1,0),(1,-1,0),(-1,-1,0),(0,1,1),(0,-1,1),\\ (0,1,-1),(0,-1,-1),(1,0,1),(-1,0,1),(1,0,-1),(-1,0,-1),\\ (1,1,1),(-1,1,1),(1,-1,1),(1,1,-1),(-1,-1,1),(-1,1,-1),\\ (1,-1,-1),(-1,-1,-1) ] We now have the task of using the directions array to draw the line along the shortest path from the starting point to the end point. I first wrote this with a recursive method, where it would find the point closest, with the manhattan distance, and then draw a block. It would recursively call itself again, drawing a block at the next closest point, until it had reached the end point. Please note that I did not put in object avoidance into this method as it was beyond the scope of the problem. With the recursive method complete, it became clear a while loop would be just as clear with minimal code changes and be more performant since tail recursion is not supported by Python.\nOnce drawing a line was completed, the last step was to use the vertices I defined in the section dedicated to drawing materials in all eight corners to draw the edges as well. The code for the filter is below.\nfrom pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox from pymclevel.box import Vector from mcplatform import * inputs = ( (\u0026#34;Replace All\u0026#34;, \u0026#34;label\u0026#34;), (\u0026#34;Material\u0026#34;, alphaMaterials.CoalBlock), (\u0026#34;Creator: Colan Biemer\u0026#34;, \u0026#34;label\u0026#34;) ) def vector_equals(v1, v2): return v1.x == v2.x and v1.y == v2.y and v1.z == v2.z def manhattan_distance(start, end): return abs(end.x - start.x) + abs(end.y - start.y) + abs(end.z - start.z) def draw_block(level, x, y, z, material): level.setBlockAt(x, y, z, material.ID) level.setBlockDataAt(x, y, z, 0) def draw_block(level, point, material): level.setBlockAt(point.x, point.y, point.z, material.ID) level.setBlockDataAt(point.x, point.y, point.z, 0) def fill_box(level, origin, size, material): final_x = origin.x + size.x final_y = origin.y + size.y final_z = origin.z + size.z for x in range(min(origin.x, final_x), max(origin.x, final_x)): for y in range(min(origin.y, final_y), max(origin.y, final_y)): for z in range(min(origin.z, final_z), max(origin.z, final_z)): draw_block(level, x, y, z, material) def draw_line(level, start, end, material): directions = [(1,0,0),(-1,0,0),(0,1,0),(0,-1,0),(0,0,1),(0,0,-1),\\ (1,1,0),(-1,1,0),(1,-1,0),(-1,-1,0),(0,1,1),(0,-1,1),\\ (0,1,-1),(0,-1,-1),(1,0,1),(-1,0,1),(1,0,-1),(-1,0,-1),\\ (1,1,1),(-1,1,1),(1,-1,1),(1,1,-1),(-1,-1,1),(-1,1,-1),\\ (1,-1,-1),(-1,-1,-1)] draw_block(level, start, material) while not vector_equals(start, end): new_s = start + directions[0] dist = manhattan_distance(start, end) for i in range(1, len(directions)): s = start + directions[i] d = manhattan_distance(s, end) if d \u0026lt; dist: new_s = s dist = d start = new_s draw_block(level, start, material) def draw_box_outline(level, box, material): point_1 = box.origin point_2 = Vector(box.origin.x + box.size.x, box.origin.y, box.origin.z) point_3 = Vector(box.origin.x, box.origin.y + box.size.y, box.origin.z) point_4 = Vector(box.origin.x, box.origin.y, box.origin.z + box.size.z) point_5 = Vector(box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z) point_6 = Vector(box.origin.x + box.size.x, box.origin.y, box.origin.z + box.size.z) point_7 = Vector(box.origin.x, box.origin.y + box.size.y, box.origin.z + box.size.z,) point_8 = Vector(box.origin.x + box.size.x, box.origin.y + box.size.y, box.origin.z + box.size.z) draw_line(level, point_1, point_2, material) draw_line(level, point_1, point_3, material) draw_line(level, point_1, point_4, material) draw_line(level, point_2, point_6, material) draw_line(level, point_4, point_6, material) draw_line(level, point_3, point_7, material) draw_line(level, point_4, point_7, material) draw_line(level, point_7, point_8, material) draw_line(level, point_6, point_8, material) draw_line(level, point_8, point_5, material) draw_line(level, point_5, point_2, material) draw_line(level, point_5, point_3, material) def perform(level, box, options): draw_box_outline(level, box, options[\u0026#34;Material\u0026#34;]) ","permalink":"http://localhost:1313/posts/second/","summary":"\u003ch1 id=\"generative-design-in-minecraft-gdmc\"\u003eGenerative Design in Minecraft (GDMC)\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eGDMC\u003c/a\u003e is a competition to generate settlements within a selection of a minecraft map. The \u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eproject\u0026rsquo;s website\u003c/a\u003e provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\u003c/p\u003e","title":"Generative Design in Mineraft: MCEdit Basics"},{"content":"This is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, Swig’s website for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on Swig\u0026rsquo;s website and a StackOverflow question for Python 3. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\n1. Install # python-dev sudo apt-get install python-dev # python2.x sudo apt-get install python3-dev # python3.x # swig sudo apt-get install swig 2. Source c++ Fibonacci implementation, filename: fib.cpp\n#include \u0026#34;fib.h\u0026#34; int fibonacci(int n) { if(n \u0026lt;= 1) return n; return fibonacci(n-1) + fibonacci(n-2); } c++ fibonacci header file, filename: fib.h. I\u0026rsquo;m going to explain why this file exists in a moment.\nint fibonacci(int n); The next file is the interface file for swig, fib.i. This is telling swig what bindings it will need to create and is why we implemented fib.h.\n%module Fibonacci %{ #include \u0026#34;fib.h\u0026#34; %} %include \u0026#34;fib.h\u0026#34; The alternative to creating the fib.h file is directly below. For this we define each function individually for swig to then bind.\n%module Fibonacci %{ int fibonacci(int n); %} int fibonacci(int n); 3. Build setup.py, this file is taken directly from Swig\u0026rsquo;s documentation and modified slightly.\n#!/usr/bin/env python from distutils.core import setup, Extension fib_module = Extension( \u0026#39;_Fibonacci\u0026#39;, sources=[\u0026#39;fib_wrap.cxx\u0026#39;, \u0026#39;fib.cpp\u0026#39;], # fib_wrap.cxx is going to be generated by swig ) setup ( name = \u0026#39;Fibonacci\u0026#39;, version = \u0026#39;0.0\u0026#39;, author = \u0026#34;YOUR_NAME\u0026#34;, description = \u0026#34;Fibonacci swig\u0026#34;, ext_modules = [fib_module], py_modules = [\u0026#34;Fibonacci\u0026#34;], # name of module that we\u0026#39;re going import ) build.sh or whatever you fancy.\n#!/bin/bash swig -c++ -python fib.i python setup.py build_ext --inplace 4. Run Assign permissions (e.g. chmod 755 build.sh) and run ./build.sh. From there you can go into the python console and test by running the following:\n$ python \u0026gt;\u0026gt;\u0026gt; import Fibonacci \u0026gt;\u0026gt;\u0026gt; Fibonacci.fibonacci(10) 55 5. Conclusion Please let me know if anything here can be improved so I can update this for future readers. Regardless, I hope this helped some of you with your projects/work and saved you some time.\n","permalink":"http://localhost:1313/posts/first/","summary":"\u003cp\u003eThis is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig’s website\u003c/a\u003e for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig\u0026rsquo;s website\u003c/a\u003e and a \u003ca href=\"https://stackoverflow.com/questions/32667888/building-extension-for-python-3-with-swig-and-distutils\"\u003eStackOverflow question for Python 3\u003c/a\u003e. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\u003c/p\u003e","title":"C++ to Python Bindings with Swig"},{"content":"Biemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). Paper\nBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). Paper\nBiemer, C., \u0026amp; Cooper, S. (2022, October). Level Assembly as a Markov Decision Process. In 2022 Proceedings of the Experimental AI in Games Workshop. Paper, Talk, Code\nBiemer, C., \u0026amp; Cooper, S. (2022, August). On Linking Level Segments. In 2022 IEEE Conference on Games (CoG) (pp. 199-205). ★ Best Paper Nominee Paper, Talk, Code\nBiemer, C., Hervella, A., \u0026amp; Cooper, S. (2021, August). Gram-Elites: N-Gram Based Quality-Diversity Search. In The 16th International Conference on the Foundations of Digital Games (FDG) 2021 (pp. 1-6). Paper, Talk, Code\nVillareale, J., Biemer, C., Seif El-Nasr, M., \u0026amp; Zhu, J. (2020, September). Reflection in Game-Based Learning: A Survey of Programming Games. In International Conference on the Foundations of Digital Games (pp. 1-9). Paper\n","permalink":"http://localhost:1313/publications/","summary":"\u003cp\u003eBiemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). \u003cbr\u003e\n\u003ca href=\"/pdf/2024_solution_path_heuristics.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). \u003cbr\u003e\n\u003ca href=\"/pdf/2023_ddaviaplgviamdp.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e","title":"Publications"}]