[{"content":"Introduction Hello, world! I\u0026rsquo;m here again :D\n","permalink":"http://localhost:1313/games/second/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eHello, world! I\u0026rsquo;m here again :D\u003c/p\u003e","title":"Second"},{"content":"Introduction Hello, world! I\u0026rsquo;m here again :D\n","permalink":"http://localhost:1313/posts/second/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eHello, world! I\u0026rsquo;m here again :D\u003c/p\u003e","title":"Second"},{"content":"This is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, Swig’s website for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on Swig\u0026rsquo;s website and a StackOverflow question for Python 3. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\n1. Install # python-dev sudo apt-get install python-dev # python2.x sudo apt-get install python3-dev # python3.x # swig sudo apt-get install swig 2. Source c++ Fibonacci implementation, filename: fib.cpp\n#include \u0026#34;fib.h\u0026#34; int fibonacci(int n) { if(n \u0026lt;= 1) return n; return fibonacci(n-1) + fibonacci(n-2); } c++ fibonacci header file, filename: fib.h. I\u0026rsquo;m going to explain why this file exists in a moment.\nint fibonacci(int n); The next file is the interface file for swig, fib.i. This is telling swig what bindings it will need to create and is why we implemented fib.h.\n%module Fibonacci %{ #include \u0026#34;fib.h\u0026#34; %} %include \u0026#34;fib.h\u0026#34; The alternative to creating the fib.h file is directly below. For this we define each function individually for swig to then bind.\n%module Fibonacci %{ int fibonacci(int n); %} int fibonacci(int n); 3. Build setup.py, this file is taken directly from Swig\u0026rsquo;s documentation and modified slightly.\n#!/usr/bin/env python from distutils.core import setup, Extension fib_module = Extension( \u0026#39;_Fibonacci\u0026#39;, sources=[\u0026#39;fib_wrap.cxx\u0026#39;, \u0026#39;fib.cpp\u0026#39;], # fib_wrap.cxx is going to be generated by swig ) setup ( name = \u0026#39;Fibonacci\u0026#39;, version = \u0026#39;0.0\u0026#39;, author = \u0026#34;YOUR_NAME\u0026#34;, description = \u0026#34;Fibonacci swig\u0026#34;, ext_modules = [fib_module], py_modules = [\u0026#34;Fibonacci\u0026#34;], # name of module that we\u0026#39;re going import ) build.sh or whatever you fancy.\n#!/bin/bash swig -c++ -python fib.i python setup.py build_ext --inplace 4. Run Assign permissions (e.g. chmod 755 build.sh) and run ./build.sh. From there you can go into the python console and test by running the following:\n$ python \u0026gt;\u0026gt;\u0026gt; import Fibonacci \u0026gt;\u0026gt;\u0026gt; Fibonacci.fibonacci(10) 55 5. Conclusion Please let me know if anything here can be improved so I can update this for future readers. Regardless, I hope this helped some of you with your projects/work and saved you some time.\n","permalink":"http://localhost:1313/posts/first/","summary":"\u003cp\u003eThis is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig’s website\u003c/a\u003e for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig\u0026rsquo;s website\u003c/a\u003e and a \u003ca href=\"https://stackoverflow.com/questions/32667888/building-extension-for-python-3-with-swig-and-distutils\"\u003eStackOverflow question for Python 3\u003c/a\u003e. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\u003c/p\u003e","title":"C++ to Python Bindings with Swig"},{"content":"Biemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). Paper\nBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). Paper\nBiemer, C., \u0026amp; Cooper, S. (2022, October). Level Assembly as a Markov Decision Process. In 2022 Proceedings of the Experimental AI in Games Workshop. Paper, Talk, Code\nBiemer, C., \u0026amp; Cooper, S. (2022, August). On Linking Level Segments. In 2022 IEEE Conference on Games (CoG) (pp. 199-205). ★ Best Paper Nominee Paper, Talk, Code\nBiemer, C., Hervella, A., \u0026amp; Cooper, S. (2021, August). Gram-Elites: N-Gram Based Quality-Diversity Search. In The 16th International Conference on the Foundations of Digital Games (FDG) 2021 (pp. 1-6). Paper, Talk, Code\nVillareale, J., Biemer, C., Seif El-Nasr, M., \u0026amp; Zhu, J. (2020, September). Reflection in Game-Based Learning: A Survey of Programming Games. In International Conference on the Foundations of Digital Games (pp. 1-9). Paper\n","permalink":"http://localhost:1313/publications/","summary":"\u003cp\u003eBiemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). \u003cbr\u003e\n\u003ca href=\"/pdf/2024_solution_path_heuristics.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). \u003cbr\u003e\n\u003ca href=\"/pdf/2023_ddaviaplgviamdp.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e","title":"Publications"},{"content":"Introduction Hello, world! I\u0026rsquo;m here again :D\n","permalink":"http://localhost:1313/games/second/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eHello, world! I\u0026rsquo;m here again :D\u003c/p\u003e","title":"Second"},{"content":"Generative Design in Minecraft (GDMC) GDMC is a competition to generate settlements within a selection of a minecraft map. The project\u0026rsquo;s website provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\nMCEdit To generate settlements, the competition has gone the route of using MCEdit to allow competitors to view, generate, and modify minecraft maps. GDMC provides a wiki with easy to use instructions for installing and general set up. The wiki also provides an example cellular automata script for generating structures seen in figure one. As you can see, the output isn’t great, but it provides a nice starting point. It, also, shows how to work with the MCEdit filters which is how we can interact with the maps.\nFigure 1: Example cellular automata output from CASG_Example.py ","permalink":"http://localhost:1313/posts/second/","summary":"\u003ch1 id=\"generative-design-in-minecraft-gdmc\"\u003eGenerative Design in Minecraft (GDMC)\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eGDMC\u003c/a\u003e is a competition to generate settlements within a selection of a minecraft map. The \u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eproject\u0026rsquo;s website\u003c/a\u003e provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\u003c/p\u003e","title":"Generative Design in Mineraft: MCEdit Basics"},{"content":"This is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, Swig’s website for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on Swig\u0026rsquo;s website and a StackOverflow question for Python 3. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\n1. Install # python-dev sudo apt-get install python-dev # python2.x sudo apt-get install python3-dev # python3.x # swig sudo apt-get install swig 2. Source c++ Fibonacci implementation, filename: fib.cpp\n#include \u0026#34;fib.h\u0026#34; int fibonacci(int n) { if(n \u0026lt;= 1) return n; return fibonacci(n-1) + fibonacci(n-2); } c++ fibonacci header file, filename: fib.h. I\u0026rsquo;m going to explain why this file exists in a moment.\nint fibonacci(int n); The next file is the interface file for swig, fib.i. This is telling swig what bindings it will need to create and is why we implemented fib.h.\n%module Fibonacci %{ #include \u0026#34;fib.h\u0026#34; %} %include \u0026#34;fib.h\u0026#34; The alternative to creating the fib.h file is directly below. For this we define each function individually for swig to then bind.\n%module Fibonacci %{ int fibonacci(int n); %} int fibonacci(int n); 3. Build setup.py, this file is taken directly from Swig\u0026rsquo;s documentation and modified slightly.\n#!/usr/bin/env python from distutils.core import setup, Extension fib_module = Extension( \u0026#39;_Fibonacci\u0026#39;, sources=[\u0026#39;fib_wrap.cxx\u0026#39;, \u0026#39;fib.cpp\u0026#39;], # fib_wrap.cxx is going to be generated by swig ) setup ( name = \u0026#39;Fibonacci\u0026#39;, version = \u0026#39;0.0\u0026#39;, author = \u0026#34;YOUR_NAME\u0026#34;, description = \u0026#34;Fibonacci swig\u0026#34;, ext_modules = [fib_module], py_modules = [\u0026#34;Fibonacci\u0026#34;], # name of module that we\u0026#39;re going import ) build.sh or whatever you fancy.\n#!/bin/bash swig -c++ -python fib.i python setup.py build_ext --inplace 4. Run Assign permissions (e.g. chmod 755 build.sh) and run ./build.sh. From there you can go into the python console and test by running the following:\n$ python \u0026gt;\u0026gt;\u0026gt; import Fibonacci \u0026gt;\u0026gt;\u0026gt; Fibonacci.fibonacci(10) 55 5. Conclusion Please let me know if anything here can be improved so I can update this for future readers. Regardless, I hope this helped some of you with your projects/work and saved you some time.\n","permalink":"http://localhost:1313/posts/first/","summary":"\u003cp\u003eThis is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig’s website\u003c/a\u003e for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig\u0026rsquo;s website\u003c/a\u003e and a \u003ca href=\"https://stackoverflow.com/questions/32667888/building-extension-for-python-3-with-swig-and-distutils\"\u003eStackOverflow question for Python 3\u003c/a\u003e. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\u003c/p\u003e","title":"C++ to Python Bindings with Swig"},{"content":"Biemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). Paper\nBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). Paper\nBiemer, C., \u0026amp; Cooper, S. (2022, October). Level Assembly as a Markov Decision Process. In 2022 Proceedings of the Experimental AI in Games Workshop. Paper, Talk, Code\nBiemer, C., \u0026amp; Cooper, S. (2022, August). On Linking Level Segments. In 2022 IEEE Conference on Games (CoG) (pp. 199-205). ★ Best Paper Nominee Paper, Talk, Code\nBiemer, C., Hervella, A., \u0026amp; Cooper, S. (2021, August). Gram-Elites: N-Gram Based Quality-Diversity Search. In The 16th International Conference on the Foundations of Digital Games (FDG) 2021 (pp. 1-6). Paper, Talk, Code\nVillareale, J., Biemer, C., Seif El-Nasr, M., \u0026amp; Zhu, J. (2020, September). Reflection in Game-Based Learning: A Survey of Programming Games. In International Conference on the Foundations of Digital Games (pp. 1-9). Paper\n","permalink":"http://localhost:1313/publications/","summary":"\u003cp\u003eBiemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). \u003cbr\u003e\n\u003ca href=\"/pdf/2024_solution_path_heuristics.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). \u003cbr\u003e\n\u003ca href=\"/pdf/2023_ddaviaplgviamdp.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e","title":"Publications"},{"content":"Introduction Hello, world! I\u0026rsquo;m here again :D\n","permalink":"http://localhost:1313/games/second/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eHello, world! I\u0026rsquo;m here again :D\u003c/p\u003e","title":"Second"},{"content":"Generative Design in Minecraft (GDMC) GDMC is a competition to generate settlements within a selection of a minecraft map. The project\u0026rsquo;s website provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\nMCEdit To generate settlements, the competition has gone the route of using MCEdit to allow competitors to view, generate, and modify minecraft maps. GDMC provides a wiki with easy to use instructions for installing and general set up. The wiki also provides an example cellular automata script for generating structures seen in figure one. As you can see, the output isn’t great, but it provides a nice starting point. It, also, shows how to work with the MCEdit filters which is how we can interact with the maps.\nFigure 1: Example cellular automata output from CASG_Example.py ","permalink":"http://localhost:1313/posts/second/","summary":"\u003ch1 id=\"generative-design-in-minecraft-gdmc\"\u003eGenerative Design in Minecraft (GDMC)\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eGDMC\u003c/a\u003e is a competition to generate settlements within a selection of a minecraft map. The \u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eproject\u0026rsquo;s website\u003c/a\u003e provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\u003c/p\u003e","title":"Generative Design in Mineraft: MCEdit Basics"},{"content":"This is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, Swig’s website for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on Swig\u0026rsquo;s website and a StackOverflow question for Python 3. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\n1. Install # python-dev sudo apt-get install python-dev # python2.x sudo apt-get install python3-dev # python3.x # swig sudo apt-get install swig 2. Source c++ Fibonacci implementation, filename: fib.cpp\n#include \u0026#34;fib.h\u0026#34; int fibonacci(int n) { if(n \u0026lt;= 1) return n; return fibonacci(n-1) + fibonacci(n-2); } c++ fibonacci header file, filename: fib.h. I\u0026rsquo;m going to explain why this file exists in a moment.\nint fibonacci(int n); The next file is the interface file for swig, fib.i. This is telling swig what bindings it will need to create and is why we implemented fib.h.\n%module Fibonacci %{ #include \u0026#34;fib.h\u0026#34; %} %include \u0026#34;fib.h\u0026#34; The alternative to creating the fib.h file is directly below. For this we define each function individually for swig to then bind.\n%module Fibonacci %{ int fibonacci(int n); %} int fibonacci(int n); 3. Build setup.py, this file is taken directly from Swig\u0026rsquo;s documentation and modified slightly.\n#!/usr/bin/env python from distutils.core import setup, Extension fib_module = Extension( \u0026#39;_Fibonacci\u0026#39;, sources=[\u0026#39;fib_wrap.cxx\u0026#39;, \u0026#39;fib.cpp\u0026#39;], # fib_wrap.cxx is going to be generated by swig ) setup ( name = \u0026#39;Fibonacci\u0026#39;, version = \u0026#39;0.0\u0026#39;, author = \u0026#34;YOUR_NAME\u0026#34;, description = \u0026#34;Fibonacci swig\u0026#34;, ext_modules = [fib_module], py_modules = [\u0026#34;Fibonacci\u0026#34;], # name of module that we\u0026#39;re going import ) build.sh or whatever you fancy.\n#!/bin/bash swig -c++ -python fib.i python setup.py build_ext --inplace 4. Run Assign permissions (e.g. chmod 755 build.sh) and run ./build.sh. From there you can go into the python console and test by running the following:\n$ python \u0026gt;\u0026gt;\u0026gt; import Fibonacci \u0026gt;\u0026gt;\u0026gt; Fibonacci.fibonacci(10) 55 5. Conclusion Please let me know if anything here can be improved so I can update this for future readers. Regardless, I hope this helped some of you with your projects/work and saved you some time.\n","permalink":"http://localhost:1313/posts/first/","summary":"\u003cp\u003eThis is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig’s website\u003c/a\u003e for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig\u0026rsquo;s website\u003c/a\u003e and a \u003ca href=\"https://stackoverflow.com/questions/32667888/building-extension-for-python-3-with-swig-and-distutils\"\u003eStackOverflow question for Python 3\u003c/a\u003e. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\u003c/p\u003e","title":"C++ to Python Bindings with Swig"},{"content":"Biemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). Paper\nBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). Paper\nBiemer, C., \u0026amp; Cooper, S. (2022, October). Level Assembly as a Markov Decision Process. In 2022 Proceedings of the Experimental AI in Games Workshop. Paper, Talk, Code\nBiemer, C., \u0026amp; Cooper, S. (2022, August). On Linking Level Segments. In 2022 IEEE Conference on Games (CoG) (pp. 199-205). ★ Best Paper Nominee Paper, Talk, Code\nBiemer, C., Hervella, A., \u0026amp; Cooper, S. (2021, August). Gram-Elites: N-Gram Based Quality-Diversity Search. In The 16th International Conference on the Foundations of Digital Games (FDG) 2021 (pp. 1-6). Paper, Talk, Code\nVillareale, J., Biemer, C., Seif El-Nasr, M., \u0026amp; Zhu, J. (2020, September). Reflection in Game-Based Learning: A Survey of Programming Games. In International Conference on the Foundations of Digital Games (pp. 1-9). Paper\n","permalink":"http://localhost:1313/publications/","summary":"\u003cp\u003eBiemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). \u003cbr\u003e\n\u003ca href=\"/pdf/2024_solution_path_heuristics.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). \u003cbr\u003e\n\u003ca href=\"/pdf/2023_ddaviaplgviamdp.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e","title":"Publications"},{"content":"Introduction Hello, world! I\u0026rsquo;m here again :D\n","permalink":"http://localhost:1313/games/second/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eHello, world! I\u0026rsquo;m here again :D\u003c/p\u003e","title":"Second"},{"content":"Generative Design in Minecraft (GDMC) GDMC is a competition to generate settlements within a selection of a minecraft map. The project\u0026rsquo;s website provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\nMCEdit To generate settlements, the competition has gone the route of using MCEdit to allow competitors to view, generate, and modify minecraft maps. GDMC provides a wiki with easy to use instructions for installing and general set up. The wiki also provides an example cellular automata script for generating structures seen in figure one. As you can see, the output isn’t great, but it provides a nice starting point. It, also, shows how to work with the MCEdit filters which is how we can interact with the maps.\nFigure 1: Example cellular automata output from CASG_Example.py ","permalink":"http://localhost:1313/posts/second/","summary":"\u003ch1 id=\"generative-design-in-minecraft-gdmc\"\u003eGenerative Design in Minecraft (GDMC)\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eGDMC\u003c/a\u003e is a competition to generate settlements within a selection of a minecraft map. The \u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eproject\u0026rsquo;s website\u003c/a\u003e provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\u003c/p\u003e","title":"Generative Design in Mineraft: MCEdit Basics"},{"content":"This is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, Swig’s website for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on Swig\u0026rsquo;s website and a StackOverflow question for Python 3. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\n1. Install # python-dev sudo apt-get install python-dev # python2.x sudo apt-get install python3-dev # python3.x # swig sudo apt-get install swig 2. Source c++ Fibonacci implementation, filename: fib.cpp\n#include \u0026#34;fib.h\u0026#34; int fibonacci(int n) { if(n \u0026lt;= 1) return n; return fibonacci(n-1) + fibonacci(n-2); } c++ fibonacci header file, filename: fib.h. I\u0026rsquo;m going to explain why this file exists in a moment.\nint fibonacci(int n); The next file is the interface file for swig, fib.i. This is telling swig what bindings it will need to create and is why we implemented fib.h.\n%module Fibonacci %{ #include \u0026#34;fib.h\u0026#34; %} %include \u0026#34;fib.h\u0026#34; The alternative to creating the fib.h file is directly below. For this we define each function individually for swig to then bind.\n%module Fibonacci %{ int fibonacci(int n); %} int fibonacci(int n); 3. Build setup.py, this file is taken directly from Swig\u0026rsquo;s documentation and modified slightly.\n#!/usr/bin/env python from distutils.core import setup, Extension fib_module = Extension( \u0026#39;_Fibonacci\u0026#39;, sources=[\u0026#39;fib_wrap.cxx\u0026#39;, \u0026#39;fib.cpp\u0026#39;], # fib_wrap.cxx is going to be generated by swig ) setup ( name = \u0026#39;Fibonacci\u0026#39;, version = \u0026#39;0.0\u0026#39;, author = \u0026#34;YOUR_NAME\u0026#34;, description = \u0026#34;Fibonacci swig\u0026#34;, ext_modules = [fib_module], py_modules = [\u0026#34;Fibonacci\u0026#34;], # name of module that we\u0026#39;re going import ) build.sh or whatever you fancy.\n#!/bin/bash swig -c++ -python fib.i python setup.py build_ext --inplace 4. Run Assign permissions (e.g. chmod 755 build.sh) and run ./build.sh. From there you can go into the python console and test by running the following:\n$ python \u0026gt;\u0026gt;\u0026gt; import Fibonacci \u0026gt;\u0026gt;\u0026gt; Fibonacci.fibonacci(10) 55 5. Conclusion Please let me know if anything here can be improved so I can update this for future readers. Regardless, I hope this helped some of you with your projects/work and saved you some time.\n","permalink":"http://localhost:1313/posts/first/","summary":"\u003cp\u003eThis is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig’s website\u003c/a\u003e for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig\u0026rsquo;s website\u003c/a\u003e and a \u003ca href=\"https://stackoverflow.com/questions/32667888/building-extension-for-python-3-with-swig-and-distutils\"\u003eStackOverflow question for Python 3\u003c/a\u003e. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\u003c/p\u003e","title":"C++ to Python Bindings with Swig"},{"content":"Biemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). Paper\nBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). Paper\nBiemer, C., \u0026amp; Cooper, S. (2022, October). Level Assembly as a Markov Decision Process. In 2022 Proceedings of the Experimental AI in Games Workshop. Paper, Talk, Code\nBiemer, C., \u0026amp; Cooper, S. (2022, August). On Linking Level Segments. In 2022 IEEE Conference on Games (CoG) (pp. 199-205). ★ Best Paper Nominee Paper, Talk, Code\nBiemer, C., Hervella, A., \u0026amp; Cooper, S. (2021, August). Gram-Elites: N-Gram Based Quality-Diversity Search. In The 16th International Conference on the Foundations of Digital Games (FDG) 2021 (pp. 1-6). Paper, Talk, Code\nVillareale, J., Biemer, C., Seif El-Nasr, M., \u0026amp; Zhu, J. (2020, September). Reflection in Game-Based Learning: A Survey of Programming Games. In International Conference on the Foundations of Digital Games (pp. 1-9). Paper\n","permalink":"http://localhost:1313/publications/","summary":"\u003cp\u003eBiemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). \u003cbr\u003e\n\u003ca href=\"/pdf/2024_solution_path_heuristics.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). \u003cbr\u003e\n\u003ca href=\"/pdf/2023_ddaviaplgviamdp.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e","title":"Publications"},{"content":"Introduction Hello, world! I\u0026rsquo;m here again :D\n","permalink":"http://localhost:1313/games/second/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eHello, world! I\u0026rsquo;m here again :D\u003c/p\u003e","title":"Second"},{"content":"Generative Design in Minecraft (GDMC) GDMC is a competition to generate settlements within a selection of a minecraft map. The project\u0026rsquo;s website provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\nMCEdit To generate settlements, the competition has gone the route of using MCEdit to allow competitors to view, generate, and modify minecraft maps. GDMC provides a wiki with easy to use instructions for installing and general set up. The wiki also provides an example cellular automata script for generating structures seen in figure one. As you can see, the output isn’t great, but it provides a nice starting point. It, also, shows how to work with the MCEdit filters which is how we can interact with the maps.\nFigure 1: Example cellular automata output from CASG_Example.py ","permalink":"http://localhost:1313/posts/second/","summary":"\u003ch1 id=\"generative-design-in-minecraft-gdmc\"\u003eGenerative Design in Minecraft (GDMC)\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eGDMC\u003c/a\u003e is a competition to generate settlements within a selection of a minecraft map. The \u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eproject\u0026rsquo;s website\u003c/a\u003e provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\u003c/p\u003e","title":"Generative Design in Mineraft: MCEdit Basics"},{"content":"This is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, Swig’s website for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on Swig\u0026rsquo;s website and a StackOverflow question for Python 3. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\n1. Install # python-dev sudo apt-get install python-dev # python2.x sudo apt-get install python3-dev # python3.x # swig sudo apt-get install swig 2. Source c++ Fibonacci implementation, filename: fib.cpp\n#include \u0026#34;fib.h\u0026#34; int fibonacci(int n) { if(n \u0026lt;= 1) return n; return fibonacci(n-1) + fibonacci(n-2); } c++ fibonacci header file, filename: fib.h. I\u0026rsquo;m going to explain why this file exists in a moment.\nint fibonacci(int n); The next file is the interface file for swig, fib.i. This is telling swig what bindings it will need to create and is why we implemented fib.h.\n%module Fibonacci %{ #include \u0026#34;fib.h\u0026#34; %} %include \u0026#34;fib.h\u0026#34; The alternative to creating the fib.h file is directly below. For this we define each function individually for swig to then bind.\n%module Fibonacci %{ int fibonacci(int n); %} int fibonacci(int n); 3. Build setup.py, this file is taken directly from Swig\u0026rsquo;s documentation and modified slightly.\n#!/usr/bin/env python from distutils.core import setup, Extension fib_module = Extension( \u0026#39;_Fibonacci\u0026#39;, sources=[\u0026#39;fib_wrap.cxx\u0026#39;, \u0026#39;fib.cpp\u0026#39;], # fib_wrap.cxx is going to be generated by swig ) setup ( name = \u0026#39;Fibonacci\u0026#39;, version = \u0026#39;0.0\u0026#39;, author = \u0026#34;YOUR_NAME\u0026#34;, description = \u0026#34;Fibonacci swig\u0026#34;, ext_modules = [fib_module], py_modules = [\u0026#34;Fibonacci\u0026#34;], # name of module that we\u0026#39;re going import ) build.sh or whatever you fancy.\n#!/bin/bash swig -c++ -python fib.i python setup.py build_ext --inplace 4. Run Assign permissions (e.g. chmod 755 build.sh) and run ./build.sh. From there you can go into the python console and test by running the following:\n$ python \u0026gt;\u0026gt;\u0026gt; import Fibonacci \u0026gt;\u0026gt;\u0026gt; Fibonacci.fibonacci(10) 55 5. Conclusion Please let me know if anything here can be improved so I can update this for future readers. Regardless, I hope this helped some of you with your projects/work and saved you some time.\n","permalink":"http://localhost:1313/posts/first/","summary":"\u003cp\u003eThis is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig’s website\u003c/a\u003e for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig\u0026rsquo;s website\u003c/a\u003e and a \u003ca href=\"https://stackoverflow.com/questions/32667888/building-extension-for-python-3-with-swig-and-distutils\"\u003eStackOverflow question for Python 3\u003c/a\u003e. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\u003c/p\u003e","title":"C++ to Python Bindings with Swig"},{"content":"Biemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). Paper\nBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). Paper\nBiemer, C., \u0026amp; Cooper, S. (2022, October). Level Assembly as a Markov Decision Process. In 2022 Proceedings of the Experimental AI in Games Workshop. Paper, Talk, Code\nBiemer, C., \u0026amp; Cooper, S. (2022, August). On Linking Level Segments. In 2022 IEEE Conference on Games (CoG) (pp. 199-205). ★ Best Paper Nominee Paper, Talk, Code\nBiemer, C., Hervella, A., \u0026amp; Cooper, S. (2021, August). Gram-Elites: N-Gram Based Quality-Diversity Search. In The 16th International Conference on the Foundations of Digital Games (FDG) 2021 (pp. 1-6). Paper, Talk, Code\nVillareale, J., Biemer, C., Seif El-Nasr, M., \u0026amp; Zhu, J. (2020, September). Reflection in Game-Based Learning: A Survey of Programming Games. In International Conference on the Foundations of Digital Games (pp. 1-9). Paper\n","permalink":"http://localhost:1313/publications/","summary":"\u003cp\u003eBiemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). \u003cbr\u003e\n\u003ca href=\"/pdf/2024_solution_path_heuristics.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). \u003cbr\u003e\n\u003ca href=\"/pdf/2023_ddaviaplgviamdp.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e","title":"Publications"},{"content":"Introduction Hello, world! I\u0026rsquo;m here again :D\n","permalink":"http://localhost:1313/games/second/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eHello, world! I\u0026rsquo;m here again :D\u003c/p\u003e","title":"Second"},{"content":"Generative Design in Minecraft (GDMC) GDMC is a competition to generate settlements within a selection of a minecraft map. The project\u0026rsquo;s website provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\nMCEdit To generate settlements, the competition has gone the route of using MCEdit to allow competitors to view, generate, and modify minecraft maps. GDMC provides a wiki with easy to use instructions for installing and general set up. The wiki also provides an example cellular automata script for generating structures seen in figure one. As you can see, the output isn’t great, but it provides a nice starting point. It, also, shows how to work with the MCEdit filters which is how we can interact with the maps.\nFigure 1: Example cellular automata output from CASG_Example.py ","permalink":"http://localhost:1313/posts/second/","summary":"\u003ch1 id=\"generative-design-in-minecraft-gdmc\"\u003eGenerative Design in Minecraft (GDMC)\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eGDMC\u003c/a\u003e is a competition to generate settlements within a selection of a minecraft map. The \u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eproject\u0026rsquo;s website\u003c/a\u003e provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\u003c/p\u003e","title":"Generative Design in Mineraft: MCEdit Basics"},{"content":"This is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, Swig’s website for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on Swig\u0026rsquo;s website and a StackOverflow question for Python 3. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\n1. Install # python-dev sudo apt-get install python-dev # python2.x sudo apt-get install python3-dev # python3.x # swig sudo apt-get install swig 2. Source c++ Fibonacci implementation, filename: fib.cpp\n#include \u0026#34;fib.h\u0026#34; int fibonacci(int n) { if(n \u0026lt;= 1) return n; return fibonacci(n-1) + fibonacci(n-2); } c++ fibonacci header file, filename: fib.h. I\u0026rsquo;m going to explain why this file exists in a moment.\nint fibonacci(int n); The next file is the interface file for swig, fib.i. This is telling swig what bindings it will need to create and is why we implemented fib.h.\n%module Fibonacci %{ #include \u0026#34;fib.h\u0026#34; %} %include \u0026#34;fib.h\u0026#34; The alternative to creating the fib.h file is directly below. For this we define each function individually for swig to then bind.\n%module Fibonacci %{ int fibonacci(int n); %} int fibonacci(int n); 3. Build setup.py, this file is taken directly from Swig\u0026rsquo;s documentation and modified slightly.\n#!/usr/bin/env python from distutils.core import setup, Extension fib_module = Extension( \u0026#39;_Fibonacci\u0026#39;, sources=[\u0026#39;fib_wrap.cxx\u0026#39;, \u0026#39;fib.cpp\u0026#39;], # fib_wrap.cxx is going to be generated by swig ) setup ( name = \u0026#39;Fibonacci\u0026#39;, version = \u0026#39;0.0\u0026#39;, author = \u0026#34;YOUR_NAME\u0026#34;, description = \u0026#34;Fibonacci swig\u0026#34;, ext_modules = [fib_module], py_modules = [\u0026#34;Fibonacci\u0026#34;], # name of module that we\u0026#39;re going import ) build.sh or whatever you fancy.\n#!/bin/bash swig -c++ -python fib.i python setup.py build_ext --inplace 4. Run Assign permissions (e.g. chmod 755 build.sh) and run ./build.sh. From there you can go into the python console and test by running the following:\n$ python \u0026gt;\u0026gt;\u0026gt; import Fibonacci \u0026gt;\u0026gt;\u0026gt; Fibonacci.fibonacci(10) 55 5. Conclusion Please let me know if anything here can be improved so I can update this for future readers. Regardless, I hope this helped some of you with your projects/work and saved you some time.\n","permalink":"http://localhost:1313/posts/first/","summary":"\u003cp\u003eThis is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig’s website\u003c/a\u003e for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig\u0026rsquo;s website\u003c/a\u003e and a \u003ca href=\"https://stackoverflow.com/questions/32667888/building-extension-for-python-3-with-swig-and-distutils\"\u003eStackOverflow question for Python 3\u003c/a\u003e. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\u003c/p\u003e","title":"C++ to Python Bindings with Swig"},{"content":"Biemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). Paper\nBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). Paper\nBiemer, C., \u0026amp; Cooper, S. (2022, October). Level Assembly as a Markov Decision Process. In 2022 Proceedings of the Experimental AI in Games Workshop. Paper, Talk, Code\nBiemer, C., \u0026amp; Cooper, S. (2022, August). On Linking Level Segments. In 2022 IEEE Conference on Games (CoG) (pp. 199-205). ★ Best Paper Nominee Paper, Talk, Code\nBiemer, C., Hervella, A., \u0026amp; Cooper, S. (2021, August). Gram-Elites: N-Gram Based Quality-Diversity Search. In The 16th International Conference on the Foundations of Digital Games (FDG) 2021 (pp. 1-6). Paper, Talk, Code\nVillareale, J., Biemer, C., Seif El-Nasr, M., \u0026amp; Zhu, J. (2020, September). Reflection in Game-Based Learning: A Survey of Programming Games. In International Conference on the Foundations of Digital Games (pp. 1-9). Paper\n","permalink":"http://localhost:1313/publications/","summary":"\u003cp\u003eBiemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). \u003cbr\u003e\n\u003ca href=\"/pdf/2024_solution_path_heuristics.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). \u003cbr\u003e\n\u003ca href=\"/pdf/2023_ddaviaplgviamdp.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e","title":"Publications"},{"content":"Introduction Hello, world! I\u0026rsquo;m here again :D\n","permalink":"http://localhost:1313/games/second/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eHello, world! I\u0026rsquo;m here again :D\u003c/p\u003e","title":"Second"},{"content":"Generative Design in Minecraft (GDMC) GDMC is a competition to generate settlements within a selection of a minecraft map. The project\u0026rsquo;s website provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\nMCEdit To generate settlements, the competition has gone the route of using MCEdit to allow competitors to view, generate, and modify minecraft maps. GDMC provides a wiki with easy to use instructions for installing and general set up. The wiki also provides an example cellular automata script for generating structures seen in figure one. As you can see, the output isn’t great, but it provides a nice starting point. It, also, shows how to work with the MCEdit filters which is how we can interact with the maps.\nFigure 1: Example cellular automata output from CASG_Example.py ","permalink":"http://localhost:1313/posts/second/","summary":"\u003ch1 id=\"generative-design-in-minecraft-gdmc\"\u003eGenerative Design in Minecraft (GDMC)\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eGDMC\u003c/a\u003e is a competition to generate settlements within a selection of a minecraft map. The \u003ca href=\"http://gendesignmc.engineering.nyu.edu/\"\u003eproject\u0026rsquo;s website\u003c/a\u003e provides details on how the competition works and what is expected. However, the main point to get across right now is that they are judging based on adaptability, functionality, narrative, and aesthetics. Adaptability is about the generation technique working with the map rather than ignoring it. An example of ignoring the environment would be generating a wooden village where there are no trees. The functionality component is based on real world criteria such as access to food, defenses, etc. The narrative component is about how every area has a story to tell. An example is a castle with part of the tower knocked down. Lastly, aesthetics is about how it looks both in terms of believability and general appeal.\u003c/p\u003e","title":"Generative Design in Mineraft: MCEdit Basics"},{"content":"This is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, Swig’s website for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on Swig\u0026rsquo;s website and a StackOverflow question for Python 3. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\n1. Install # python-dev sudo apt-get install python-dev # python2.x sudo apt-get install python3-dev # python3.x # swig sudo apt-get install swig 2. Source c++ Fibonacci implementation, filename: fib.cpp\n#include \u0026#34;fib.h\u0026#34; int fibonacci(int n) { if(n \u0026lt;= 1) return n; return fibonacci(n-1) + fibonacci(n-2); } c++ fibonacci header file, filename: fib.h. I\u0026rsquo;m going to explain why this file exists in a moment.\nint fibonacci(int n); The next file is the interface file for swig, fib.i. This is telling swig what bindings it will need to create and is why we implemented fib.h.\n%module Fibonacci %{ #include \u0026#34;fib.h\u0026#34; %} %include \u0026#34;fib.h\u0026#34; The alternative to creating the fib.h file is directly below. For this we define each function individually for swig to then bind.\n%module Fibonacci %{ int fibonacci(int n); %} int fibonacci(int n); 3. Build setup.py, this file is taken directly from Swig\u0026rsquo;s documentation and modified slightly.\n#!/usr/bin/env python from distutils.core import setup, Extension fib_module = Extension( \u0026#39;_Fibonacci\u0026#39;, sources=[\u0026#39;fib_wrap.cxx\u0026#39;, \u0026#39;fib.cpp\u0026#39;], # fib_wrap.cxx is going to be generated by swig ) setup ( name = \u0026#39;Fibonacci\u0026#39;, version = \u0026#39;0.0\u0026#39;, author = \u0026#34;YOUR_NAME\u0026#34;, description = \u0026#34;Fibonacci swig\u0026#34;, ext_modules = [fib_module], py_modules = [\u0026#34;Fibonacci\u0026#34;], # name of module that we\u0026#39;re going import ) build.sh or whatever you fancy.\n#!/bin/bash swig -c++ -python fib.i python setup.py build_ext --inplace 4. Run Assign permissions (e.g. chmod 755 build.sh) and run ./build.sh. From there you can go into the python console and test by running the following:\n$ python \u0026gt;\u0026gt;\u0026gt; import Fibonacci \u0026gt;\u0026gt;\u0026gt; Fibonacci.fibonacci(10) 55 5. Conclusion Please let me know if anything here can be improved so I can update this for future readers. Regardless, I hope this helped some of you with your projects/work and saved you some time.\n","permalink":"http://localhost:1313/posts/first/","summary":"\u003cp\u003eThis is a quick walk through of how to take c++ and run it with Python through bindings. If you find yourself wishing to learn more on the topic, \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig’s website\u003c/a\u003e for working with Python is a good start. My experience in setting this up was far more tedious than it had to be and I hope this will save people some time. As a note, I currently work on Ubuntu 16.04 and Python 2.7; this will be tailored to those dependencies, however, I do not believe any major changes will be required to the setup.py file based on \u003ca href=\"http://www.swig.org/Doc1.3/Python.html\"\u003eSwig\u0026rsquo;s website\u003c/a\u003e and a \u003ca href=\"https://stackoverflow.com/questions/32667888/building-extension-for-python-3-with-swig-and-distutils\"\u003eStackOverflow question for Python 3\u003c/a\u003e. In addition, the majority of operating systems should be covered by this walk through, with minor tweaks such as yum instead of apt-get for select operating systems.\u003c/p\u003e","title":"C++ to Python Bindings with Swig"},{"content":"Biemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). Paper\nBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). Paper\nBiemer, C., \u0026amp; Cooper, S. (2022, October). Level Assembly as a Markov Decision Process. In 2022 Proceedings of the Experimental AI in Games Workshop. Paper, Talk, Code\nBiemer, C., \u0026amp; Cooper, S. (2022, August). On Linking Level Segments. In 2022 IEEE Conference on Games (CoG) (pp. 199-205). ★ Best Paper Nominee Paper, Talk, Code\nBiemer, C., Hervella, A., \u0026amp; Cooper, S. (2021, August). Gram-Elites: N-Gram Based Quality-Diversity Search. In The 16th International Conference on the Foundations of Digital Games (FDG) 2021 (pp. 1-6). Paper, Talk, Code\nVillareale, J., Biemer, C., Seif El-Nasr, M., \u0026amp; Zhu, J. (2020, September). Reflection in Game-Based Learning: A Survey of Programming Games. In International Conference on the Foundations of Digital Games (pp. 1-9). Paper\n","permalink":"http://localhost:1313/publications/","summary":"\u003cp\u003eBiemer, C., \u0026amp; Cooper, S. (2024, May). Solution Path Heuristics for Predicting Difficulty and Enjoyment Ratings of Roguelike Level Segments. In Proceedings of the 19th International Conference on the Foundations of Digital Games (pp. 1-8). \u003cbr\u003e\n\u003ca href=\"/pdf/2024_solution_path_heuristics.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBiemer, C. F. (2023, October). Dynamic difficulty adjustment via procedural level generation guided by a Markov decision process for platformers and roguelikes. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (Vol. 19, No. 1, pp. 436-439). \u003cbr\u003e\n\u003ca href=\"/pdf/2023_ddaviaplgviamdp.pdf\"\u003ePaper\u003c/a\u003e\u003c/p\u003e","title":"Publications"}]